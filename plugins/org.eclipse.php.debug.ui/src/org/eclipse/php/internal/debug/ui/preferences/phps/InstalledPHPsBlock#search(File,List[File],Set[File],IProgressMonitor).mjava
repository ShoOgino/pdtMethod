	/**
	 * Searches the specified directory recursively for installed PHP
	 * executables, adding each detected executable to the <code>found</code>
	 * list. Any directories specified in the <code>ignore</code> are not
	 * traversed.
	 * 
	 * @param directory
	 * @param found
	 * @param types
	 * @param ignore
	 */
	protected void search(final File directory, final List<File> found,
			final Set<File> ignore, final IProgressMonitor monitor) {
		if (monitor.isCanceled())
			return;

		// Search the root directory
		if (!ignore.contains(directory)) {
			final File foundExe = findPHPExecutable(directory);
			if (foundExe != null)
				found.add(foundExe);
		}

		final String[] names = directory.list();
		if (names == null)
			return;
		final List<File> subDirs = new ArrayList<File>();
		for (String element : names) {
			if (monitor.isCanceled())
				return;
			final File file = new File(directory, element);
			// PHPexeItem[] vmTypes = phpExes.getEditableItems();
			if (file.isDirectory()) {
				try {
					monitor.subTask(MessageFormat.format(
							PHPDebugUIMessages.InstalledPHPsBlock_14,
							new Object[] { Integer.toString(found.size()),
									file.getCanonicalPath() }));
				} catch (final IOException e) {
				}
				if (!ignore.contains(file)) {
					if (monitor.isCanceled())
						return;
					final File foundExe = findPHPExecutable(file);
					if (foundExe != null) {
						found.add(foundExe);
						ignore.add(file);
					}
					subDirs.add(file);
				}
			}
		}
		while (!subDirs.isEmpty()) {
			final File subDir = subDirs.remove(0);
			search(subDir, found, ignore, monitor);
			if (monitor.isCanceled())
				return;
		}
	}

