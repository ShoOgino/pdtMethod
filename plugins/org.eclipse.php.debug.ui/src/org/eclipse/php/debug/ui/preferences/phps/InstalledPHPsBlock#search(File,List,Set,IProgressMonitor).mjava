	/**
	 * Searches the specified directory recursively for installed PHP executables, adding each
	 * detected executable to the <code>found</code> list. Any directories specified in
	 * the <code>ignore</code> are not traversed.
	 * 
	 * @param directory
	 * @param found
	 * @param types
	 * @param ignore
	 */
	protected void search(File directory, List found, Set ignore, IProgressMonitor monitor) {
		if (monitor.isCanceled()) {
			return;
		}

		// Search the root directory
		if (!ignore.contains(directory)) {
			File foundExe = PHPexeItem.findPHPExecutable(directory);
			if (foundExe != null) {
				found.add(foundExe);
			}
		}

		String[] names = directory.list();
		if (names == null) {
			return;
		}
		List subDirs = new ArrayList();
		for (int i = 0; i < names.length; i++) {
			if (monitor.isCanceled()) {
				return;
			}
			File file = new File(directory, names[i]);
			//			PHPexeItem[] vmTypes = phpExes.getEditableItems();
			if (file.isDirectory()) {
				try {
					monitor.subTask(MessageFormat.format(PHPDebugUIMessages.InstalledPHPsBlock_14, new String[] { Integer.toString(found.size()), file.getCanonicalPath() })); //$NON-NLS-1$
				} catch (IOException e) {
				}
				if (!ignore.contains(file)) {
					if (monitor.isCanceled()) {
						return;
					}
					File foundExe = PHPexeItem.findPHPExecutable(file);
					if (foundExe != null) {
						found.add(foundExe);
						ignore.add(file);
					}
					subDirs.add(file);
				}
			}
		}
		while (!subDirs.isEmpty()) {
			File subDir = (File) subDirs.remove(0);
			search(subDir, found, ignore, monitor);
			if (monitor.isCanceled()) {
				return;
			}
		}

	}

