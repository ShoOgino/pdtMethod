	/**
	 * Return best matching ICommunicationDaemons array.
	 * The returned ICommunicationDaemons are always new instances.
	 * In case of an error, null is returned.
	 * The basic PDT returned array of communication daemons contains all the daemons that
	 * were registered in the org.eclipse.php.debug.core plug-in name-space.
	 * In case that a different plug-in added another daemon, we add the new daemon to the list 
	 * and in case that the daemon extends the PDT daemon class, the PDT daemon will be removed from the
	 * list. This way we can make sure that enhanced daemons will be loaded on top of the daemons 
	 * they enhance.
	 * 
	 * Note that this method simply returns all the registered valid debug daemons. It does NOT take 
	 * into consideration the debugger type that is currently used by the PDT, and this should be handled 
	 * by the calling function by initializing the relevant daemons from the returned list.
	 * 
	 * @return New instances of a best match ICommunicationDaemons
	 */
	public static ICommunicationDaemon[] getBestMatchCommunicationDaemons() {
		try {
			Dictionary<String, CommunicationDaemonFactory> factories = getInstance().getDaemons();
			Enumeration<CommunicationDaemonFactory> e = factories.elements();
			ArrayList<ICommunicationDaemon> pdtDaemons = new ArrayList<ICommunicationDaemon>(5);
			ArrayList<ICommunicationDaemon> additionalDaemons = new ArrayList<ICommunicationDaemon>(5);
			while (e.hasMoreElements()) {
				CommunicationDaemonFactory initializerFactory = e.nextElement();
				ICommunicationDaemon initializerDaemon = initializerFactory.createDaemon();
				if (DEFAULT_DEBUG_DAEMONS_NAMESPACE.equals(initializerFactory.element.getNamespaceIdentifier())) {
					if (initializerDaemon.isEnabled()) {
						pdtDaemons.add(initializerDaemon);
					}
				} else {
					if (initializerDaemon.isEnabled()) {
						additionalDaemons.add(initializerDaemon);
					}
				}
			}
			// Create the final daemons list. 
			// Check if any of the additional daemons enhance one of the basic PDT daemons. In 
			// this case, we do not use the PDT daemon and remove it from the returned list.
			ArrayList<ICommunicationDaemon> daemons = new ArrayList<ICommunicationDaemon>(pdtDaemons.size() + 4);
			daemons.addAll(pdtDaemons);
			for (ICommunicationDaemon addedDaemon : additionalDaemons) {
				daemons.add(addedDaemon);
				for (ICommunicationDaemon pdtDaemon : pdtDaemons) {
					if (pdtDaemon.getClass().isAssignableFrom(addedDaemon.getClass())) {
						// in this case, remove the pdt daemon because it's a superclass of the 
						// enhanced plugin.
						daemons.remove(pdtDaemon);
					}
				}
			}
			ICommunicationDaemon[] daemonsLoaded = new ICommunicationDaemon[daemons.size()];
			daemons.toArray(daemonsLoaded);
			return daemonsLoaded;
		} catch (Exception e) {
			DaemonPlugin.log(e);
		}
		return null;
	}

