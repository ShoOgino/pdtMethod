		public void run() {

			while (isAlive) {

				while (!inWork && isAlive) {
					try {
						synchronized (WAIT) {
							synchronized (READY_FOR_RESTART_LOCK) {
								READY_FOR_RESTART_LOCK.notify(); // release one thread.
							}
							WAIT.wait();
						}

					} catch (InterruptedException e) {
					}
				}

				if (!isAlive)
					break;

				try {

					Object newInputMessage = inputMessageQueue.queueOut();

					// do not stop until the message is processed.
					synchronized (this) {
						try {
							if (newInputMessage instanceof DebugSessionStartedNotification) {
								hookDebugSession((DebugSessionStartedNotification) newInputMessage);
								if (getCommunicationClient() != null) {
									getCommunicationClient().handleNotification(newInputMessage);
								} else {
									handleConnectionClosed();
								}
							} else if (newInputMessage instanceof IDebugNotificationMessage) {
								getCommunicationClient().handleNotification(newInputMessage);
							} else if (newInputMessage instanceof IDebugRequestMessage) {

								IDebugMessageHandler requestHandler = createRequestHandler((IDebugRequestMessage) newInputMessage);

								if (requestHandler instanceof IDebugRequestHandler) {
									requestHandler.handle((IDebugRequestMessage) newInputMessage, debugTarget);
									IDebugResponseMessage response = ((IDebugRequestHandler) requestHandler).getResponseMessage();

									byteArray.reset();
									response.serialize(outArray);
									if (isDebugMode) {
										System.out.println("sending message size=" + byteArray.size()); //$NON-NLS-1$
									}
									synchronized (out) {
										out.writeInt(byteArray.size());
										byteArray.writeTo(out);
										out.flush();
									}
								} else {
									// error, we could not find the relevant request message handler for the received message.
								}
							} else if (newInputMessage instanceof IDebugResponseMessage) {
								IDebugResponseMessage r = (IDebugResponseMessage) newInputMessage;
								int requestId = r.getID(); // take the request ID from the response.
								IDebugRequestMessage req = (IDebugRequestMessage) requestsTable.remove(requestId); // find the request.
								ResponseHandler handler = responseHandlers.remove(new Integer(requestId)); // find the handler.
								handler.handleResponse(req, r);
							} else if (newInputMessage == STOP_MSG) {
								synchronized (STOP_MSG) {
									inWork = false;
									STOP_MSG.notifyAll();
									if (shouldExit) {
										isAlive = false;
										inputMessageQueue.releaseReaders(); // why do we need this??
										//notifyAll();
									}
								}
							} else if (newInputMessage == CONNECTION_CLOSED_MSG) {
								handleConnectionClosed();
								//inWork = false;
							}
							//else if (newInputMessage == MULTIPLE_BINDINGS_MSG){
							//    handleMultipleBindingsMessage();
							//}
							//else if (newInputMessage == PEER_RESPONSE_TIMEOUT_MSG){
							//    handlePeerResponseTimeoutMessage();
							//}

						} catch (Exception exc) { // error processing the current message.
							PHPDebugPlugin.log(exc);
						}
					}

				} catch (Exception exc) {
					//inWork = false;
					PHPDebugPlugin.log(exc);
				}
			}
		}

