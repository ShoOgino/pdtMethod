		/**
		 * @see java.lang.Thread#run()
		 */
		public void run() {
			while (isAlive) {

				while (!inWork && isAlive) {
					try {
						synchronized (this) {
							synchronized (READY_FOR_RESTART_LOCK) {
								READY_FOR_RESTART_LOCK.notify(); // release one thread.

							}
							wait();
							// This way we will start working until the connectionCreator
							// has finished updating the in + out.
							synchronized (in) {
							}
						}
					} catch (InterruptedException e) {
						if (isDebugMode) {
							System.out.println("interrupted: inWork = " + inWork + ", isAlive = " + isAlive);
						}
					}
				}

				try {

					if (!isAlive) {
						break;
					}

					// reads the length
					int num = in.readInt();
					if (isDebugMode) {
						System.out.println("recieved message size = " + num);
					}
					if (num < 0) {
						shutDown();
						if (isDebugMode) {
							System.out.println("Socket error (length is negative): possibly Server is SSL, Client is not.");
						}
						Logger.log(Logger.ERROR, "Socket error (length is negative): possibly Server is SSL, Client is not.");
					}
					// We have a new message. process it !!.
					// This part is synchronized since we do not want the thread to be stopped
					// when in processing of a message.
					synchronized (this) {
						int messageType = getMessageType(in);
						// If this is the first message, the protocol is still held as invalid.
						// Check that the first message has the DebugSessionStartedNotification type. If not, then we
						// can assume that the remote debugger protocol has a different version then expected.
						if (!validProtocol && messageType != startMessageId) {
							// display an error message that the protocol in used is wrong.
							final String errorMessage = MessageFormat.format(PHPDebugCoreMessages.Debugger_Incompatible_Protocol, new String[] { String.valueOf(RemoteDebugger.PROTOCOL_ID) });
							Status status = new Status(IStatus.ERROR, PHPDebugPlugin.getID(), IPHPConstants.INTERNAL_ERROR, errorMessage, null);
							DebugPlugin.log(status);
							Display.getDefault().asyncExec(new Runnable() {
								public void run() {
									MessageDialog.openError(Display.getDefault().getActiveShell(), "Debugger Error", errorMessage);
								}
							});
							shutDown();
							return;
						}
						validProtocol = true;
						if (isDebugMode) {
							System.out.println("message type=" + messageType);
						}

						IDebugMessage message = DebugMessagesRegistry.getMessage(messageType);
						if (message != null) {
							if (message instanceof OutputNotification) {
								message.setTransferEncoding(outputEncoding);
							} else {
								message.setTransferEncoding(transferEncoding);
							}
						}

						// handle the message
						if (message instanceof IDebugNotificationMessage) {
							if (isDebugMode) {
								System.out.println("Starting to read notification ");
							}
							message.deserialize(in);
							if (isDebugMode) {
								System.out.println("End reading of notification " + message);
							}
							//getCommunicationClient().handleNotification((Notification)message);
							//PUT NOTIFICATION TO NOTIFICATION QUEUE
							inputMessageHandler.queueIn(message);
						} else if (message instanceof IDebugResponseMessage) {
							if (isDebugMode) {
								System.out.println("Starting to read response");
							}
							message.deserialize(in);
							int idd = ((IDebugResponseMessage) message).getID();
							if (isDebugMode) {
								System.out.println("End reading of response " + message);
							}
							//responseQueue.queueIn(message);
							//INSERT RESPONSE TO TABLE AND RELEASE THE THREAD WAITING FOR THE REQUEST
							ResponseHandler handler = (ResponseHandler) responseHandlers.get(new Integer(idd)); // find the handler.
							if (handler == null) {
								responseTable.put(/*requestId*/idd, message);
								IDebugRequestMessage req = (IDebugRequestMessage) requestsTable.remove(idd); // find the request.
								if (req != null) {
									synchronized (req) {
										req.notifyAll(); // Notify the response is here.
									}
								} else {
									// Remove this message.
									responseTable.remove(idd);
								}
							} else {
								inputMessageHandler.queueIn(message);
							}
						} else if (message instanceof IDebugRequestMessage) { // this is a request.
							if (isDebugMode) {
								System.out.println("Starting to read request");
							}
							message.deserialize(in);
							if (isDebugMode) {
								System.out.println("End reading of request " + message);
							}
							//Response response =  getCommunicationClient().handleRequest((Request)message);
							inputMessageHandler.queueIn(message);
						}
					} // end of synchronized part.

				} catch (EOFException exc) {
					shutDown();
				} catch (SocketException exc) {
					shutDown();
				} catch (IOException exc) {
					PHPDebugPlugin.log(exc);
					shutDown();
				} catch (Exception exc) {
					PHPDebugPlugin.log(exc);
				}
			}
		}

