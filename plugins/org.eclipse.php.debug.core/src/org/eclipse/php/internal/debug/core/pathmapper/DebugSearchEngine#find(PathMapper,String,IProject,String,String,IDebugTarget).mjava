	/**
	 * Searches for all local resources that match provided remote file, and returns it in best match order.
	 * @param pathMapper Path mapper to look at
	 * @param remoteFile Path of the file on server. This argument must not be <code>null</code>.
	 * @param currentWorkingDir Current working directory of PHP process
	 * @param currentScriptDir Directory of current PHP file
	 * @param debugTarget Current debug target
	 * @return path entry or <code>null</code> in case it could not be found
	 * @throws InterruptedException
	 * @throws CoreException
	 */
	private static PathEntry find(PathMapper pathMapper, String remoteFile, IProject currentProject, String currentWorkingDir, String currentScriptDir, IDebugTarget debugTarget) throws InterruptedException, CoreException {

		// First, look into the path mapper:
		PathEntry localFile = pathMapper.getLocalFile(remoteFile);
		if (localFile != null) {
			return localFile;
		}

		VirtualPath abstractPath = new VirtualPath(remoteFile);
		LinkedList<PathEntry> results = new LinkedList<PathEntry>();

		Object[] includePaths;
		if (currentProject != null) {
			includePaths = PHPSearchEngine.buildIncludePath(currentProject);
		} else {
			// Search in the whole workspace:
			Set<Object> s = new HashSet<Object>();
			IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
			for (IProject project : projects) {
				PHPSearchEngine.buildIncludePath(project, s);
			}
			includePaths = s.toArray();
		}

		// Iterate over all include path, and search for a requested file
		for (Object includePath : includePaths) {
			if (includePath instanceof IContainer) {
				find((IContainer) includePath, abstractPath, results);
			} else if (includePath instanceof IIncludePathEntry) {
				IIncludePathEntry entry = (IIncludePathEntry) includePath;
				IPath entryPath = entry.getPath();
				if (entry.getEntryKind() == IIncludePathEntry.IPE_LIBRARY) {
					if (entry.getContentKind() != IIncludePathEntry.K_BINARY) { // We don't support lookup in archive
						File entryDir = entryPath.toFile();
						find(entryDir, abstractPath, entry, results);
					}
				} else if (entry.getEntryKind() == IIncludePathEntry.IPE_PROJECT) {
					IProject project = (IProject) entry.getResource();
					if (project.isAccessible()) {
						find(project, abstractPath, results);
					}
				} else if (entry.getEntryKind() == IIncludePathEntry.IPE_VARIABLE) {
					entryPath = IncludePathVariableManager.instance().resolveVariablePath(entryPath.toString());
					File entryDir = entryPath.toFile();
					find(entryDir, abstractPath, entry, results);
				}
			}
		}

		//search in opened editors
		searchOpenedEditors(results, abstractPath);

		if (results.size() > 0) {
			Collections.sort(results, new BestMatchPathComparator(abstractPath));
			localFile = filterItems(abstractPath, results.toArray(new PathEntry[results.size()]), debugTarget);
			if (localFile != null) {
				pathMapper.addEntry(remoteFile, localFile);
				PathMapperRegistry.storeToPreferences();
			}
		}
		return localFile;
	}

