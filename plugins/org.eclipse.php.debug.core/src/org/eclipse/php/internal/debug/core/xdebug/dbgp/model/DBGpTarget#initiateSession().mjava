	/**
	 * initiate the session, this cannot be called from the DBGpSession response
	 * handler thread as we install breakpoints synchronously and block waiting
	 * for the response thread to pick them up, so we will deadlock
	 * 
	 */
	private void initiateSession() {
		if (targetState != STATE_INIT_SESSION_WAIT
				&& targetState != STATE_STARTED_SESSION_WAIT) {
			DBGpLogger
					.logWarning(
							"initiateSession in Wrong State: " + targetState, this, null); //$NON-NLS-1$
		}
		stackFrames = null;
		currentVariables = null;
		superGlobalVars = null;
		// clear any previous debug output object and create a new one.
		debugOutput = new DebugOutput();

		session.startSession();

		// we are effectively suspended once the session has handshaked until we
		// run
		setState(STATE_STARTED_SUSPENDED);
		negotiateDBGpFeatures();
		loadPredefinedBreakpoints();
		if (!stopAtStart) {
			// set state before issuing a run otherwise a timing window occurs
			// where
			// a run could suspend, the thread sets state to suspend but then
			// this
			// thread sets it to running.
			setState(STATE_STARTED_RUNNING);
			session.sendAsyncCmd(DBGpCommand.run);
		} else {
			// first say we are suspended on a breakpoint to trigger a
			// perspective switch
			// then do an initial step into to step onto the 1st line
			suspended(DebugEvent.BREAKPOINT);
			try {
				stepInto();
			} catch (DebugException e) {
			}
		}
	}

