	/**
	 * parse the xml information for an object or array
	 * 
	 * @param property
	 */
	private void parseData(Node property) {
		/*
		 * children, numchildren, page, pagesize, recursive attribute page and
		 * pagesize only appear if you exceed the max_children option limit.
		 * Pagesize is the max_children limit. children can be zero, but we may
		 * as well get all the information we can, so no point checking the
		 * flag. We also need to make sure that DBGpVariable is not set to null
		 * here otherwise it will attempt to defer the info. This is ok for no
		 * children as page will be set to -1
		 */
		String type = DBGpResponse.getAttribute(property, "type"); //$NON-NLS-1$
		if (type.equals(DBGpVariable.PHP_OBJECT)) {
			containerType = IS_OBJECT;
			className = DBGpResponse.getAttribute(property, "classname"); //$NON-NLS-1$
		}
		String numChildStr = DBGpResponse.getAttribute(property, "numchildren"); //$NON-NLS-1$
		numChild = 0;
		if (numChildStr != null && numChildStr.trim().length() != 0) {
			try {
				numChild = Integer.parseInt(numChildStr);
			} catch (NumberFormatException nfe) {
				// do nothing
			}
		}
		String pageStr = null;
		String pageSizeStr = null;
		pageStr = DBGpResponse.getAttribute(property, "page"); //$NON-NLS-1$
		pageSizeStr = DBGpResponse.getAttribute(property, "pagesize"); //$NON-NLS-1$
		// TODO: currently getMaxChildren returns 0, may need to look into this.
		pageSize = ((DBGpTarget) getDebugTarget()).getMaxChildren();
		if (pageSizeStr != null && pageSizeStr.trim().length() != 0) {
			try {
				pageSize = Integer.parseInt(pageSizeStr);
			} catch (NumberFormatException nfe) {
				// do nothing
			}
		}
		page = -1;
		if (pageStr != null && pageStr.trim().length() != 0) {
			try {
				page = Integer.parseInt(pageStr);
			} catch (NumberFormatException nfe) {
				// do nothing
			}
		}
		if (page == -1 && numChild > pageSize) {
			// Assume the xdebug defect and set page = 0 to force container
			// control
			page = 0;
		}
		/*
		 * TODO: Improvement: nApplyCount > 1 in the zend hash table for an
		 * array or object String recursiveStr =
		 * DBGpResponse.getAttribute(property, "recursive");
		 */
		/*
		 * XDebug in 2.1 now outputs the page and pagesize attribute even if
		 * there is only a single page, ie page will never be -1 now. in xdebug
		 * 2.0.5, page will only be -1 if numChild <= pagesize, so we check for
		 * that (instead of page == -1) now which provides the required
		 * behaviour of no [x..y] type format.
		 */
		if (numChild <= pageSize || getOwner() instanceof DBGpContainerVariable) {
			/*
			 * we have a full set of entries or we have a complete subset within
			 * a ContainerVariable create a standard child entries that show the
			 * variables and their values
			 */
			NodeList childProperties = property.getChildNodes();
			int childrenReceived = childProperties.getLength();
			if (childrenReceived > 0) {
				childVariables = new DBGpVariable[childrenReceived];
				for (int i = 0; i < childrenReceived; i++) {
					Node childProperty = childProperties.item(i);
					childVariables[i] = new DBGpVariable(
							(DBGpTarget) getDebugTarget(), childProperty,
							getOwner().getStackLevel(),
							containerType == IS_OBJECT ? KIND_OBJECT_MEMBER
									: KIND_ARRAY_MEMBER);
				}
				if (containerType == IS_OBJECT)
					VariablesUtil.sortObjectMembers(childVariables);
			}
		} else {
			/*
			 * create container variables to handle a complete subset and that
			 * show their name as a container [x...y] in the debug view
			 */
			int subCount = roundUp((double) numChild / (double) pageSize);
			childVariables = new VirtualPartition[subCount];
			/*
			 * we can populate the 1st one, we assume page=0 here. TODO: xdebug
			 * appears to do strange things on the watch expression. For example
			 * // if I have expanded $a (array of 201 elements) then a watch
			 * doesn't get page 0, it could get page 4 for example.
			 * childVariables[0] = new DBGpContainerVariable(getDebugTarget(),
			 * page, pageSize, numChild, property, getOwner().getStackLevel(),
			 * getOwner().getFullName()); for (int i = 1; i < subCount; i++) {
			 * childVariables[i] = new DBGpContainerVariable(getDebugTarget(),
			 * page + i, pageSize, numChild, null, getOwner().getStackLevel(),
			 * getOwner().getFullName()); }
			 */
			for (int i = 0; i < subCount; i++) {
				int startIndex = i * pageSize;
				int endIndex = (i + 1) * pageSize - 1;
				if (endIndex > numChild) {
					endIndex = numChild - 1;
				}
				if (i == page) {
					// we have data for this page so pass the property info
					final IVariable var = new DBGpContainerVariable(
							getDebugTarget(), i, pageSize, numChild, property,
							getOwner().getStackLevel(), getOwner()
									.getFullName());
					IVariable partition = new VirtualPartition(this,
							new IVariableProvider() {
								@Override
								public IVariable[] getVariables()
										throws DebugException {
									return var.getValue().getVariables();
								}
							}, startIndex, endIndex);
					childVariables[i] = partition;
				} else {
					/*
					 * we don't have data for this page so create a container
					 * with no info, could be fetched later.
					 */
					final IVariable var = new DBGpContainerVariable(
							getDebugTarget(), i, pageSize, numChild, null,
							getOwner().getStackLevel(), getOwner()
									.getFullName());
					/*
					 * we copy the address from the original data as we could
					 * use it if we don't have a fullname from the variable, eg
					 * if an eval was done.
					 */
					((DBGpContainerVariable) var).setAddress(getOwner()
							.getAddress());
					IVariable partition = new VirtualPartition(this,
							new IVariableProvider() {
								@Override
								public IVariable[] getVariables()
										throws DebugException {
									return var.getValue().getVariables();
								}
							}, startIndex, endIndex);
					childVariables[i] = partition;
				}
			}
		}
	}

