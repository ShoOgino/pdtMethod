	protected ICompletionProposal[] calcCompletionProposals(PHPProjectModel projectModel) {
		if (codeDataProposals == null || codeDataProposals.length == 0) {
			return ContentAssistSupport.EMPTY_CodeDataCompletionProposal_ARRAY;
		}

		CodeData[] codeDatas = ModelSupport.getCodeDataStartingWith(codeDataProposals, key);

		// filter internal code data
		codeDatas = ModelSupport.removeFilteredCodeData(codeDatas, ModelSupport.INTERNAL_CODEDATA_FILTER);

		if (!groupOptions) {
			// this is the default option - just create proposals for each code data and return the array
			ICompletionProposal[] results = new ICompletionProposal[codeDatas.length];
			for (int i = 0; i < results.length; ++i) {
				results[i] = createElementProposal(projectModel, codeDatas[i]);
			}
			return results;
		}

		// else:
		// 1. Create tree of all the elements:
		final ElementTree completionTree = buildCompletionTree(projectModel, codeDatas);

		final Collection<ICompletionProposal> proposals = new ArrayList<ICompletionProposal>(codeDatas.length);
		if (completionTree.getChildCount(completionTree.getRoot()) > 0) {
			final Path root = COMPLETION_TREE_ROOT;
			// 2. Extract only the relevant element and group paths from the tree:
			final Collection<IPath> completionProposalPaths = calculateProposalPaths(completionTree, root, false);
			for (final IPath completionProposalPath : completionProposalPaths) {
				Object elementData = completionTree.getElementData(completionProposalPath);
				if (elementData != null) {
					proposals.add(createElementProposal(projectModel, elementData));
				} else {

					// show directories even if matched:
					IPath replacementPath = completionProposalPath.removeFirstSegments(1);
					String replacement = elementPathToName(replacementPath) + ELEMENT_NAME_SEPARATOR;
					proposals.add(createGroupProposal(completionProposalPath, replacement));
				}
			}
		}

		return proposals.toArray(new ICompletionProposal[proposals.size()]);
	}

