	/*
	 * @see IAutoIndentStrategy#customizeDocumentCommand
	 */
	public void customizeDocumentCommand(IDocument document, DocumentCommand command) {

		if (!isSmartMode())
			return;

		if (command.text != null) {
			if (command.length == 0) {
				// get legal end of line set
				String[] lineDelimiters = document.getLegalLineDelimiters();
				// get the the last index of end of line in the command
				int index = TextUtilities.endsWith(lineDelimiters, command.text);
				int offset = command.offset;

				// if end of line exists in the command
				if (index > -1) {
					// ends with line delimiter
					if (lineDelimiters[index].equals(command.text)) {
						try {
							IStructuredDocumentRegion sdRegion = ((IStructuredDocument) document).getRegionAtCharacterOffset(offset);
							//in case we're at the end of file, go on char back to be in region
							int fixedOffset = offset;
							if (offset == document.getLength()) {
								fixedOffset -= 1;
							}
							ITextRegion tRegion = sdRegion.getRegionAtCharacterOffset(fixedOffset);

							int regionOffset = offset;
							//if netsed html/php structure exists
							if (tRegion instanceof ITextRegionContainer) {
								tRegion = ((ITextRegionContainer) tRegion).getRegionAtCharacterOffset(fixedOffset);
								//update region offset for in order to get phpdoc region later
								regionOffset -= (sdRegion.getStartOffset(tRegion) + tRegion.getStart());
							}

							if (tRegion != null && tRegion instanceof IPhpScriptRegion) {
								IPhpScriptRegion scriptRegion = (IPhpScriptRegion) tRegion;

								//update region offset for in order to get phpdoc region later
								regionOffset -= scriptRegion.getStart();

								ITextRegion commentRegion = scriptRegion.getPhpToken(regionOffset);

								String tokenType = commentRegion.getType();
								if (document.getLength() == offset && (tokenType.equals(PHPRegionTypes.PHPDOC_COMMENT_END) || tokenType.equals(PHPRegionTypes.PHP_COMMENT_END)) && document.get(offset - 2, 2).equals("*/")) {

									ITextRegion region = commentRegion;
									//go up in document and search for the first line containing PHPDOC_COMMENT_START/PHP_COMMENT_START tag
									do {
										if (region.getType() == PHPRegionTypes.PHPDOC_COMMENT_START || region.getType() == PHPRegionTypes.PHP_COMMENT_START || region.getStart() <= scriptRegion.getStart()) {
											break;
										}
										//get previous region
										region = scriptRegion.getPhpToken(region.getStart() - lineDelimiters[index].length());

									} while (true);

									//get the line region
									IRegion line = document.getLineInformationOfOffset(region.getStart());
									StringBuffer buf = new StringBuffer(command.text);
									//extract indentation from the found line
									IRegion prefix = findCommentBlockStartPrefixRange(document, line);
									//build indentation based on the prefix length
									String indentation = document.get(prefix.getOffset(), prefix.getLength());
									buf.append(indentation);
									//perform the actual work
									command.shiftsCaret = false;
									command.caretOffset = command.offset + buf.length();
									command.text = buf.toString();
									return;
								}
							}
						} catch (BadLocationException e) {
							Logger.logException(e);
						}

						// just the line delimiter
						if (lineDelimiters[index].equals(command.text)) {
							indentAfterNewLine(document, command);
						}
						return;
					}
				}
			}

			if (command.text.equals("/")) { //$NON-NLS-1$
				indentAfterCommentEnd(document, command);
				return;
			}
		}
	}

