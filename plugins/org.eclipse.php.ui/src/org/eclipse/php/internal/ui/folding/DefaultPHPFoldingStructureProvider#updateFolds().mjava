	private void updateFolds() {
		IStructuredModel sModel = null;
		PHPFileData fileData = null;
		try {
			sModel = StructuredModelManager.getModelManager().getExistingModelForRead(document);
			if (sModel != null && sModel instanceof DOMModelForPHP) {
				DOMModelForPHP editorModel = (DOMModelForPHP) sModel;
				fileData = editorModel.getFileData();
				if (editorModel.getProjectModel() == null) {
					return;
				}
				if (fileData == null) {
					// create file data 
					IProject project = editorModel.getProjectModel().getProject();
					fileData = PHPFileDataUtilities.getFileData(new DocumentReader(document), project);
				} 
				workspaceModelManagerInstance.removeModelListener(this);
				ProjectionAnnotationModel model = viewer.getProjectionAnnotationModel();
				if (model != null) {
					synchronized (model.getLockObject()) {
						// Get the additions map that has a PHPProjectionAnnotation keys and AnnotatedPosition values
						Map additions = computeAdditions(fileData);
						toRemove.clear();
						newFolds.clear();

						// get the existing annotations. 
						// In this map we use the AnnotatedPosition as keys
						Iterator existing = model.getAnnotationIterator();
						LinkedHashMap exitingHashMap = new LinkedHashMap();
						while (existing.hasNext()) {
							ProjectionAnnotation existingAnnotation = (ProjectionAnnotation) existing.next();
							Position existingPosition = model.getPosition(existingAnnotation);
							exitingHashMap.put(existingPosition, existingAnnotation);
						}

						Iterator additionsIterator = additions.values().iterator();

						while (additionsIterator.hasNext()) {
							AnnotatedPosition addedPosition = (AnnotatedPosition) additionsIterator.next();
							// Try to remove the added Position from the existing positions.
							// If the position was found and removed, then it was not new. Otherwise, it's a new
							// one and we add it to the new folds. 
							//								addedPosition.hashCode()
							if (exitingHashMap.remove(addedPosition) == null) {
								newFolds.put(addedPosition.getAnnotation(), addedPosition);
							}
						}

						// At this stage we have the added map.
						// All the Annotations that are left in the hash need
						// to be removed from the model.
						boolean removeAnyway = false;
						Iterator annotationsToRemove = exitingHashMap.entrySet().iterator();
						while (annotationsToRemove.hasNext()) {
							Entry entry = (Entry) annotationsToRemove.next();
							AnnotatedPosition position = (AnnotatedPosition) entry.getKey();
							PHPProjectionAnnotation projectionToRemove = (PHPProjectionAnnotation) entry.getValue();
							// Check if this annotation should be removed.
							// Any expanded annotation should be removed.
							if (removeAnyway || !projectionToRemove.isCollapsed()) {
								toRemove.add(projectionToRemove);
							} else if (shouldRemoveAnnotation(projectionToRemove, position.offset)) {
								toRemove.add(projectionToRemove);
								// We can assume that any other fold that we have under this fold should be
								// removed since it's probably under a comment.
								removeAnyway = true;
							}
						}
						//						List removals = new LinkedList();
						//						model.getPosition((Annotation)removals.get(0));
						//						Iterator existing = model.getAnnotationIterator();
						//						while (existing.hasNext()) {
						//							removals.add(existing.next());
						//						}

						/*
						 *  Minimize the events being sent out - as this happens in the
						 *  UI thread merge everything into one call.
						 */
						if (toRemove.size() > 0 || newFolds.size() > 0) {
							model.replaceAnnotations((Annotation[]) toRemove.toArray(new Annotation[toRemove.size()]), newFolds);
						}
					}
				}
			}
		} catch (ArrayStoreException ase) {
			ase.printStackTrace();
		} finally {
			if (sModel != null) {
				sModel.releaseFromRead();
				if (fileData != null) {
					allowCollapsing = false;
				}
			}

		}
	}

