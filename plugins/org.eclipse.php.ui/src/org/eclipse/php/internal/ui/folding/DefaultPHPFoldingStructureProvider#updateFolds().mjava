	private void updateFolds() {
		IStructuredModel sModel = null;
		PHPFileData fileData = null;
		try {
			sModel = StructuredModelManager.getModelManager().getExistingModelForRead(document);
			if (sModel != null && sModel instanceof DOMModelForPHP) {
				DOMModelForPHP editorModel = (DOMModelForPHP) sModel;
				fileData = editorModel.getFileData();
				if (fileData == null) {
					// It's possible that while loading, the model is not yet ready, therefore, we will wait until the 
					// model fires the fileDataAdded event with the currect file data.
					// Fix bug #75
					return;
				}
				workspaceModelManagerInstance.removeModelListener(this);
				ProjectionAnnotationModel model = viewer.getProjectionAnnotationModel();
				if (model != null) {
					synchronized (model.getLockObject()) {
						// Get the additions map that has a PHPProjectionAnnotation keys and AnnotatedPosition values
						Map additions = computeAdditions(fileData);
						toRemove.clear();
						newFolds.clear();

						// get the existing annotations. 
						// In this map we use the AnnotatedPosition as keys
						Iterator existing = model.getAnnotationIterator();
						LinkedHashMap exitingHashMap = new LinkedHashMap();
						while (existing.hasNext()) {
							ProjectionAnnotation existingAnnotation = (ProjectionAnnotation) existing.next();
							Position existingPosition = model.getPosition(existingAnnotation);
							exitingHashMap.put(existingPosition, existingAnnotation);
						}

						Iterator additionsIterator = additions.values().iterator();

						while (additionsIterator.hasNext()) {
							AnnotatedPosition addedPosition = (AnnotatedPosition) additionsIterator.next();
							// Try to remove the added Position from the existing positions.
							// If the position was found and removed, then it was not new. Otherwise, it's a new
							// one and we add it to the new folds. 
							//								addedPosition.hashCode()
							if (exitingHashMap.remove(addedPosition) == null) {
								newFolds.put(addedPosition.getAnnotation(), addedPosition);
							}
						}

						// At this stage we have the added map.
						// All the Annotations that are left in the hash need
						// to be removed from the model.
						Iterator annotationsToRemove = exitingHashMap.values().iterator();
						while (annotationsToRemove.hasNext()) {
							toRemove.add(annotationsToRemove.next());
						}
						//						List removals = new LinkedList();
						//						model.getPosition((Annotation)removals.get(0));
						//						Iterator existing = model.getAnnotationIterator();
						//						while (existing.hasNext()) {
						//							removals.add(existing.next());
						//						}

						/*
						 *  Minimize the events being sent out - as this happens in the
						 *  UI thread merge everything into one call.
						 */
						if (toRemove.size() > 0 || newFolds.size() > 0) {
							model.replaceAnnotations((Annotation[]) toRemove.toArray(new Annotation[toRemove.size()]), newFolds);
						}
					}
				}
			}
		} catch (ArrayStoreException ase) {
			ase.printStackTrace();
		} finally {
			if (sModel != null) {
				sModel.releaseFromRead();
				if (fileData != null){
					allowCollapsing = false;
				}
			}
			
		}
	}

