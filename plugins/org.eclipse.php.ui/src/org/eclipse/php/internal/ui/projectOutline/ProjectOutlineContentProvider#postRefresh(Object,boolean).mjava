	public void postRefresh(final Object root, final boolean updateLabels) {
		if (fViewer == null || fViewer.getControl() == null)
			return;
		final Runnable runnable = new Runnable() {
			public void run() {
				if (fViewer == null) {
					return;
				}
				Control control = fViewer.getControl();
				if (control == null || control.isDisposed() || !control.isVisible()) {
					return;
				}
				/*
				 * XXX Sometimes refresh is called in the same time with the disposition.
				 * It means the previous check of disposition fulfills, but the refresh operations
				 * are not possible. We should think of a way of synchronization upon viewer's control
				 * to avoid such situations.
				 */
				IResource res = PHPModelUtil.getResource(root);
				if (res == null) {
					return;
				}
				if (res.getProject() != fStoredProject) {
					return;
				}
				PHPProjectModel model = null;
				model = PHPWorkspaceModelManager.getInstance().getModelForProject(res.getProject());
				for (OutlineNode outlineNode : groupNodes) {
					if (model != outlineNode.getModel())
						outlineNode.setModel(model);
					outlineNode.loadChildren();
					fViewer.refresh(outlineNode, true);
				}
				for (IPHPTreeContentProvider provider : treeProviders) {
					Object[] children = provider.getChildren(fStoredProject);
					if (children == null)
						continue;
					for (Object element : children) {
						fViewer.refresh(element, true);
					}
				}
				ISelection currentSelection = fViewer.getSelection();
				if (currentSelection.isEmpty()) {
					fViewer.setSelection(fViewer.getStoredSelection(), false);
				}
			}
		};
		if (timer != null) {
			timer.cancel();
		}
		timer = new Timer(true);
		timer.schedule(new TimerTask() {
			public void run() {
				if (!fViewer.getControl().isDisposed()) {
					fViewer.getControl().getDisplay().asyncExec(runnable);
				}
			}
		}, 1000);
	}

