	/**
	 * this function handles the case that the line of the event is the first line of the dockBloc
	 * @return the position in the document the caret should be at, at the end of the command.
	 * -1 if the caret should be at the end of the command.text
	 */
	private int handleDocBlockStart(IStructuredDocument document, DocumentCommand command, String blanks, boolean isDocBlock) {
		int rvPosition = 0;
		try {
			IRegion lineInfo = document.getLineInformationOfOffset(command.offset);
			int lineStart = lineInfo.getOffset();
			String line = document.get(lineStart, command.offset - lineStart);

			Matcher m = Pattern.compile("\\/\\*+").matcher(line);
			m.find();
			String commentStart = line.substring(m.start(), m.end());
			int commentStartLength = commentStart.length();
			command.text += "* ";
			rvPosition = command.offset + command.text.length();
			int selectionEnd = command.offset + command.length;
			if (isInsideExistingDocBlock(document, selectionEnd)) {
				return -1;
			}

			lineStart += line.indexOf(commentStart);
			String lineContent = line.substring(line.indexOf(commentStart) + commentStartLength).trim();
			rvPosition = lineStart + commentStartLength + command.text.length();
			// if there are whiteSpaces after the selection then we remove them too
			int lineEnd = selectionEnd;
			if (selectionEnd < lineInfo.getOffset() + lineInfo.getLength()) {
				lineInfo = document.getLineInformationOfOffset(selectionEnd);
			}

			if (isDocBlock && TypingPreferences.addDocTags) {
				//taking off the /** in order to find the closest codeData
				document.replace(lineStart, lineEnd - lineStart, "");
				command.offset = lineStart;

				// making sure the new fileData will be created after the deletion
				DOMModelForPHP editorModel = (DOMModelForPHP) StructuredModelManager.getModelManager().getModelForRead(document);
				editorModel.updateFileData();

				if (lineContent.equals("")) { //this is a patch in order to make PHPDescriptionTool add a default shortDescription
					lineContent = null;
				}

				String stub = getDocBlockStub(editorModel, document, lineStart, lineContent);

				editorModel.releaseFromRead();

				// putting back the /** that was taken off
				command.offset += commentStart.length();
				document.replace(lineStart, 0, commentStart);

				if (stub != null) {
					command.text = stub.substring(3);
					if (lineContent == null) {
						//this means that we added the default shortDescription to the docBlock
						//now we want to make sure this description will be selected in the editor 
						//at the end of the command
						String fileName = editorModel.getFileData().getName();
						IFile file = PHPUiPlugin.getWorkspace().getRoot().getFile(new Path(fileName));
						IEditorPart editorPart;
						try {
							editorPart = EditorUtility.openInEditor(file, true);
						} catch (PartInitException e) {
							Logger.logException(e);
							command.text = commentStart + command.text;
							return -1;
						}
						ITextEditor textEditor = EditorUtility.getPHPStructuredEditor(editorPart);
						//25 - stands for the shortDescription length
						//E - stands for the first latter in the shortDescription
						Display.getDefault().asyncExec(new SelectText(command.offset + command.text.indexOf("E"), 25, textEditor));
						return -1;
					}
					return rvPosition + lineContent.length();
				}
			} else {
				command.length += (command.offset - lineStart - commentStartLength);
				command.offset = lineStart + commentStartLength;
			}
			lineStart += commentStartLength;
			if (lineContent != null && !lineContent.equals("")) {
				command.text += lineContent;
				rvPosition = lineStart + command.text.length();
			}

		} catch (BadLocationException e) {
			Logger.logException(e);
		} finally {
			document.getUndoManager().enableUndoManagement();
		}
		command.text += document.getLineDelimiter() + blanks + "*/";
		return rvPosition;
	}

