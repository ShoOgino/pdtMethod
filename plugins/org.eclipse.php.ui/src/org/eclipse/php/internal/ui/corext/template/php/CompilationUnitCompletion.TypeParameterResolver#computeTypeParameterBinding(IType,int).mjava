		/**
		 * Given a type parameter of <code>superType</code> at position
		 * <code>index</code>, this method recursively computes the (lower)
		 * type bound(s) of that parameter for an instance of <code>fType</code>.
		 * <p>
		 * <code>superType</code> must be a super type of <code>fType</code>,
		 * and <code>superType</code> must have at least
		 * <code>index + 1</code> type parameters.
		 * </p>
		 * <p>
		 * The type bounds are stored in <code>fBounds</code>.
		 * </p>
		 * 
		 * @param superType the super type to compute the type parameter binding
		 *        for
		 * @param index the index into the list of type parameters of
		 *        <code>superType</code>
		 * @throws JavaModelException if any java model operation fails
		 * @throws IndexOutOfBoundsException if the index is not valid
		 */
		private void computeTypeParameterBinding(final IType superType, final int index) throws JavaModelException, IndexOutOfBoundsException {
			int nParameters= superType.getTypeParameters().length;
			if (nParameters <= index)
				throw new IndexOutOfBoundsException();
			
			IType[] subTypes= fHierarchy.getSubtypes(superType);
			
			if (subTypes.length == 0) {
				// we have reached down to the base type
				Assert.isTrue(superType.equals(fType));
				
				String match= findMatchingTypeArgument(fVariable.signature, index, fUnit.findPrimaryType());
				String bound= SignatureUtil.getUpperBound(match);
				
				// use the match whether it is a concrete type or not - if not,
				// the generic type will at least be in visible in our context
				// and can be referenced
				addBound(bound);
				return;
			}
			
			IType subType= subTypes[0]; // take the first, as they all lead to fType

			String signature= findMatchingSuperTypeSignature(subType, superType);
			String match= findMatchingTypeArgument(signature, index, subType);
			
			if (isConcreteType(match, subType)) {
				addBound(match);
				return;
			}
			
			ITypeParameter[] typeParameters= subType.getTypeParameters();
			
			for (int k= 0; k < typeParameters.length; k++) {
				ITypeParameter formalParameter= typeParameters[k];
				if (formalParameter.getElementName().equals(SignatureUtil.stripSignatureToFQN(match))) {
					String[] bounds= formalParameter.getBounds();
					for (int i= 0; i < bounds.length; i++) {
						String boundSignature= Signature.createTypeSignature(bounds[i], true);
						addBound(SignatureUtil.qualifySignature(boundSignature, subType));
					}
					computeTypeParameterBinding(subType, k);
					return;
				}
			}
			
			// We have a non-concrete type argument T, but no matching type
			// parameter in the sub type. This can happen if T is declared in
			// the enclosing type. Since it the declaration is probably visible
			// then, its fine to simply copy the match to the bounds and return.
			addBound(match);
			return;
		}

