	/**
	 * Converts a map of IValidatorForReconcile to List to annotations based
	 * on those messages
	 * 
	 * @param messages
	 * @return
	 */
	protected IReconcileResult[] createAnnotations(List messageList) {
		List annotations = new ArrayList();
		for (int i = 0; i < messageList.size(); i++) {
			IMessage validationMessage = (IMessage) messageList.get(i);

			int offset = validationMessage.getOffset();

			if (offset < 0)
				continue;

			String messageText = null;
			try {
				messageText = validationMessage.getText(validationMessage.getClass().getClassLoader());
			} catch (Exception t) {
				Logger.logException("exception reporting message from validator", t); //$NON-NLS-1$
				continue;
			}
			String type = TemporaryAnnotation.ANNOT_INFO;
			switch (validationMessage.getSeverity()) {
				case IMessage.HIGH_SEVERITY:
					type = TemporaryAnnotation.ANNOT_ERROR;
					break;
				case IMessage.NORMAL_SEVERITY:
					type = TemporaryAnnotation.ANNOT_WARNING;
					break;
				case IMessage.LOW_SEVERITY:
					type = TemporaryAnnotation.ANNOT_WARNING;
					break;
				case IMessage.ERROR_AND_WARNING:
					type = TemporaryAnnotation.ANNOT_WARNING;
					break;
			}

			int length = validationMessage.getLength();
			if (length >= 0) {
				Position p = new Position(offset, length);
				IStructuredDocument structuredDocument = getStructuredDocument();
				ReconcileAnnotationKey key = createKey(structuredDocument.getRegionAtCharacterOffset(offset), ReconcileAnnotationKey.TOTAL);
				annotations.add(new TemporaryAnnotation(p, type, messageText, key));
			}
		}

		return (IReconcileResult[]) annotations.toArray(new IReconcileResult[annotations.size()]);
	}

