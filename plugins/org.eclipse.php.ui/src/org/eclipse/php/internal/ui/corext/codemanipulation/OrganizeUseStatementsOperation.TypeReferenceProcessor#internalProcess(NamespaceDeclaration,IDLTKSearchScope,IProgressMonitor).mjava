		private boolean internalProcess(NamespaceDeclaration namespace, IDLTKSearchScope scope,
				IProgressMonitor monitor) throws ModelException {
			int nUnresolved = fUnresolvedTypes.get(namespace).size();
			if (nUnresolved == 0) {
				return false;
			}
			final ArrayList<TypeNameMatch> typesFound = new ArrayList<>();
			TypeNameMatchCollector collector = new TypeNameMatchCollector(typesFound);
			for (Iterator<String> iter = fUnresolvedTypes.get(namespace).keySet().iterator(); iter.hasNext();) {
				ModelAccess modelAccess = new ModelAccess();
				IType[] types = modelAccess.findTypes(iter.next(), MatchRule.EXACT, 0, 0, scope, monitor);
				for (IType type : types) {
					TypeNameMatch match = new PHPSearchTypeNameMatch(type, type.getFlags());
					collector.acceptTypeNameMatch(match);
				}
			}

			for (int i = 0; i < typesFound.size(); i++) {
				TypeNameMatch curr = typesFound.get(i);
				UnresolvedTypeData data = fUnresolvedTypes.get(namespace).get(curr.getSimpleTypeName());
				if (data != null && isOfKind(curr, data.typeKinds)) {
					if (fAllowDefaultPackageImports || curr.getPackageName().length() > 0) {
						data.addInfo(curr);
					}
				}
			}

			for (Entry<String, UnresolvedTypeData> entry : fUnresolvedTypes.get(namespace).entrySet()) {
				if (entry.getValue().foundInfos.size() == 0) { // No
																// result
																// found
																// in
																// search
					Set<String> matchingUnresolvableImports = fUnresolvableImportMatcher.matchTypeImports(namespace,
							entry.getKey());
					if (!matchingUnresolvableImports.isEmpty()) {
						// If there are matching unresolvable import(s),
						// rely on them to provide the type.
						for (String string : matchingUnresolvableImports) {
							fImpStructure.addImport(namespace, string, UNRESOLVABLE_IMPORT_CONTEXT);
						}
					}
				}
			}

			ArrayList<TypeNameMatch[]> openChoices = new ArrayList<>(nUnresolved);
			ArrayList<SourceRange> sourceRanges = new ArrayList<>(nUnresolved);
			for (Iterator<UnresolvedTypeData> iter = fUnresolvedTypes.get(namespace).values().iterator(); iter
					.hasNext();) {
				UnresolvedTypeData data = iter.next();
				TypeNameMatch[] openChoice = processTypeInfo(namespace, data.foundInfos);
				if (openChoice != null) {
					openChoices.add(openChoice);
					sourceRanges.add(new SourceRange(data.ref.getStart(), data.ref.getLength()));
				}
			}
			if (openChoices.isEmpty()) {
				return false;
			}
			fOpenChoices.put(namespace, openChoices.toArray(new TypeNameMatch[openChoices.size()][]));
			fSourceRanges.put(namespace, sourceRanges.toArray(new SourceRange[sourceRanges.size()]));
			return true;

		}

