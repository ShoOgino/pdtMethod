	private Collection<IPath> calculateProposalPaths(final ElementTree completionTree, final IPath root, boolean hasBrothers) {
		if (completionTree == null)
			return null;
		Collection<IPath> originalPath = Arrays.asList(new IPath[] { root });
		final int childCount = completionTree.getChildCount(root);
		if (childCount == 0) {
			if (completionTree.getElementData(root) != null)
				return originalPath;
			return null;
		}
		final IPath[] childrenRoots = completionTree.getChildren(root);
		boolean allEqual = childCount > 1;
		if (allEqual) {
			for (int i = 0; i < childrenRoots.length; i++) {
				if (i + 1 < childrenRoots.length && !childrenRoots[i].lastSegment().equalsIgnoreCase(childrenRoots[i + 1].lastSegment())) {
					allEqual = false;
					break;
				}
			}
		}
		if (childCount > 1 && hasBrothers)
			return originalPath;
		final Collection<IPath> childCompletions = new ArrayList();
		final boolean childHasBrothers = childCount > 1 && !allEqual;

		for (final IPath childRoot : childrenRoots) {
			final Collection<IPath> childCompletionProposal = calculateProposalPaths(completionTree, childRoot, hasBrothers || childHasBrothers);
			if (childCompletionProposal != null)
				childCompletions.addAll(childCompletionProposal);
		}
		return childCompletions;
	}

