	/**
	 * Inserts USE statement into beginning of the document, or after the last
	 * USE statement.
	 * 
	 * @param document
	 * @param textViewer
	 * @param offset
	 * @return new offset
	 */
	public int inject(IDocument document, ITextViewer textViewer, int offset) {
		IModelElement modelElement = proposal.getModelElement();

		if (modelElement instanceof FakeConstructor) {
			FakeConstructor fc = (FakeConstructor) modelElement;
			if (fc.getParent() instanceof AliasType) {
				return offset;
			}

		} else if (modelElement instanceof AliasType
				|| modelElement instanceof AliasMethod
				|| modelElement instanceof AliasField) {
			return offset;
		}
		if (modelElement == null)
			return offset;
		if (proposal instanceof IPHPCompletionProposalExtension) {
			IPHPCompletionProposalExtension phpCompletionProposal = (IPHPCompletionProposalExtension) proposal;
			if (ProposalExtraInfo.isNotInsertUse(phpCompletionProposal
					.getExtraInfo())) {
				return offset;
			}
		}

		try {
			// quanlified namespace should return offset directly
			if (offset - proposal.getReplacementLength() > 0
					&& document.getChar(offset
							- proposal.getReplacementLength() - 1) == NamespaceReference.NAMESPACE_SEPARATOR) {
				return offset;
			}
			if (modelElement.getElementType() == IModelElement.TYPE
					&& PHPFlags.isNamespace(((IType) modelElement).getFlags())) {
				if (offset - proposal.getReplacementLength() > 0) {
					String prefix = document.get(
							offset - proposal.getReplacementLength(),
							proposal.getReplacementLength());
					String fullName = ((IType) modelElement).getElementName();
					if (fullName.startsWith(prefix)
							&& prefix
									.indexOf(NamespaceReference.NAMESPACE_SEPARATOR) < 0) {
						// int
						ITextEditor textEditor = ((PHPStructuredTextViewer) textViewer)
								.getTextEditor();
						if (textEditor instanceof PHPStructuredEditor) {
							IModelElement editorElement = ((PHPStructuredEditor) textEditor)
									.getModelElement();
							if (editorElement != null) {
								ISourceModule sourceModule = ((ModelElement) editorElement)
										.getSourceModule();

								String namespaceName = fullName;
								int nsSeparatorIndex = fullName
										.indexOf(NamespaceReference.NAMESPACE_SEPARATOR);
								if (nsSeparatorIndex > 0) {
									namespaceName = fullName.substring(0,
											nsSeparatorIndex);
								}
								String usePartName = namespaceName;
								boolean useAlias = !Platform
										.getPreferencesService()
										.getBoolean(
												PHPCorePlugin.ID,
												PHPCoreConstants.CODEASSIST_INSERT_FULL_QUALIFIED_NAME_FOR_NAMESPACE,
												true, null);

								ModuleDeclaration moduleDeclaration = SourceParserUtil
										.getModuleDeclaration(sourceModule);

								ASTParser parser = ASTParser
										.newParser(sourceModule);
								parser.setSource(document.get().toCharArray());
								Program program = parser.createAST(null);

								// don't insert USE statement for current
								// namespace
								if (isSameNamespace(namespaceName, program,
										sourceModule, offset)) {
									return offset;
								}

								// find existing use statement:
								UsePart usePart = ASTUtils
										.findUseStatementByNamespace(
												moduleDeclaration, usePartName,
												offset);

								List<String> importedTypeName = getImportedTypeName(
										moduleDeclaration, offset);
								String typeName = namespaceName;

								// if the class/namesapce has not been imported
								// add use statement
								if (!importedTypeName.contains(typeName)) {

									program.recordModifications();
									AST ast = program.getAST();
									NamespaceName newNamespaceName = ast
											.newNamespaceName(
													createIdentifiers(ast,
															usePartName),
													false, false);
									UseStatementPart newUseStatementPart = ast
											.newUseStatementPart(
													newNamespaceName, null);
									UseStatement newUseStatement = ast
											.newUseStatement(
													Arrays.asList(new UseStatementPart[] { newUseStatementPart }),
													UseStatement.T_NONE);

									NamespaceDeclaration currentNamespace = getCurrentNamespace(
											program, sourceModule, offset - 1);
									if (currentNamespace != null) {
										List<Statement> statements = currentNamespace
												.getBody().statements();
										// insert in the beginning of the
										// current namespace:
										insertUseStatement(offset,
												newUseStatement, statements,
												document);
									} else {
										insertUseStatement(offset,
												newUseStatement,
												program.statements(), document);
									}

									ast.setInsertUseStatement(true);
									TextEdit edits = program.rewrite(document,
											createOptions(modelElement));
									edits.apply(document);
									ast.setInsertUseStatement(false);

									int replacementOffset = proposal
											.getReplacementOffset()
											+ edits.getLength();
									offset += edits.getLength();
									proposal.setReplacementOffset(replacementOffset);
								} else if (!useAlias
										&& (usePart == null || !usePartName
												.equals(usePart
														.getNamespace()
														.getFullyQualifiedName()))) {
									// if the type name already exists, use
									// fully
									// qualified name to replace
									proposal.setReplacementString(NamespaceReference.NAMESPACE_SEPARATOR
											+ fullName);
								}
							}
						}

					}
					return offset;
				}
				return offset;
			} else
			// class members should return offset directly
			if (modelElement.getElementType() != IModelElement.TYPE
					&& !(modelElement instanceof FakeConstructor)) {
				IModelElement type = modelElement
						.getAncestor(IModelElement.TYPE);
				if (type != null
						&& !PHPFlags.isNamespace(((IType) type).getFlags())) {
					return offset;
				}
			}
		} catch (Exception e) {
			PHPUiPlugin.log(e);
		}

		return addUseStatement(modelElement, document, textViewer, offset);
	}

