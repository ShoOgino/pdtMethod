		/**
		 * Finds and returns the type argument with index <code>index</code>
		 * in the given type super type signature. If <code>signature</code>
		 * is a generic signature, the type parameter at <code>index</code> is
		 * extracted. If the type parameter is an upper bound (<code>? super SomeType</code>),
		 * the type signature of <code>java.lang.Object</code> is returned.
		 * <p>
		 * Also, if <code>signature</code> has no type parameters (i.e. is a
		 * reference to the raw type), the type signature of
		 * <code>java.lang.Object</code> is returned.
		 * </p>
		 * 
		 * @param signature the super type signature from a type's
		 *        <code>extends</code> or <code>implements</code> clause
		 * @param index the index of the type parameter to extract from
		 *        <code>signature</code>
		 * @param context the type context inside which unqualified types should
		 *        be resolved
		 * @return the type argument signature of the type parameter at
		 *         <code>index</code> in <code>signature</code>
		 * @throws IndexOutOfBoundsException if the index is not valid
		 */
		private String findMatchingTypeArgument(String signature, int index, IType context) throws IndexOutOfBoundsException {
			String[] typeArguments= Signature.getTypeArguments(signature);
			if (typeArguments.length > 0 && typeArguments.length <= index)
				throw new IndexOutOfBoundsException();
			if (typeArguments.length == 0) {
				// raw binding - bound to Object
				return OBJECT_SIGNATURE;
			} else {
				String bound= SignatureUtil.getUpperBound(typeArguments[index]);
				return SignatureUtil.qualifySignature(bound, context);
			}
		}

