		/**
		 * Returns <code>true</code> if the receiver's type is an implementor
		 * of <code>interfaceName</code>.
		 * 
		 * @param supertype the fully qualified name of the interface
		 * @return <code>true</code> if the receiver's type implements the
		 *         type named <code>interfaceName</code>
		 */
		private boolean isSubtypeOf(String supertype) {
			String implementorName= SignatureUtil.stripSignatureToFQN(signature);
			if (implementorName.length() == 0)
				return false;
			
			boolean qualified= supertype.indexOf('.') != -1;
			
			// try cheap test first
			if (implementorName.equals(supertype) || !qualified && Signature.getSimpleName(implementorName).equals(supertype))
				return true;

			if (fUnit == null)
				return false;

			IJavaProject project= fUnit.getJavaProject();

			try {
				IType sub= project.findType(implementorName);
				if (sub == null)
					return false;
				
				if (qualified) {
					IType sup= project.findType(supertype);
					if (sup == null)
						return false;
					ITypeHierarchy hierarchy= sub.newSupertypeHierarchy(null);
					return hierarchy.contains(sup);
				} else {
					ITypeHierarchy hierarchy= sub.newSupertypeHierarchy(null);
					IType[] allTypes= hierarchy.getAllTypes();
					for (int i= 0; i < allTypes.length; i++) {
						IType type= allTypes[i];
						if (type.getElementName().equals(supertype))
							return true;
					}
				}

			} catch (JavaModelException e) {
				// ignore and return false
			}			
			
			return false;
		}

