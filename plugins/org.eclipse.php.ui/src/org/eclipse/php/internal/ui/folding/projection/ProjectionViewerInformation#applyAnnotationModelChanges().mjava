	/**
	 * Applies the pending projection annotation model changes to the
	 * projection annotation model.
	 */
	void applyAnnotationModelChanges() {
		List<ProjectionAnnotationModelChanges> queuedChanges = getQueuedAnnotationChanges();
		// go through all the pending annotation changes and apply:
		while (!queuedChanges.isEmpty()) {
			ProjectionAnnotationModelChanges changes = queuedChanges.remove(0);
			try {
				// 1. Collect annotations and their positions and store collapsed ones:
				Set<Position> collapsedPositions = new HashSet<Position>();
				Map<Position, ProjectionAnnotation> positionAnnotations = new HashMap<Position, ProjectionAnnotation>();
				for (Iterator<ProjectionAnnotation> i = fProjectionAnnotationModel.getAnnotationIterator(); i.hasNext();) {
					ProjectionAnnotation existingAnnotation = i.next();
					Position position = fProjectionAnnotationModel.getPosition(existingAnnotation);
					if (existingAnnotation.isCollapsed() && inScript(position.offset)) {
						collapsedPositions.add(position);
					}
					positionAnnotations.put(position, existingAnnotation);
				}

				// 2. Delete the annotations marked as deleted, if they are not collapsed:
				Annotation[] deletions = changes.getDeletions();
				if (deletions == null) {
					deletions = EMPTY_ANNOTATIONS;
				}
				Set<Position> persistentPositions = new HashSet<Position>(deletions.length);
				Collection<Annotation> finalDeletions = new ArrayList<Annotation>(1); 
				for (Annotation deletion : deletions) {
					Position position = fProjectionAnnotationModel.getPosition(deletion);
					if (!collapsedPositions.contains(position)) {
						finalDeletions.add(deletion);
					} else {
						persistentPositions.add(position);
					}
				}

				// 3. Add missing annotations or replace existing ones with same persistent position:
				Map<ProjectionAnnotation, Position> additions = changes.getAdditions();
				for (Map.Entry<ProjectionAnnotation, Position> addition : additions.entrySet()) {
					Position position = addition.getValue();
					ProjectionAnnotation newAnnotation = addition.getKey();
					if (!persistentPositions.contains(position)) {
						fProjectionAnnotationModel.addAnnotation(newAnnotation, position);
					} else {
						ProjectionAnnotation existingAnnotation = positionAnnotations.get(position);
						if (existingAnnotation.isCollapsed()) {
							newAnnotation.markCollapsed();
						} else {
							newAnnotation.markExpanded();
						}
						Map annotationAddition = new HashMap(1);
						annotationAddition.put(newAnnotation, position);
						fProjectionAnnotationModel.replaceAnnotations(new Annotation[] { existingAnnotation }, annotationAddition);
					}
				}

				//4. Replace positions for modified annotations or add if missing and not persistent:
				Map<ProjectionAnnotation, Position> modifications = changes.getModifications();
				List<Annotation> annotationsToModify = new ArrayList<Annotation>();
				if (modifications != null) {
					for (Map.Entry<ProjectionAnnotation, Position> modification : modifications.entrySet()) {
						ProjectionAnnotation modifiedAnnotation = modification.getKey();
						Position modifiedPosition = modification.getValue();
						Position position = fProjectionAnnotationModel.getPosition(modifiedAnnotation);
						if (position == null) {
							if (!persistentPositions.contains(modifiedPosition)) {
								fProjectionAnnotationModel.addAnnotation(modifiedAnnotation, modifiedPosition);
							}
						} else if (!modifiedPosition.equals(position)) {
							annotationsToModify.add(modifiedAnnotation);
						}
					}
				}

				// call the modification event only after all annotations are validated as should modified
				fProjectionAnnotationModel.modifyAnnotations(finalDeletions.toArray(new Annotation[finalDeletions.size()]), null, annotationsToModify.toArray(new Annotation[annotationsToModify.size()]));	

			} catch (RuntimeException e) {
				Logger.logException(e);
			}
		}
	}

