	/**
	 * Applies the pending projection annotation model changes to the
	 * projection annotation model.
	 */
	void applyAnnotationModelChanges() {
		List<ProjectionAnnotationModelChanges> queuedChanges = getQueuedAnnotationChanges();
		// go through all the pending annotation changes and apply:
		while (!queuedChanges.isEmpty()) {
			ProjectionAnnotationModelChanges changes = queuedChanges.remove(0);
			try {
				// 1. Collect annotations and their positions and store collapsed ones:
				Set<Position> collapsedPositions = new HashSet<Position>();
				Map<Position, ProjectionAnnotation> positionAnnotations = new HashMap<Position, ProjectionAnnotation>();
				for (Iterator<ProjectionAnnotation> i = fProjectionAnnotationModel.getAnnotationIterator(); i.hasNext();) {
					ProjectionAnnotation existingAnnotation = i.next();
					Position position = fProjectionAnnotationModel.getPosition(existingAnnotation);
					if (existingAnnotation.isCollapsed()) {
						collapsedPositions.add(position);
					}
					positionAnnotations.put(position, existingAnnotation);
				}

				// 2. Delete the annotations marked as deleted, if they are not collapsed:
				Annotation[] deletions = changes.getDeletions();
				if (deletions == null) {
					deletions = EMPTY_ANNOTATIONS;
				}
				Set<Position> shouldNotDelete = new HashSet<Position>(deletions.length);
				for (Annotation deletion : deletions) {
					Position position = fProjectionAnnotationModel.getPosition(deletion);
					if (!collapsedPositions.contains(position)) {
						// fProjectionAnnotationModel.removeAnnotation(deletion);
						// System.out.println("removed");
					} else {
						shouldNotDelete.add(position);
					}
				}

				// 3. Add missing annotations or replace existing ones with same persistent position:
				Map<ProjectionAnnotation, Position> additions = changes.getAdditions();
				for (Map.Entry<ProjectionAnnotation, Position> addition : additions.entrySet()) {
					Position position = addition.getValue();
					ProjectionAnnotation newAnnotation = addition.getKey();
					if (!shouldNotDelete.contains(position)) {
						final Position position2 = fProjectionAnnotationModel.getPosition(newAnnotation);
						if (position2 == null) {
							fProjectionAnnotationModel.addAnnotation(newAnnotation, position);
						}
					} else {
						ProjectionAnnotation existingAnnotation = positionAnnotations.get(position);
						if (!existingAnnotation.isCollapsed()) {
							newAnnotation.markExpanded();
							Map annotationAddition = new HashMap(1);
							annotationAddition.put(newAnnotation, position);
							fProjectionAnnotationModel.replaceAnnotations(new Annotation[] { existingAnnotation }, annotationAddition);
						}
					}
				}

				//4. Replace positions for modified annotations or add if missing and not persistent:
				Map<ProjectionAnnotation, Position> modifications = changes.getModifications();
				if (modifications != null) {
					for (Map.Entry<ProjectionAnnotation, Position> modification : modifications.entrySet()) {
						ElementProjectionAnnotation modifiedAnnotation = (ElementProjectionAnnotation) modification.getKey();
						Position modifiedPosition = modification.getValue();
						Position position = fProjectionAnnotationModel.getPosition(modifiedAnnotation);
						if (position == null) {
							if (!shouldNotDelete.contains(modifiedPosition)) {
								// fProjectionAnnotationModel.addAnnotation(modifiedAnnotation, modifiedPosition);
								// System.out.println("added " + modifiedAnnotation.toString());
							}
						} else if (!modifiedPosition.equals(position) && modifiedAnnotation.sameSize) {
							fProjectionAnnotationModel.modifyAnnotationPosition(modifiedAnnotation, modifiedPosition);
							break;
						}
					}
				}

			} catch (RuntimeException e) {
				Logger.logException(e);
			}
		}
	}

