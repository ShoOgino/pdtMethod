	/**
	 * Does any node in <code>edit1</code> overlap with any other node
	 * in <code>edit2</code>.
	 * <p>If this returns true then the two edit trees can be merged into one.</p>
	 *
	 * @param edit1 the edit to compare against edit2
	 * @param edit2 the edit to compare against edit1
	 * @return true of no node overlaps with any other node
	 * @since 3.4
	 */
	public static boolean overlaps(TextEdit edit1, TextEdit edit2) {
		if (edit1 instanceof MultiTextEdit && edit2 instanceof MultiTextEdit) {
			MultiTextEdit multiTextEdit1= (MultiTextEdit)edit1;
			if (!multiTextEdit1.hasChildren())
				return false;

			MultiTextEdit multiTextEdit2= (MultiTextEdit)edit2;
			if (!multiTextEdit2.hasChildren())
				return false;

			TextEdit[] children1= multiTextEdit1.getChildren();
			TextEdit[] children2= multiTextEdit2.getChildren();

			int i1= 0;
			int i2= 0;
			while (i1 < children1.length && i2 < children2.length) {
				while (children1[i1].getExclusiveEnd() < children2[i2].getOffset()) {
					i1++;
					if (i1 >= children1.length)
						return false;
				}
				while (children2[i2].getExclusiveEnd() < children1[i1].getOffset()) {
					i2++;
					if (i2 >= children2.length)
						return false;
				}

				if (children1[i1].getExclusiveEnd() < children2[i2].getOffset())
					continue;

				if (overlaps(children1[i1], children2[i2]))
					return true;

				int mergeEnd= Math.max(children1[i1].getExclusiveEnd(), children2[i2].getExclusiveEnd());

				i1++;
				i2++;

				if (i1 < children1.length && children1[i1].getOffset() < mergeEnd) {
					return true;
				}
				if (i2 < children2.length && children2[i2].getOffset() < mergeEnd) {
					return true;
				}
			}

			return false;
		} else if (edit1 instanceof MultiTextEdit) {
			MultiTextEdit multiTextEdit1= (MultiTextEdit)edit1;
			if (!multiTextEdit1.hasChildren())
				return false;

			TextEdit[] children= multiTextEdit1.getChildren();

			int i= 0;
			while (children[i].getExclusiveEnd() < edit2.getOffset()) {
				i++;
				if (i >= children.length)
					return false;
			}



			if (overlaps(children[i], edit2))
				return true;

			return false;
		} else if (edit2 instanceof MultiTextEdit) {
			MultiTextEdit multiTextEdit2= (MultiTextEdit)edit2;
			if (!multiTextEdit2.hasChildren())
				return false;

			TextEdit[] children= multiTextEdit2.getChildren();

			int i= 0;
			while (children[i].getExclusiveEnd() < edit1.getOffset()) {
				i++;
				if (i >= children.length)
					return false;
			}

			if (overlaps(children[i], edit1))
				return true;

			return false;
		} else {
			int start1= edit1.getOffset();
			int end1= start1 + edit1.getLength();
			int start2= edit2.getOffset();
			int end2= start2 + edit2.getLength();

			if (start1 > end2)
				return false;

			if (start2 > end1)
				return false;

			return true;
		}
	}

