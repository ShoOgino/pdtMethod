	/**
	 * Handles partition boundaries within the selection. The end of the current
	 * partition and the start of the next partition are examined for whether
	 * they contain comment tokens that interfere with the created comment.
	 * <p>
	 * Comment tokens are removed from interior multi-line comments. PHPdoc
	 * comments are left as is; instead, multi-line comment tokens are inserted
	 * before and after PHPdoc partitions to ensure that the entire selected
	 * area is commented.
	 * </p>
	 * <p>
	 * The next partition is returned.
	 * </p>
	 * 
	 * @param partition the current partition
	 * @param multiEdit container of edits
	 * @param docExtension the document to get the partitions from
	 * @return the next partition after the current
	 * @param offset where the PHP script region starts
	 * @throws BadLocationException if accessing the document fails - this can only happen if the document gets modified concurrently
	 * @throws BadPartitioningException if the document does not have a PHP partitioning
	 */
	private ITypedRegion handleInteriorPartition(ITypedRegion partition, MultiTextEdit multiEdit, IDocumentExtension3 docExtension, int phpRegionStart) throws BadPartitioningException, BadLocationException {

		// end of previous partition
		String partType = partition.getType();
		int partEndOffset = phpRegionStart + partition.getOffset() + partition.getLength();
		int tokenLength = getCommentStart().length();

		boolean wasPHPDoc = false; // true if the previous partition is PHPDoc

		if (partType == PHPPartitionTypes.PHP_DOC) {
			wasPHPDoc = true;
		} else if (partType == PHPPartitionTypes.PHP_MULTI_LINE_COMMENT) {
			// already in a comment - remove ending mark
			multiEdit.addChild(new DeleteEdit(partEndOffset - tokenLength, tokenLength));
		}

		// advance to next partition
		IStructuredDocument sDoc = (IStructuredDocument) docExtension;
		IStructuredDocumentRegion sdRegion = sDoc.getRegionAtCharacterOffset(partEndOffset);
		ITextRegion textRegion = sdRegion.getRegionAtCharacterOffset(partEndOffset);

		ITextRegionCollection container = sdRegion;

		if (textRegion instanceof ITextRegionContainer) {
			container = (ITextRegionContainer) textRegion;
			textRegion = container.getRegionAtCharacterOffset(partEndOffset);
		}

		if (textRegion.getType() == PHPRegionContext.PHP_CONTENT) {
			IPhpScriptRegion phpScriptRegion = (IPhpScriptRegion) textRegion;
			partition = PHPPartitionTypes.getPartition(phpScriptRegion, partEndOffset - container.getStartOffset() - phpScriptRegion.getStart());
			partType = partition.getType();
			phpRegionStart = container.getStartOffset() + phpScriptRegion.getStart();
		}
		if (textRegion.getType() == PHPRegionContext.PHP_CLOSE) {
			return null;
		}

		// start of next partition
		if (wasPHPDoc) {
			// if previous was PHPDoc, and the current one is not, then add block comment start
			if (partType == PHPPartitionTypes.PHP_DEFAULT || isSpecialPartition(partType)) {
				multiEdit.addChild(new InsertEdit(phpRegionStart + partition.getOffset(), getCommentStart()));
			}
		} else { // !wasPHPDoc
			if (partType == PHPPartitionTypes.PHP_DOC) {
				// if next is PHPDoc, end block comment before
				multiEdit.addChild(new InsertEdit(phpRegionStart + partition.getOffset(), getCommentEnd()));
			} else if (partType == PHPPartitionTypes.PHP_MULTI_LINE_COMMENT) {
				// already in a comment - remove startToken
				multiEdit.addChild(new DeleteEdit(phpRegionStart + partition.getOffset(), getCommentStart().length()));
			}
		}
		return partition;
	}

