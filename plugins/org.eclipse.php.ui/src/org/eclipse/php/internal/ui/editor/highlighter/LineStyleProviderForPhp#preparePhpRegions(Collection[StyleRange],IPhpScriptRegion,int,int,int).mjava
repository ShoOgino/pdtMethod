	/**
	 * Prepares php regions to the line highliter
	 * @param holdResults - results
	 * @param region - php region
	 * @param partitionLength 
	 * @param partitionStartOffset 
	 */
	private boolean preparePhpRegions(Collection<StyleRange> holdResults, IPhpScriptRegion region, int regionStart, int partitionStartOffset, int partitionLength) {
		assert region.getType() == PHPRegionContext.PHP_CONTENT;

		StyleRange styleRange = null;
		TextAttribute attr;
		TextAttribute previousAttr = null;

		ITextRegion[] phpTokens = null;
		try {

			int from;
			int length;
			if (partitionStartOffset < regionStart) {
				from = 0;
				length = partitionLength - (regionStart - partitionStartOffset);
			} else {
				from = partitionStartOffset - regionStart;
				length = partitionLength;
			}
			phpTokens = region.getPhpTokens(from, Math.min(length, region.getLength()));
			ITextRegion prevElement = null;
			for (int i = 0; i < phpTokens.length; i++) {
				ITextRegion element = phpTokens[i];
				attr = getAttributeFor(element);
				// Check that the elements are different - otherwise the coloring is not valid
				if (prevElement == element) {
					continue;
				}
				if ((styleRange != null) && (previousAttr != null) && (previousAttr.equals(attr)) && prevElement != null && prevElement.getLength() == prevElement.getLength()) {
					// extends the prev styleRange with the current element
					// length
					styleRange.length += element.getLength();
					if (styleRange.start + styleRange.length > partitionStartOffset + partitionLength) {
						styleRange.length -= (styleRange.start + styleRange.length) - (partitionStartOffset + partitionLength);
					}
				} else {
					// create new styleRange
					int styleStart = regionStart + element.getStart();
					int styleLength = element.getLength();
					if (styleStart + styleLength < partitionStartOffset) { // if the range ends before the requested starting position - ignoring it
						continue;
					}
					if (styleStart < partitionStartOffset) { // if the region starts before the requested starting position - adjusting the style start position
						styleLength -= (partitionStartOffset - styleStart);
						styleStart = partitionStartOffset;
					}
					if (styleStart + styleLength > partitionStartOffset + partitionLength) {//if the region ends after the requested end position - making it shorter
						styleLength -= (styleStart + styleLength) - (partitionStartOffset + partitionLength);
					}
					if (attr.getBackground() != null && element.getTextEnd() != element.getEnd()) {//in case of background color make sure the highlighting will not paint the whitespaces
						//applying style to the region w/o the whitespace
						styleRange = new StyleRange(styleStart, styleLength - (element.getEnd() - element.getTextEnd()), attr.getForeground(), attr.getBackground(), attr.getStyle());
						if ((attr.getStyle() & TextAttribute.UNDERLINE) != 0) {
							styleRange.underline = true;
							styleRange.fontStyle &= ~TextAttribute.UNDERLINE;
						}
						if ((attr.getStyle() & TextAttribute.STRIKETHROUGH) != 0) {
							styleRange.strikeout = true;
							styleRange.fontStyle &= ~TextAttribute.STRIKETHROUGH;
						}
						holdResults.add(styleRange);
						//applying style to the whitespace (important for the refresh of the specific range
						styleRange = new StyleRange(regionStart + element.getTextEnd(), element.getEnd() - element.getTextEnd(), attr.getForeground(), null, attr.getStyle());
						holdResults.add(styleRange);
						previousAttr = null;
					} else {
						styleRange = new StyleRange(styleStart, styleLength, attr.getForeground(), attr.getBackground(), attr.getStyle());
						if ((attr.getStyle() & TextAttribute.UNDERLINE) != 0) {
							styleRange.underline = true;
							styleRange.fontStyle &= ~TextAttribute.UNDERLINE;
						}
						if ((attr.getStyle() & TextAttribute.STRIKETHROUGH) != 0) {
							styleRange.strikeout = true;
							styleRange.fontStyle &= ~TextAttribute.STRIKETHROUGH;
						}
						holdResults.add(styleRange);
						// technically speaking, we don't need to update
						// previousAttr
						// in the other case, because the other case is when
						// it hasn't changed
						previousAttr = attr;
					}
				}
				prevElement = element;
			}
			return true;
		} catch (BadLocationException e) {
			Logger.logException(e);
			return false;
		}
	}

