	/**
	 * Prepares php regions to the line highliter
	 * 
	 * @param holdResults
	 *            - results
	 * @param region
	 *            - php region
	 * @param partitionLength
	 * @param partitionStartOffset
	 */
	private boolean preparePhpRegions(Collection<StyleRange> holdResults,
			IPhpScriptRegion region, int regionStart, int partitionStartOffset,
			int partitionLength) {
		assert region.getType() == PHPRegionContext.PHP_CONTENT;

		StyleRange styleRange = null;
		TextAttribute attr;
		TextAttribute previousAttr = null;

		ITextRegion[] phpTokens = null;
		try {

			int from;
			int length;
			if (partitionStartOffset < regionStart) {
				from = 0;
				length = partitionLength - (regionStart - partitionStartOffset);
			} else {
				from = partitionStartOffset - regionStart;
				length = partitionLength;
			}
			phpTokens = region.getPhpTokens(from,
					Math.min(length, region.getLength()));
			ITextRegion prevElement = null;
			for (int i = 0; i < phpTokens.length; i++) {
				ITextRegion element = phpTokens[i];
				attr = getAttributeFor(element);
				// Check that the elements are different - otherwise the
				// coloring is not valid
				if (prevElement == element) {
					continue;
				}
				if ((styleRange != null) && (previousAttr != null)
						&& (previousAttr.equals(attr)) && prevElement != null
						&& prevElement.getLength() == prevElement.getLength()) {
					// extends the prev styleRange with the current element
					// length
					styleRange.length += element.getLength();
					if (styleRange.start + styleRange.length > partitionStartOffset
							+ partitionLength) {
						styleRange.length -= (styleRange.start + styleRange.length)
								- (partitionStartOffset + partitionLength);
					}
				} else {
					// create new styleRange
					int styleStart = regionStart + element.getStart();
					int styleLength = element.getLength();
					if (styleStart + styleLength < partitionStartOffset) { // if
						// the
						// range
						// ends
						// before
						// the
						// requested
						// starting
						// position
						// -
						// ignoring
						// it
						continue;
					}
					if (styleStart < partitionStartOffset) { // if the region
						// starts before
						// the requested
						// starting
						// position -
						// adjusting the
						// style start
						// position
						styleLength -= (partitionStartOffset - styleStart);
						styleStart = partitionStartOffset;
					}
					if (styleStart > partitionStartOffset + partitionLength) {
						// if the region ends after the requested end position -
						// making it shorter
						styleLength -= styleStart
								- (partitionStartOffset + partitionLength);
					}
					if (attr.getBackground() != null
							&& element.getTextEnd() != element.getEnd()) {// in
						// case
						// of
						// background
						// color
						// make
						// sure
						// the
						// highlighting
						// will
						// not
						// paint
						// the
						// whitespaces
						// applying style to the region w/o the whitespace
						styleRange = new StyleRange(styleStart, styleLength
								- (element.getEnd() - element.getTextEnd()),
								attr.getForeground(), attr.getBackground(),
								attr.getStyle());
						if ((attr.getStyle() & TextAttribute.UNDERLINE) != 0) {
							styleRange.underline = true;
							styleRange.fontStyle &= ~TextAttribute.UNDERLINE;
						}
						if ((attr.getStyle() & TextAttribute.STRIKETHROUGH) != 0) {
							styleRange.strikeout = true;
							styleRange.fontStyle &= ~TextAttribute.STRIKETHROUGH;
						}
						holdResults.add(styleRange);
						// applying style to the whitespace (important for the
						// refresh of the specific range
						styleRange = new StyleRange(regionStart
								+ element.getTextEnd(), element.getEnd()
								- element.getTextEnd(), attr.getForeground(),
								null, attr.getStyle());
						holdResults.add(styleRange);
						previousAttr = null;
					} else {
						styleRange = new StyleRange(styleStart, styleLength,
								attr.getForeground(), attr.getBackground(),
								attr.getStyle());
						if ((attr.getStyle() & TextAttribute.UNDERLINE) != 0) {
							styleRange.underline = true;
							styleRange.fontStyle &= ~TextAttribute.UNDERLINE;
						}
						if ((attr.getStyle() & TextAttribute.STRIKETHROUGH) != 0) {
							styleRange.strikeout = true;
							styleRange.fontStyle &= ~TextAttribute.STRIKETHROUGH;
						}
						holdResults.add(styleRange);
						// technically speaking, we don't need to update
						// previousAttr
						// in the other case, because the other case is when
						// it hasn't changed
						previousAttr = attr;
					}
				}
				prevElement = element;
			}
			return true;
		} catch (BadLocationException e) {
			Logger.logException(e);
			return false;
		}
	}

