	/**
	 * Prepares php regions to the line highliter
	 * @param holdResults - results
	 * @param region - php region
	 * @param partitionLength 
	 * @param partitionStartOffset 
	 */
	private boolean preparePhpRegions(Collection<StyleRange> holdResults, IPhpScriptRegion region, int regionStart, int partitionStartOffset, int partitionLength) {
		assert region.getType() == PHPRegionContext.PHP_CONTENT;

		StyleRange styleRange = null;
		TextAttribute attr;
		TextAttribute previousAttr = null;

		ITextRegion[] phpTokens = null;
		try {

			int from;
			int length;
			if (partitionStartOffset < regionStart) {
				from = 0;
				length = partitionLength - (partitionStartOffset - regionStart);
			} else {
				from = partitionStartOffset - regionStart;
				length = partitionLength;
			}
			phpTokens = region.getPhpTokens(from, Math.min(length, region.getLength()));
			ITextRegion prevElement = null;
			for (int i = 0; i < phpTokens.length; i++) {
				ITextRegion element = phpTokens[i];
				// ignore any first whitespace regions
//				if (i == 0 && (element.getType() == PHPRegionTypes.WHITESPACE || element.getTextEnd() < from)) {
//					continue;
//				}
				attr = getAttributeFor(element);
				if ((styleRange != null) && (previousAttr != null) && (previousAttr.equals(attr)) && prevElement != null && prevElement.getTextLength() == prevElement.getLength()) {
					// extends the prev styleRange with the current element length
					styleRange.length += element.getTextLength();
				} else {
					// Verify that the element does not exceed the given partition end, otherwise break. It is assumed that the elements are sorted according to ascending indexes
					if ((regionStart + element.getStart() + element.getTextLength()) > (partitionStartOffset+partitionLength)){
						break;
					}
					// create new styleRange
					int styleStart = regionStart + element.getStart();
					if (styleStart < partitionStartOffset) {
						styleStart = partitionStartOffset;
					}
					styleRange = new StyleRange(styleStart, element.getTextLength(), attr.getForeground(), attr.getBackground(), attr.getStyle());
					if ((attr.getStyle() & TextAttribute.UNDERLINE) != 0) {
						styleRange.underline = true;
						styleRange.fontStyle &= ~TextAttribute.UNDERLINE;
					}
					if ((attr.getStyle() & TextAttribute.STRIKETHROUGH) != 0) {
						styleRange.strikeout = true;
						styleRange.fontStyle &= ~TextAttribute.STRIKETHROUGH;
					}
					holdResults.add(styleRange);
					// technically speaking, we don't need to update
					// previousAttr
					// in the other case, because the other case is when
					// it hasn't changed
					previousAttr = attr;
				}
				prevElement = element;
			}
			return true;
		} catch (BadLocationException e) {
			Logger.logException(e);
			return false;
		}
	}

