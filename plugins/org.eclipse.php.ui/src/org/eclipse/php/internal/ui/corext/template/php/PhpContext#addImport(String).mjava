	/**
	 * Adds an import for type with type name <code>type</cod> if possible.
	 * Returns a string which can be used to reference the type.
	 * 
	 * @param type the fully qualified name of the type to import
	 * @return returns a type to which the type binding can be assigned to.
	 * 	The returned type contains is unqualified when an import could be added or was already known.
	 * 	It is fully qualified, if an import conflict prevented the import.
	 * @since 3.4
	 */
	public String addImport(String type) {
		if (isReadOnly())
			return type;
		
		ICompilationUnit cu= getCompilationUnit();
		if (cu == null)
			return type;

		try {
			boolean qualified= type.indexOf('.') != -1;
			if (!qualified) {
				IJavaSearchScope searchScope= SearchEngine.createJavaSearchScope(new IJavaElement[] { cu.getJavaProject() });
				SimpleName nameNode= null;
				TypeNameMatch[] matches= findAllTypes(type, searchScope, nameNode, null, cu);
				if (matches.length != 1) // only add import if we have a single match
					return type;
				type= matches[0].getFullyQualifiedName();
			}
			
			CompilationUnit root= getASTRoot(cu);
			if (fImportRewrite == null) {
				if (root == null) {
					fImportRewrite= StubUtility.createImportRewrite(cu, true);
				} else {
					fImportRewrite= StubUtility.createImportRewrite(root, true);
				}
			}

			ImportRewriteContext context;
			if (root == null)
				context= null;
			else
				context= new ContextSensitiveImportRewriteContext(root, getCompletionOffset(), fImportRewrite);

			return fImportRewrite.addImport(type, context);
		} catch (JavaModelException e) {
			handleException(null, e);
			return type;
		}
	}

