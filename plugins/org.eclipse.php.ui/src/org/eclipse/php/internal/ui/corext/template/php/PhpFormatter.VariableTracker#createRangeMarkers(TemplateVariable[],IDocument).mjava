		private List createRangeMarkers(TemplateVariable[] variables, IDocument document) throws MalformedTreeException, BadLocationException {
			Map markerToOriginal= new HashMap();
			
			MultiTextEdit root= new MultiTextEdit(0, document.getLength());
			List edits= new ArrayList();
			boolean hasModifications= false;
			for (int i= 0; i != variables.length; i++) {
				final TemplateVariable variable= variables[i];
				int[] offsets= variable.getOffsets();
				
				String value= variable.getDefaultValue();
				if (isWhitespaceVariable(value)) {
					// replace whitespace positions with unformattable comments
					String placeholder= COMMENT_START + value + COMMENT_END;
					for (int j= 0; j != offsets.length; j++) {
						ReplaceEdit replace= new ReplaceEdit(offsets[j], value.length(), placeholder);
						root.addChild(replace);
						hasModifications= true;
						markerToOriginal.put(replace, value);
						edits.add(replace);
					}
				} else {
					for (int j= 0; j != offsets.length; j++) {
						RangeMarker marker= new RangeMarker(offsets[j], value.length());
						root.addChild(marker);
						edits.add(marker);
					}
				}
			}
			
			if (hasModifications) {
				// update the document and convert the replaces to markers
				root.apply(document, TextEdit.UPDATE_REGIONS);
			}
			
			List positions= new ArrayList();
			for (Iterator it= edits.iterator(); it.hasNext();) {
				TextEdit edit= (TextEdit) it.next();
				try {
					// abuse TypedPosition to piggy back the original contents of the position
					final TypedPosition pos= new TypedPosition(edit.getOffset(), edit.getLength(), (String) markerToOriginal.get(edit));
					document.addPosition(CATEGORY, pos);
					positions.add(pos);
				} catch (BadPositionCategoryException x) {
					Assert.isTrue(false);
				}
			}
			
			return positions;
		}

