		@Override
		public boolean visit(ClassName className) {
			Expression classNode = className.getName();
			if (classNode instanceof Identifier) {

				String typeName = ((Identifier) classNode).getName();
				IModelAccessCache cache = className.getAST().getBindingResolver().getModelAccessCache();
				try {
					IType[] types = PHPModelUtils.getTypes(typeName, getSourceModule(), className.getStart(), cache,
							new NullProgressMonitor());
					if (types != null) {
						for (IType type : types) {
							if (ModelUtils.isDeprecated(type)) {
								// SemanticHighlightingPresenter.updatePresentation()
								// sorts the "highlighting" areas by
								// ascending position.
								// Any fully-qualified class name highlighting
								// will always be rendered before its class name
								// highlighting (when their start positions
								// differ)...
								// https://bugs.eclipse.org/bugs/show_bug.cgi?id=496045
								// https://bugs.eclipse.org/bugs/show_bug.cgi?id=549957
								// See also
								// ClassHighlighting#visit(ClassInstanceCreation)
								// and
								// DeprecatedHighlighting#highlightStatic(StaticDispatch).
								if (!(ClassHighlighting.SELF.equalsIgnoreCase(typeName)
										|| ClassHighlighting.CLASS.equalsIgnoreCase(typeName)
										|| ClassHighlighting.PARENT.equalsIgnoreCase(typeName))) {
									// We want to highlight all NamespaceName
									// segments, so don't do
									// highlight(classNode) that will only
									// highlight last NamespaceName segment.
									highlight(className);
								}
								if (classNode instanceof NamespaceName) {
									// ...so we must render again the class
									// name "Deprecated Highlighting"
									// on top of the class name
									// "Class Highlighting".
									highlightLastNamespaceSegment((NamespaceName) classNode);
								}
								break;
							}
						}
					}
				} catch (ModelException e) {
					Logger.logException(e);
				}

			}
			return true;
		}

