	void processAction(ITextEditor textEditor, IDocument document, ITextSelection textSelection) {

		int selectionOffset = textSelection.getOffset();
		int selectionLength = textSelection.getLength();

		IStructuredModel model = StructuredModelManager.getModelManager().getExistingModelForEdit(document);
		if (model != null) {
			try {
				model.beginRecording(this, PHPUIMessages.getString("RemoveBlockComment_tooltip"));
				model.aboutToChangeModel();

				if (document instanceof IStructuredDocument) {
					IStructuredDocument sDoc = (IStructuredDocument) document;
					ITextRegion textRegion = sDoc.getRegionAtCharacterOffset(selectionOffset).getRegionAtCharacterOffset(selectionOffset);

					Stack<TextLocation> phpCommentLocationStack = new Stack<TextLocation>(); // stack of ITextRegion including only Comments' Start and End tokens locations

					try {
						int regionOffset = textRegion.getStart();
						ITextRegion[] phpTokens = ((PhpScriptRegion) textRegion).getPhpTokens(selectionOffset - regionOffset, selectionLength);

						int lastOffsetParsed = -1;

						for (ITextRegion token : phpTokens) {
							if (lastOffsetParsed >= token.getEnd()) //in order to save some redundant computation cycles...
								continue;

							if (isCommentStartRegion(token) || isCommentRegion(token) || isCommentEndRegion(token)) {
								// if we are somewhere within a comment (start/end/body), this will find the start and end tokens
								ITextRegion startToken = findCommentStartToken(token, (PhpScriptRegion) textRegion);
								TextLocation commentOffsets = new TextLocation(startToken.getStart() + regionOffset, startToken.getEnd() + regionOffset);
								boolean result = validateAndPushLocation(phpCommentLocationStack, commentOffsets);
								assert (result);
								lastOffsetParsed = commentOffsets.endOffset - regionOffset;

								ITextRegion endToken = findCommentEndToken(token, (PhpScriptRegion) textRegion);
								commentOffsets = new TextLocation(endToken.getStart() + regionOffset, endToken.getEnd() + regionOffset);
								result = validateAndPushLocation(phpCommentLocationStack, commentOffsets);
								assert (result);
								lastOffsetParsed = commentOffsets.endOffset - regionOffset;

							}
						}
						for (int i = phpCommentLocationStack.size(); i > 0; i--) {
							TextLocation location = phpCommentLocationStack.pop();
							document.replace(location.startOffset, location.endOffset - location.startOffset, ""); //$NON-NLS-1$
						}

					} catch (BadLocationException e) {
						Logger.log(Logger.WARNING_DEBUG, e.getMessage(), e);
					}

				}

			} finally {
				model.changedModel();
				model.endRecording(this);
				model.releaseFromEdit();
			}
		}
	}

