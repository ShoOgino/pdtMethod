	private String handleElement(ITextEditor textEditor,
			IModelElement modelElem, IDocument document) {
		if (modelElem instanceof ISourceModule) {
			handleFileDocBlock((ISourceModule) modelElem,
					(IStructuredDocument) document);
			return null;
		}

		try {
			startPosition = getCodeDataOffset(modelElem);
		} catch (ModelException e) {
			Logger.logException(e);
			return null;
		}

		// Calculating indentation need to be added
		String indentString = null;
		try {
			indentString = getIndentString(document, modelElem);
		} catch (BadLocationException e) {
			Logger.logException(e);
			return null;
		}

		if (!textEditor.isEditable()) {
			return null;
		}
		int type = modelElem != null ? modelElem.getElementType() : -1;
		if (type != IModelElement.METHOD && type != IModelElement.TYPE
				&& type != IModelElement.FIELD) {
			assert false;
			return null;
		}
		String comment = null;
		try {
			switch (type) {
			case IModelElement.TYPE:
				if (PHPModelUtils.getDocBlock((IType) modelElem) != null) {
					return null;
				}
				comment = createTypeComment((IType) modelElem, lineDelim);
				break;
			case IModelElement.FIELD:
				if (PHPModelUtils.getDocBlock((IField) modelElem) != null) {
					return null;
				}
				comment = createFieldComment((IField) modelElem, lineDelim);
				break;
			case IModelElement.METHOD:
				if (PHPModelUtils.getDocBlock((IMethod) modelElem) != null) {
					return null;
				}
				comment = createMethodComment((IMethod) modelElem, lineDelim);
				break;
			default:
				comment = createDefaultComment(lineDelim);
			}
		} catch (CoreException e) {
			Logger.logException(e);
		}

		if (comment == null) {
			comment = createDefaultComment(lineDelim);
		}

		docBlock = indentPattern(comment, indentString, lineDelim);

		String docBlockText = insertDocBlock((IStructuredDocument) document,
				startPosition, docBlock);

		return docBlockText;
	}

