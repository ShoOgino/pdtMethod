	/**
	 * Returns a shared compilation unit AST for the given Java element.
	 * <p>
	 * Clients are not allowed to modify the AST and must synchronize all access
	 * to its nodes.
	 * </p>
	 * 
	 * @param input
	 *            the Java element, must not be <code>null</code>
	 * @param waitFlag
	 *            {@link SharedASTProvider#WAIT_YES},
	 *            {@link SharedASTProvider#WAIT_NO} or
	 *            {@link SharedASTProvider#WAIT_ACTIVE_ONLY}
	 * @param progressMonitor
	 *            the progress monitor or <code>null</code>
	 * @return the AST or <code>null</code> if the AST is not available
	 */
	public Program getAST(ISourceModule input, WAIT_FLAG waitFlag, IProgressMonitor progressMonitor) {
		if (input == null || waitFlag == null) {
			throw new IllegalArgumentException("input or wait flag are null"); //$NON-NLS-1$
		}

		if (progressMonitor != null && progressMonitor.isCanceled()) {
			return null;
		}

		boolean isActiveElement;
		synchronized (this) {
			isActiveElement = input.equals(fActiveJavaElement);
			if (isActiveElement) {
				if (fAST != null) {
					if (DEBUG) {
						System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "returning cached AST:" //$NON-NLS-1$ //$NON-NLS-2$
								+ toString(fAST) + " for: " + input.getElementName()); //$NON-NLS-1$
					}
					return fAST;
				}
				if (waitFlag == SharedASTProvider.WAIT_NO) {
					if (DEBUG) {
						System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "returning null (WAIT_NO) for: " //$NON-NLS-1$ //$NON-NLS-2$
								+ input.getElementName());
					}
					return null;
				}
			}
		}

		final boolean canReturnNull = waitFlag == SharedASTProvider.WAIT_NO
				|| (waitFlag == SharedASTProvider.WAIT_ACTIVE_ONLY && !(isActiveElement && fAST == null));
		boolean isReconciling = false;
		if (isActiveElement) {
			synchronized (fReconcileLock) {
				isReconciling = isReconciling(input);
				if (!isReconciling && !canReturnNull) {
					aboutToBeReconciled(input);
				}
			}
		}

		if (isReconciling) {
			try {
				final ISourceModule activeElement = fReconcilingJavaElement;

				// Wait for AST
				synchronized (fWaitLock) {
					if (DEBUG) {
						System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "waiting for AST for: " //$NON-NLS-1$ //$NON-NLS-2$
								+ input.getElementName());
					}
					fWaitLock.wait(30000); // XXX: The 30 seconds timeout is an
											// attempt to at least avoid a
											// deadlock. See
											// https://bugs.eclipse.org/366048#c21
				}

				// Check whether active element is still valid
				synchronized (this) {
					if (activeElement == fActiveJavaElement && fAST != null) {
						if (DEBUG) {
							System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "...got AST for: " //$NON-NLS-1$ //$NON-NLS-2$
									+ input.getElementName());
						}
						return fAST;
					}
				}

				return getAST(input, waitFlag, progressMonitor);
			} catch (InterruptedException e) {
				return null; // thread has been interrupted don't compute AST
			}
		} else if (canReturnNull)
			return null;

		Program ast = null;
		try {
			ast = createAST(input, progressMonitor);
			if (progressMonitor != null && progressMonitor.isCanceled()) {
				ast = null;
				if (DEBUG) {
					System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "Ignore created AST for: " //$NON-NLS-1$ //$NON-NLS-2$
							+ input.getElementName() + " - operation has been cancelled"); //$NON-NLS-1$
				}
			}
		} finally {
			if (isActiveElement) {
				if (fAST != null) {
					// in the meantime, reconcile created a new AST. Return that
					// one
					if (DEBUG) {
						System.out.println(getThreadName() + " - " + DEBUG_PREFIX + "Ignore created AST for " //$NON-NLS-1$ //$NON-NLS-2$
								+ input.getElementName() + " - AST from reconciler is newer"); //$NON-NLS-1$
					}
					reconciled(fAST, input, null);
					return fAST;
				} else
					reconciled(ast, input, null);
			}
		}
		return ast;
	}

