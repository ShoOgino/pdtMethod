	/**
	 * This function returns statement text depending on the current offset.
	 * It searches backwards until it finds ';', '{' or '}'.
	 * 
	 * @param offset The absolute offset in the document
	 * @param sdRegion Structured document region of the offset
	 * @param removeComments Flag determining whether to remove comments in the resulted text sequence
	 * 
	 * @return text sequence of the statement
	 */
	public static TextSequence getStatment(int offset, IStructuredDocumentRegion sdRegion, boolean removeComments) {
		ITextRegion tRegion = sdRegion.getRegionAtCharacterOffset(offset);

		// This text region must be of type PhpScriptRegion:
		if (tRegion.getType() == PHPRegionTypes.PHP_CONTENT) {
			PhpScriptRegion phpScriptRegion = (PhpScriptRegion) tRegion;

			try {
				// Get the PHP token region corresponding to the offset:
				ITextRegion tokenRegion = phpScriptRegion.getPhpToken(offset - sdRegion.getStartOffset() - phpScriptRegion.getStart());

				
				// Now, search backwards for the statement start (in this PhpScriptRegion):
				ITextRegion startTokenRegion = tokenRegion;
				while (startTokenRegion != null
						&& startTokenRegion.getType() != PHPRegionTypes.PHP_CURLY_CLOSE
						&& startTokenRegion.getType() != PHPRegionTypes.PHP_CURLY_OPEN
						&& startTokenRegion.getType() != PHPRegionTypes.PHP_SEMICOLON) {
					startTokenRegion = phpScriptRegion.getPhpToken(startTokenRegion.getStart() - 1);
				}

				// Caclulate the start position of the statement:

				// Set default starting position to the beginning of the PhpScriptRegion:
				int startOffset = sdRegion.getStartOffset() + phpScriptRegion.getStart();

				// If there is a start statement "delimiter", we should consider statement is starting after this token:
				if (tokenRegion != null) {
					startOffset += startTokenRegion.getEnd();
				}

				TextSequence textSequence = TextSequenceUtilities.createTextSequence(sdRegion, startOffset, offset - startOffset);

				if (removeComments) {
					textSequence = removeComments(textSequence);
				}
				// remove spaces from start.
				textSequence = textSequence.subTextSequence(readForwardSpaces(textSequence, 0), textSequence.length());
				return textSequence;

			} catch (BadLocationException e) {
			}
		}

		return null;
	}

