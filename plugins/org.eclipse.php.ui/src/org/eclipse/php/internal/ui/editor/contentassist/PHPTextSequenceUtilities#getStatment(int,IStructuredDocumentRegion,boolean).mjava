	/**
	 * This function returns statement text depending on the current offset.
	 * It searches backwards until it finds ';', '{' or '}'.
	 * 
	 * @param offset The absolute offset in the document
	 * @param sdRegion Structured document region of the offset
	 * @param removeComments Flag determining whether to remove comments in the resulted text sequence
	 * 
	 * @return text sequence of the statement
	 */
	public static TextSequence getStatment(int offset, IStructuredDocumentRegion sdRegion, boolean removeComments) {
		ITextRegion tRegion = sdRegion.getRegionAtCharacterOffset(offset);

		// This text region must be of type PhpScriptRegion:
		if (tRegion.getType() == PHPRegionContext.PHP_CONTENT) {
			PhpScriptRegion phpScriptRegion = (PhpScriptRegion) tRegion;

			try {
				//	Set default starting position to the beginning of the PhpScriptRegion:
				int startOffset = sdRegion.getStartOffset() + phpScriptRegion.getStart();

				// Now, search backwards for the statement start (in this PhpScriptRegion):
				ITextRegion startTokenRegion = phpScriptRegion.getPhpToken(offset - sdRegion.getStartOffset() - phpScriptRegion.getStart() - 1);
				while (true) {
					// If statement start is at the beginning of the PHP script region: 
					if (startTokenRegion.getStart() == 0) {
						break;
					}
					if (startTokenRegion.getType() == PHPRegionTypes.PHP_CURLY_CLOSE || startTokenRegion.getType() == PHPRegionTypes.PHP_CURLY_OPEN || startTokenRegion.getType() == PHPRegionTypes.PHP_SEMICOLON) {
						// Calculate starting position of the statement (it should go right after this startTokenRegion):
						startOffset += startTokenRegion.getEnd();
						break;
					}
					startTokenRegion = phpScriptRegion.getPhpToken(startTokenRegion.getStart() - 1);
				}

				TextSequence textSequence = TextSequenceUtilities.createTextSequence(sdRegion, startOffset, offset - startOffset);

				if (removeComments) {
					textSequence = removeComments(textSequence);
				}
				// remove spaces from start.
				textSequence = textSequence.subTextSequence(readForwardSpaces(textSequence, 0), textSequence.length());
				return textSequence;

			} catch (BadLocationException e) {
			}
		}

		return null;
	}

