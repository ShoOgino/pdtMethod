	/**
	 * Finds the highest position <code>p</code> in <code>fDocument</code>
	 * such that <code>bound</code> &lt; <code>p</code> &lt;=
	 * <code>start</code> and
	 * <code>condition.stop(fDocument.getChar(p), p)</code> evaluates to
	 * <code>true</code>.
	 * 
	 * @param start
	 *            the first character position in <code>fDocument</code> to
	 *            be considered
	 * @param bound
	 *            the first position in <code>fDocument</code> to not
	 *            consider any more, with <code>bound</code> &lt;
	 *            <code>start</code>, or <code>UNBOUND</code>
	 * @param condition
	 *            the <code>StopCondition</code> to check
	 * @return the highest position in (<code>bound</code>,
	 *         <code>start</code> for which <code>condition</code> holds,
	 *         or <code>NOT_FOUND</code> if none can be found
	 */
	public int scanBackward(int start, int bound, StopCondition condition) {
		if (bound == UNBOUND)
			bound = -1;

		Assert.isTrue(bound >= -1);
		Assert.isTrue(start < fDocument.getLength());

		try {
			fPos = start;
			while (fPos > bound) {

				fChar = fDocument.getChar(fPos);
				if (condition.stop(fChar, fPos, false))
					return fPos;

				fPos = condition.nextPosition(fPos, false);
			}
		} catch (BadLocationException e) {
		}
		return NOT_FOUND;
	}

