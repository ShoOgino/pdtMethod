	/**
	 * Returns the comment for a method or constructor using the comment code
	 * templates (constructor / method / overriding method). <code>null</code>
	 * is returned if the template is empty.
	 * <p>
	 * The returned string is unformatted and not indented.
	 * 
	 * @param method
	 *            The method to be documented. The method must exist.
	 * @param overridden
	 *            The method that will be overridden by the created method or
	 *            <code>null</code> for non-overriding methods. If not
	 *            <code>null</code>, the method must exist.
	 * @param lineDelimiter
	 *            The line delimiter to be used.
	 * @return Returns the constructed comment or <code>null</code> if the
	 *         comment code template is empty. The returned string is
	 *         unformatted and and has no indent (formatting required).
	 * @throws CoreException
	 *             Thrown when the evaluation of the code template fails.
	 *             Contributed by zhaozw - bug #255204 [regression] Parameters
	 *             type is not displayed in Generated element comments doc block
	 */
	public static String getMethodComment(IMethod method, IMethod overridden,
			String lineDelimiter) throws CoreException {
		// FIXME - 'retType' should be initialized to null after the
		// 'getReturnType will be functional, so void/c'tor will not have
		// 'return' tag

		String retType = null;
		String[] typeParameterNames = null;
		String[] parameterTypes = null;
		Program program = null;

		try {
			// XXX: WAIT_NO (instead of WAIT_YES) due bug 466694 and until
			// bug 438661 will be fixed
			program = SharedASTProvider.getAST(method.getSourceModule(),
					SharedASTProvider.WAIT_NO, new NullProgressMonitor());
		} catch (IOException e1) {
		}

		if (program == null) {
			program = generageProgram(method, null);
			if (program == null) {
				return null;
			}
		}

		ASTNode elementAt = null;
		try {
			elementAt = program.getElementAt(method.getSourceRange()
					.getOffset());
		} catch (IllegalArgumentException e) {
			program = generageProgram(method, null);
			if (program == null) {
				return null;
			}
			elementAt = program.getElementAt(method.getSourceRange()
					.getOffset());
			if (elementAt == null) {
				return null;
			}
		}

		if (!(elementAt instanceof MethodDeclaration
				|| elementAt instanceof FunctionDeclaration || elementAt
					.getParent() instanceof MethodDeclaration)) {
			program = generageProgram(method, program);
			if (program == null) {
				return null;
			}
			elementAt = program.getElementAt(method.getSourceRange()
					.getOffset());
		}

		if (elementAt.getParent() instanceof MethodDeclaration) {
			elementAt = elementAt.getParent();
		}

		ITypeBinding[] returnTypes = null;
		ITypeBinding[] typeParametersTypes = null;
		IFunctionBinding resolvedBinding = null;
		List<FormalParameter> formalParameters = null;

		if (elementAt instanceof MethodDeclaration) {
			MethodDeclaration methodDeclaration = (MethodDeclaration) elementAt;
			resolvedBinding = methodDeclaration.resolveMethodBinding();
			formalParameters = methodDeclaration.getFunction()
					.formalParameters();
		} else if (elementAt instanceof FunctionDeclaration) {
			FunctionDeclaration functionDeclaration = (FunctionDeclaration) elementAt;
			resolvedBinding = functionDeclaration.resolveFunctionBinding();
			formalParameters = functionDeclaration.formalParameters();
		}
		final List<String> exceptions = new ArrayList<String>();
		elementAt.accept(new AbstractVisitor() {
			public boolean visit(ThrowStatement throwStatement) {
				Expression expression = throwStatement.getExpression();
				if (expression instanceof ClassInstanceCreation) {
					ClassInstanceCreation cic = (ClassInstanceCreation) throwStatement
							.getExpression();
					if (cic.getClassName().getName() instanceof Identifier) {
						Identifier name = (Identifier) cic.getClassName()
								.getName();
						exceptions.add(name.getName());
					}
				}
				if (expression instanceof Variable) {
					ITypeBinding type = ((Variable) expression)
							.resolveTypeBinding();
					if (type != null) {
						exceptions.add(type.getName());
					}
				}

				return true;
			}
		});
		final List<String> newExceptions = new ArrayList<String>();
		final Set<String> exceptionSet = new HashSet<String>();
		for (Iterator<String> iterator = exceptions.iterator(); iterator
				.hasNext();) {
			String exception = iterator.next();
			if (!exceptionSet.contains(exception)) {
				exceptionSet.add(exception);
				newExceptions.add(exception);
			}
		}
		if (formalParameters != null) {
			// get parameter type
			parameterTypes = new String[formalParameters.size()];
			int i = 0;
			for (ASTNode node : formalParameters) {
				FormalParameter formalParameter = (FormalParameter) node;
				Expression parameterType = formalParameter.getParameterType();
				if (parameterType != null) {
					String typeName = ((Identifier) parameterType).getName();
					parameterTypes[i++] = typeName;
				} else {
					if (formalParameter.getDefaultValue() != null
							&& formalParameter.getDefaultValue() instanceof Scalar
							&& !formalParameter.getDefaultValue()
									.isNullExpression()) {
						Scalar scalar = (Scalar) formalParameter
								.getDefaultValue();
						IEvaluatedType simpleType = PHPSimpleTypes
								.fromString(Scalar.getType(scalar
										.getScalarType()));
						if (simpleType == null) {
							parameterTypes[i++] = Scalar.getType(scalar
									.getScalarType());
						} else {
							parameterTypes[i++] = simpleType.getTypeName();
						}

					} else {
						parameterTypes[i++] = UNKNOWN_TYPE;
					}

				}
			}
		}

		StringBuilder returnTypeBuffer = new StringBuilder();
		if (null != resolvedBinding) {
			returnTypes = resolvedBinding.getReturnType();
			if (null != returnTypes && returnTypes.length > 0) {
				List<ITypeBinding> returnTypesList = removeDuplicateTypes(returnTypes);
				for (ITypeBinding returnType : returnTypesList) {
					if (returnType.isUnknown()) {
						// show unknown types as if they were null types, even
						// if looking for returnType.isUnknown() is not the same
						// as looking for returnType.isNullType()
						returnTypeBuffer.append(
								PHPSimpleTypes.NULL.getTypeName()).append("|"); //$NON-NLS-1$
					} else if (returnType.isAmbiguous()) {
						returnTypeBuffer.append("Ambiguous").append("|"); //$NON-NLS-1$ //$NON-NLS-2$
					} else if (returnType.getEvaluatedType() instanceof AmbiguousType) {
						// https://bugs.eclipse.org/bugs/show_bug.cgi?id=467148
						IEvaluatedType[] allPossibleTypes = ((AmbiguousType) returnType
								.getEvaluatedType()).getPossibleTypes();
						for (IEvaluatedType possibleType : allPossibleTypes) {
							returnTypeBuffer.append(possibleType.getTypeName())
									.append("|"); //$NON-NLS-1$
						}
					} else if (returnType.getEvaluatedType() instanceof MultiTypeType) {
						// https://bugs.eclipse.org/bugs/show_bug.cgi?id=467151
						List<IEvaluatedType> allPossibleTypes = ((MultiTypeType) returnType
								.getEvaluatedType()).getTypes();
						for (IEvaluatedType possibleType : allPossibleTypes) {
							returnTypeBuffer.append(possibleType.getTypeName())
									.append("[]").append("|"); //$NON-NLS-1$ //$NON-NLS-2$
						}
					} else {
						returnTypeBuffer.append(returnType.getName()).append(
								"|"); //$NON-NLS-1$
					}
				}
				if (returnTypeBuffer.length() > 0) {
					retType = returnTypeBuffer.substring(0,
							returnTypeBuffer.length() - 1);
				}
			}

			typeParametersTypes = resolvedBinding.getParameterTypes();

			if (null != typeParametersTypes) {
				int i = 0;
				typeParameterNames = new String[typeParametersTypes.length];
				for (ITypeBinding type : typeParametersTypes) {
					typeParameterNames[i++] = type.getName();
				}
			}
		}

		String[] paramNames = method.getParameterNames();
		if (formalParameters == null) {
			parameterTypes = new String[paramNames.length];
			for (int i = 0; i < paramNames.length; i++) {
				parameterTypes[i] = UNKNOWN_TYPE;
			}
		} else {
			for (int i = 0; i < formalParameters.size(); i++) {
				if (formalParameters.get(i).isVariadic()) {
					paramNames[i] = PhpTokenNames
							.getName(ParserConstants.T_ELLIPSIS)
							+ paramNames[i];
				}
			}
		}
		// add parameter type before parameter name
		for (int i = 0; i < paramNames.length; i++) {
			if (null != parameterTypes && null != parameterTypes[i]) {
				paramNames[i] = parameterTypes[i] + " " + paramNames[i]; //$NON-NLS-1$
				// } else {
				// String parameterType =
				// detectFromHungarianNotation(paramNames[i]);
				// if (parameterType != null) {
				// paramNames[i] = parameterType + " " + paramNames[i];
				// }
			}
		}
		IType declaringType = method.getDeclaringType();
		if (null != declaringType) {
			return StubUtility.getMethodComment(method.getScriptProject(),
					declaringType.getElementName(), method.getElementName(),
					paramNames, retType, typeParameterNames, overridden, false,
					lineDelimiter, newExceptions);
		}
		return StubUtility.getMethodComment(method.getScriptProject(), null,
				method.getElementName(), paramNames, retType,
				typeParameterNames, overridden, false, lineDelimiter,
				newExceptions);
	}

