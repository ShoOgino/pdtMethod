	/**
	 * Returns the content for a new field comment using the 'field comment'
	 * code template. The returned content is unformatted and is not indented.
	 * 
	 * @param sp
	 *            The compilation unit where the field is contained. The
	 *            compilation unit does not need to exist.
	 * @param fieldType
	 *            The name of the field declared type.
	 * @param fieldName
	 *            The name of the field to which the comment is added.
	 * @param lineDelimiter
	 *            The line delimiter to be used.
	 * @return Returns the new content or <code>null</code> if the code template
	 *         is undefined or empty. The returned content is unformatted and is
	 *         not indented.
	 * @throws CoreException
	 *             Thrown when the evaluation of the code template fails.
	 * @since 3.0
	 */
	public static String getFieldComment(IScriptProject sp, IField field,
			String lineDelimiter) throws CoreException {
		String fieldName = field.getElementName();
		String fieldType = null;
		Boolean isVar = false;
		Program program = null;

		try {
			// XXX: WAIT_NO (instead of WAIT_YES) due bug 466694 and until
			// bug 438661 will be fixed
			program = SharedASTProvider.getAST(field.getSourceModule(),
					SharedASTProvider.WAIT_NO, new NullProgressMonitor());
		} catch (IOException e1) {
		}

		if (program == null) {
			program = generageProgram(field, null);
			if (program == null) {
				return null;
			}
		}

		ASTNode elementAt = program.getElementAt(field.getSourceRange()
				.getOffset());
		Variable varDeclaration = null;
		Expression expression = null;
		ITypeBinding varType = null;

		if (elementAt instanceof Variable) {
			isVar = true;
			varDeclaration = (Variable) elementAt;
			if (varDeclaration.getParent() instanceof Assignment) {
				expression = ((Assignment) varDeclaration.getParent())
						.getRightHandSide();
				varType = expression.resolveTypeBinding();
			} else {
				varType = varDeclaration.resolveTypeBinding();
			}
		} else if (elementAt instanceof FieldsDeclaration) {
			FieldsDeclaration fieldDeclaration = (FieldsDeclaration) elementAt;
			Variable[] variables = fieldDeclaration.getVariableNames();
			Expression[] values = fieldDeclaration.getInitialValues();
			if (variables.length > 0) {
				assert values.length == variables.length;
				// XXX: treat all field declarations (variables.length > 1),
				// not only the first one.
				// Example: "private $field1 = array(), $field2 = 5;"
				varDeclaration = variables[0];
				expression = values[0];
				varType = varDeclaration.resolveTypeBinding();
			}
		}

		if (expression instanceof ArrayCreation) {
			fieldType = "array"; //$NON-NLS-1$
		} else if (expression instanceof Scalar) {
			Scalar scalar = (Scalar) expression;
			switch (scalar.getScalarType()) {
			case Scalar.TYPE_INT:
				fieldType = "integer"; //$NON-NLS-1$
				break;
			case Scalar.TYPE_STRING:
				if (!expression.isNullExpression()) {
					fieldType = "string"; //$NON-NLS-1$
				} else {
					// we don't want to use varType to describe
					// null values (because varType.isAmbiguous() will
					// return true and varType.getName() will return
					// "NULL"), but preferably UNKNOWN_TYPE when
					// fieldType is null
					varType = null;
				}
				break;
			}
		}

		if (null == fieldType && null != varType) {
			if (varType.isArray()) {
				fieldType = "array"; //$NON-NLS-1$
			} else if (varType.isAmbiguous()) {
				fieldType = "Ambiguous"; //$NON-NLS-1$
			} else {
				fieldType = varType.getName();
			}
		}

		if (null == fieldType) {
			fieldType = UNKNOWN_TYPE;
		}
		if (isVar) {
			return StubUtility.getVarComment(sp, fieldType, fieldName,
					lineDelimiter);
		}
		return StubUtility.getFieldComment(sp, fieldType, fieldName,
				lineDelimiter);
	}

