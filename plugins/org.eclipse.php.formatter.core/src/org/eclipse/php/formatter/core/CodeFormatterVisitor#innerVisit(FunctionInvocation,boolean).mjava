	private void innerVisit(FunctionInvocation functionInvocation,
			boolean addParen) {
		Expression functionName = functionInvocation.getFunctionName()
				.getName();
		functionName.accept(this);

		if (this.preferences.insert_space_before_opening_paren_in_function) {
			insertSpace();
		}

		if (addParen) {
			appendToBuffer(OPEN_PARN);
		}

		int lastPosition = functionName.getEnd();
		if (functionInvocation.parameters().size() > 0) {
			if (this.preferences.insert_space_after_opening_paren_in_function) {
				insertSpace();
			}
			int indentationGap = calculateIndentGap(
					this.preferences.line_wrap_arguments_in_method_invocation_indent_policy,
					this.preferences.line_wrap_wrapped_lines_indentation);

			List<Expression> parametersList = functionInvocation.parameters();
			Expression[] parameters = new Expression[parametersList.size()];
			parameters = parametersList.toArray(parameters);

			// work around. count close bracket now.
			if (addParen) {
				lineWidth++;
			}

			// work around. count space now.
			if (this.preferences.insert_space_before_closing_paren_in_function) {
				lineWidth++;
			}

			lastPosition = handleCommaList(
					parameters,
					lastPosition,
					this.preferences.insert_space_before_comma_in_function,
					this.preferences.insert_space_after_comma_in_function,
					this.preferences.line_wrap_arguments_in_method_invocation_line_wrap_policy,
					indentationGap,
					this.preferences.line_wrap_arguments_in_method_invocation_force_split);

			if (this.preferences.insert_space_before_closing_paren_in_function) {
				// work around. count space now.
				lineWidth--;
				insertSpace();
			}

			// work around. count close bracket now.
			if (addParen) {
				lineWidth--;
			}

		} else {
			if (this.preferences.insert_space_between_empty_paren_in_function) {
				insertSpace();
			}
		}

		if (addParen) {
			appendToBuffer(CLOSE_PARN);
		}
		handleChars(lastPosition, functionInvocation.getEnd());

	}

