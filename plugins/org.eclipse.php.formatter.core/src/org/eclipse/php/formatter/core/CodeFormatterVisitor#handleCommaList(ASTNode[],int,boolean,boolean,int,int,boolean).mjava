	/**
	 * handle comma list (e.g. 1,2,3)
	 * 
	 * @param array
	 *            ASTNode array
	 * @param lastPosition
	 *            the position of the last ASTNode
	 * @param insertSpaceBeforeComma
	 * @param insertSpaceAfterComma
	 * @param b
	 * @param k
	 * @param j
	 * @return the last element end position
	 */
	private int handleCommaList(ASTNode[] array, int lastPosition, boolean insertSpaceBeforeComma,
			boolean insertSpaceAfterComma, int lineWrapPolicy, int indentGap, boolean forceSplit) {
		int oldIndentationLevel = indentationLevel;
		boolean wasBinaryExpressionWrapped = this.wasBinaryExpressionWrapped;
		if (array.length == 0) {
			return lastPosition;
		}

		// save the changes index position
		String savedBuffer = replaceBuffer.toString();
		int changesIndex = changes.size() - 1;
		int savedLastPosition = lastPosition;
		boolean isExtraIndentation = false;

		// Map<Integer, CommentIndentationObject> commentIndentationMap = new
		// HashMap<Integer, CommentIndentationObject>();
		CommentIndentationObject cio = new CommentIndentationObject();
		commentIndentationStack.add(cio);
		// commentIndentationMap.put(array., cio);
		boolean isFirst = true;
		for (int i = 0; i < array.length; i++) {
			if (!isFirst) {
				if (insertSpaceBeforeComma) {
					insertSpace();
				}
				appendToBuffer(COMMA);
			}

			// after the first element and wrap policy is except first element
			if (i == 1 && lineWrapPolicy == WRAP_ALL_ELEMENTS_EXCEPT_FIRST) {
				savedBuffer = replaceBuffer.toString();
				changesIndex = changes.size() - 1;
				savedLastPosition = lastPosition;
			}
			boolean isInsertNewLine = false;
			switch (lineWrapPolicy) {
			case NO_LINE_WRAP:
				break;
			case FIRST_WRAP_WHEN_NECESSARY:
				if (lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					lineWrapPolicy = WRAP_WHEN_NECESSARY;
					insertNewLine();
					if (!cio.indented) {
						indentationLevel += indentGap;
					}

					indent();
					isInsertNewLine = true;
				}
				break;
			case WRAP_WHEN_NECESSARY:
				if (lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					insertNewLine();
					indent();
					isInsertNewLine = true;
				}
				break;
			case WRAP_FIRST_ELEMENT:
				if (forceSplit || lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					revert(savedBuffer, changesIndex);
					lastPosition = savedLastPosition;
					i = 0;
					lineWrapPolicy = WRAP_WHEN_NECESSARY;
					insertNewLine();
					if (!cio.indented) {
						indentationLevel += indentGap;
					}
					indent();
					isInsertNewLine = true;
				}
				break;
			case WRAP_ALL_ELEMENTS:
				if (forceSplit || lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					revert(savedBuffer, changesIndex);
					lastPosition = savedLastPosition;
					i = 0;
					lineWrapPolicy = ALWAYS_WRAP_ELEMENT;
					insertNewLine();
					if (!cio.indented) {
						indentationLevel += indentGap;
					}
					indent();
					isInsertNewLine = true;
				}
				break;
			case WRAP_ALL_ELEMENTS_NO_INDENT_FIRST:
				if (forceSplit || lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					// revert the buffer
					revert(savedBuffer, changesIndex);
					lastPosition = savedLastPosition;
					i = 0;
					lineWrapPolicy = ALWAYS_WRAP_ELEMENT;
					insertNewLine();
					if (!cio.indented) {
						indentationLevel += indentGap;
					}
					indent();
					isInsertNewLine = true;

					// increase the indentation level after the first element
					indentationLevel++;
					isExtraIndentation = true;
				}
				break;
			case WRAP_ALL_ELEMENTS_EXCEPT_FIRST:
				if (forceSplit || lineWidth + array[i].getLength() > this.preferences.line_wrap_line_split) {
					// revert
					revert(savedBuffer, changesIndex);
					lastPosition = savedLastPosition;
					i = (i > 0) ? 1 : 0;
					lineWrapPolicy = ALWAYS_WRAP_ELEMENT;
					insertNewLine();
					if (!cio.indented) {
						indentationLevel += indentGap;
					}
					indent();
					isInsertNewLine = true;
				}
				break;
			case ALWAYS_WRAP_ELEMENT:
				insertNewLine();
				indent();
				isInsertNewLine = true;
				break;
			}

			if (!isInsertNewLine && !isFirst && insertSpaceAfterComma) {
				insertSpace();
			}

			handleChars1(lastPosition, array[i].getStart(), oldIndentationLevel != indentationLevel, indentGap);
			array[i].accept(this);
			lastPosition = array[i].getEnd();

			isFirst = false;
		}
		commentIndentationStack.pop();
		if (isExtraIndentation) {
			indentationLevel--;
		}

		if (oldIndentationLevel != indentationLevel) {
			indentationLevel = oldIndentationLevel;
		}

		if (wasBinaryExpressionWrapped != this.wasBinaryExpressionWrapped) {
			this.wasBinaryExpressionWrapped = wasBinaryExpressionWrapped;
		}
		return lastPosition;
	}

