	// TODO: Do correct comment placement
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=440209
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=440820
	private void handleComments(int offset, int end,
			List<org.eclipse.php.internal.core.compiler.ast.nodes.Comment> commentList,
			boolean isIndented, int indentGap) throws Exception {
		boolean oldIgnoreEmptyLineSetting = ignoreEmptyLineSetting;
		ignoreEmptyLineSetting = false;

		int startLine = document.getLineOfOffset(offset);
		int start = offset;
		boolean needIndentNewLine = false;
		boolean indentationLevelDesending = this.indentationLevelDesending;
		inComment = true;
		boolean previousCommentIsSingleLine = false;

		comments: for (Iterator<org.eclipse.php.internal.core.compiler.ast.nodes.Comment> iter = commentList
				.iterator(); iter.hasNext();) {
			org.eclipse.php.internal.core.compiler.ast.nodes.Comment comment = iter
					.next();
			int commentStartLine = document
					.getLineOfOffset(comment.sourceStart() + offset);
			int position = replaceBuffer.lastIndexOf(lineSeparator);
			boolean startAtFirstColumn = (document.getLineOffset(
					commentStartLine) == comment.sourceStart() + offset);
			boolean endWithNewLineIndent = endWithNewLineIndent(
					replaceBuffer.toString());
			String afterNewLine = EMPTY_STRING;
			boolean indentOnFirstColumn;
			String commentContent;
			switch (comment.getCommentType()) {
			case org.eclipse.php.internal.core.compiler.ast.nodes.Comment.TYPE_SINGLE_LINE:
				indentOnFirstColumn = !startAtFirstColumn
						|| !this.preferences.never_indent_line_comments_on_first_column;
				if (startLine == commentStartLine) {
					indentOnFirstColumn = false;
					IRegion startLinereg = document
							.getLineInformation(startLine);
					// TODO: Do line width calculation based on the
					// formatted content instead of the original content
					lineWidth = comment.sourceStart() + offset
							- startLinereg.getOffset();
					if (position >= 0) {
						if (getBufferFirstChar(
								position + lineSeparator.length()) == '\0') {
							afterNewLine = replaceBuffer.substring(
									position + lineSeparator.length(),
									replaceBuffer.length());
							replaceBuffer.replace(position,
									replaceBuffer.length(), ""); //$NON-NLS-1$
							insertSpaces(1);
						} else {
							insertSpace();
						}
					} else {
						if (getBufferFirstChar(0) == '\0') {
							replaceBuffer.setLength(0);
							insertSpaces(1);
						} else {
							insertSpace();
						}
					}
				} else {
					if (indentationLevelDesending) {
						IRegion reg = document
								.getLineInformation(commentStartLine - 1);
						char previousChar = document
								.getChar(reg.getOffset() + reg.getLength() - 1);
						int indentationSize = preferences.indentationSize;

						// add empty lines
						if (previousChar != '{') {
							for (int line = 0; line < preferences.blank_line_preserve_empty_lines; line++) {
								insertNewLine();
							}
							if (isInsideFun) {
								indentationSize++;
							}
						}
						// End fixing.

						// add single indentationChar * indentationSize
						// Because the comment is the previous indentation level
						for (int i = 0; i < indentationSize; i++) {
							appendToBuffer(preferences.indentationChar);
							lineWidth += (preferences.indentationChar == CodeFormatterPreferences.SPACE_CHAR)
									? 0 : 3;
						}
					}

					if (getBufferFirstChar(0) == '\0') {
						if (position >= 0) {
							replaceBuffer.setLength(0);
							lineWidth = 0;
							insertNewLine();
						} else {
							replaceBuffer.setLength(0);
							lineWidth = 0;
						}
					} else {
						if (position >= 0 && getBufferFirstChar(
								position + lineSeparator.length()) == '\0') {
							replaceBuffer.replace(position,
									replaceBuffer.length(), ""); //$NON-NLS-1$
						}
						insertNewLine();
						if (!isIndented && !commentIndetationStack.isEmpty()) {
							CommentIndentationObject cio = commentIndetationStack
									.peek();
							if (!cio.indented) {
								cio.indented = true;
								indentationLevel += indentGap;
							}
						}
						// TODO should add indent level
					}
					if (indentationLevelDesending || blockEnd) {
						for (int i = 0; i < preferences.indentationSize; i++) {
							appendToBuffer(preferences.indentationChar);
							lineWidth += (preferences.indentationChar == CodeFormatterPreferences.SPACE_CHAR)
									? 0 : 3;
						}
					}
					needIndentNewLine = true;
				}

				doNotIndent = true;
				boolean resetCommentIndentVariables = true;
				if (indentOnFirstColumn) {
					if (previousCommentIsSingleLine
							&& indentStringForComment != null) {
						appendToBuffer(indentStringForComment);
						// adjust lineWidth,because indentLengthForComment may
						// contain '\t'
						lineWidth = indentLengthForComment;
						resetCommentIndentVariables = false;
					} else {
						indent();
					}
					if (lineWidth > 0) {
						startAtFirstColumn = false;
					}
					doNotIndent = false;
				}
				previousCommentIsSingleLine = true;
				handleCharsWithoutComments(start,
						comment.sourceStart() + offset);

				doNotIndent = false;
				resetEnableStatus(document.get(comment.sourceStart() + offset,
						comment.sourceEnd() - comment.sourceStart()));
				if (this.editsEnabled
						&& this.preferences.comment_format_line_comment
						&& (startAtFirstColumn
								&& this.preferences.comment_format_line_comment_starting_on_first_column
								|| !startAtFirstColumn)) {
					if (resetCommentIndentVariables) {
						resetCommentIndentVariables();
					}

					if (startLine == commentStartLine) {
						initCommentIndentVariables(offset, startLine, comment,
								endWithNewLineIndent);
						// adjust lineWidth,because indentLengthForComment may
						// contain '\t'
						lineWidth = indentLengthForComment;
					}
					if (startAtFirstColumn
							&& this.preferences.never_indent_line_comments_on_first_column) {
						indentLengthForComment = 0;
						indentStringForComment = ""; //$NON-NLS-1$
					}

					commentContent = document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart());
					boolean needInsertNewLine = commentContent
							.endsWith(lineSeparator);
					if (!needInsertNewLine) {
						String[] delimiters = document.getLegalLineDelimiters();
						for (int i = 0; i < delimiters.length; i++) {
							needInsertNewLine = commentContent
									.endsWith(delimiters[i]);
							if (needInsertNewLine) {
								break;
							}
						}
					}
					int commentTokLen = commentContent.startsWith("#") ? 1 : 2;//$NON-NLS-1$
					commentWords = Arrays
							.asList(commentContent.substring(commentTokLen)
									.trim().split("[ \\t\\v\\f]")); //$NON-NLS-1$
					commentWords = removeEmptyString(commentWords);
					commentContent = join(commentWords, " "); //$NON-NLS-1$
					commentContent = commentContent.trim();

					boolean newLineStart = true;
					appendToBuffer("//"); //$NON-NLS-1$

					for (String word : commentWords) {
						if (this.preferences.comment_line_length != 9999
								&& !newLineStart && (lineWidth + 1 + word
										.length() > this.preferences.comment_line_length)) {
							insertNewLine();
							// start at first column, and more than
							// comment_line_length
							if (!startAtFirstColumn || (startAtFirstColumn
									&& indentOnFirstColumn)) {
								if (indentLengthForComment >= 0) {
									appendToBuffer(indentStringForComment);

								} else {
									indent();
								}
							}
							appendToBuffer("//"); //$NON-NLS-1$
							insertSpaces(1);
							appendToBuffer(word);
						} else {
							insertSpaces(1);
							appendToBuffer(word);
							newLineStart = false;
						}
					}
					handleCharsWithoutComments(comment.sourceStart() + offset,
							comment.sourceEnd() + offset, true);
					if (needInsertNewLine) {
						insertNewLine();
						needInsertNewLine = false;
					} else {
						insertSpaces(1);
						afterNewLine = EMPTY_STRING;
					}
				} else {
					commentContent = document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart());
					boolean needInsertNewLine = commentContent
							.endsWith(lineSeparator);
					if (!needInsertNewLine) {
						String[] delimiters = document.getLegalLineDelimiters();
						for (int i = 0; i < delimiters.length; i++) {
							needInsertNewLine = commentContent
									.endsWith(delimiters[i]);
							if (needInsertNewLine) {
								break;
							}
						}
					}
					if (needInsertNewLine) {
						// https://bugs.eclipse.org/bugs/show_bug.cgi?id=441825
						lineWidth = 0;
						needInsertNewLine = false;
					} else {
						afterNewLine = EMPTY_STRING;
					}
				}

				start = comment.sourceEnd() + offset;
				break;
			case org.eclipse.php.internal.core.compiler.ast.nodes.Comment.TYPE_PHPDOC:
				previousCommentIsSingleLine = false;
				inComment = false;
				handleCharsWithoutComments(start,
						comment.sourceStart() + offset);
				inComment = true;
				resetEnableStatus(document.get(comment.sourceStart() + offset,
						comment.sourceEnd() - comment.sourceStart()));
				String codeBeforeComment = document
						.get(0, comment.sourceStart() + offset).trim();
				boolean isHeaderComment = codeBeforeComment.equals("<?") //$NON-NLS-1$
						|| codeBeforeComment.equals("<?php"); //$NON-NLS-1$
				if ((!isHeaderComment || this.preferences.comment_format_header)
						&& this.editsEnabled
						&& this.preferences.comment_format_javadoc_comment
						&& canHandlePHPDocComment((PHPDocBlock) comment,
								offset)) {
					PHPDocBlock block = (PHPDocBlock) comment;

					newLineOfComment = false;
					appendToBuffer("/**"); //$NON-NLS-1$

					commentWords = new ArrayList<String>();
					org.eclipse.php.internal.core.compiler.ast.nodes.Scalar[] texts = block
							.getTexts().toArray(
									new org.eclipse.php.internal.core.compiler.ast.nodes.Scalar[block
											.getTexts().size()]);
					PHPDocTag[] tags = block.getTags();
					if ((tags == null || tags.length == 0)) {
						texts = getNonblankScalars(texts);
					}
					boolean lastLineIsBlank = false;
					boolean isFirst = true;

					// description is blank
					if (getNonblankScalars(texts).length == 0) {
						texts = new org.eclipse.php.internal.core.compiler.ast.nodes.Scalar[0];
					}
					if (this.preferences.comment_new_lines_at_javadoc_boundaries) {
						insertNewLineForPHPDoc();
						// description is blank
						if (texts.length == 0) {
							lastLineIsBlank = true;
						}
					}
					int textsLength = texts.length;
					for (int j = 0; j < textsLength; j++) {
						org.eclipse.php.internal.core.compiler.ast.nodes.Scalar scalar = texts[j];
						String word = scalar.getValue();
						if (word.trim().length() > 0) {
							commentWords.add(word);
							if (this.preferences.join_lines_in_comments) {

								if (!isFirst) {
									insertNewLineForPHPDoc();
								}
								isFirst = false;
								initCommentWords();
								formatPHPDocText(commentWords, null, false,
										false);
								commentWords = new ArrayList<String>();
								lastLineIsBlank = false;
							}
						} else
							if (!this.preferences.comment_clear_blank_lines_in_javadoc_comment) {
							// don't duplicate first blank line
							if (isFirst
									&& this.preferences.comment_new_lines_at_javadoc_boundaries
									&& commentWords.isEmpty()) {
								isFirst = false;
								lastLineIsBlank = true;
								continue;
							}
							isFirst = false;
							initCommentWords();
							formatPHPDocText(commentWords, null, false, false);
							insertNewLineForPHPDoc();
							commentWords = new ArrayList<String>();
							lastLineIsBlank = true;
						}
					}
					if (!commentWords.isEmpty()) {
						initCommentWords();
						formatPHPDocText(commentWords, null, false, false);
						lastLineIsBlank = false;
					}

					if (tags != null && tags.length > 0) {
						if (this.preferences.comment_insert_empty_line_before_root_tags
								&& !lastLineIsBlank) {
							insertNewLineForPHPDoc();
							appendToBuffer(" "); //$NON-NLS-1$
						}
						for (int i = 0; i < tags.length; i++) {
							PHPDocTag phpDocTag = tags[i];
							boolean insertTag = true;
							String[] words = phpDocTag.getDescTexts()
									.toArray(new String[0]);

							if ((i == tags.length - 1)
									&& !this.preferences.comment_new_lines_at_javadoc_boundaries) {
								words = getNonblankWords(words);
							}
							commentWords = new ArrayList<String>();

							if (getNonblankWords(words).length == 0) {
								boolean hasRefs = phpDocTag
										.getAllReferencesWithOrigOrder()
										.size() != 0;
								int nbLines = words.length;
								// https://bugs.eclipse.org/bugs/show_bug.cgi?id=433938
								if (!hasRefs && nbLines > 1) {
									nbLines--;
								}
								// insert several lines
								formatCommentWords(phpDocTag, insertTag, false);
								for (int j = 0; j < nbLines; j++) {
									insertNewLineForPHPDoc();
								}
							} else {
								for (int j = 0; j < words.length; j++) {
									String word = words[j];
									if (word.trim().length() > 0) {
										commentWords.add(word);
										if (this.preferences.join_lines_in_comments) {

											formatCommentWords(phpDocTag,
													insertTag, true);
											insertTag = false;
										}
									} else
										if (!this.preferences.comment_clear_blank_lines_in_javadoc_comment
												&& !insertTag) {

										formatCommentWords(phpDocTag, insertTag,
												true);
										insertTag = false;
									}

								}
								if (!commentWords.isEmpty() || insertTag) {
									formatCommentWords(phpDocTag, insertTag,
											!commentWords.isEmpty());
								}
							}
						}
						lastLineIsBlank = false;
					}
					if (this.preferences.comment_new_lines_at_javadoc_boundaries
							&& !lastLineIsBlank) {
						insertNewLineForPHPDoc();
						appendToBuffer("/"); //$NON-NLS-1$
					} else if (lastLineIsBlank) {
						appendToBuffer("/"); //$NON-NLS-1$
					} else {
						indertWordToComment("*/"); //$NON-NLS-1$
					}
					handleCharsWithoutComments(comment.sourceStart() + offset,
							comment.sourceEnd() + offset, true);
				} else {
					commentContent = document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart());
					List<String> lines = Arrays
							.asList(commentContent.split("\r\n?|\n", -1)); //$NON-NLS-1$
					appendToBuffer(lines.get(0));
					// indent all lines, even empty lines
					for (int i = 1; i < lines.size(); i++) {
						insertNewLineForPHPDoc(false);
						appendToBuffer(lines.get(i)
								.replaceFirst("^[ \\t\\v\\f]+", "")); //$NON-NLS-1$ //$NON-NLS-2$
					}
					handleCharsWithoutComments(comment.sourceStart() + offset,
							comment.sourceEnd() + offset, true);
				}
				start = comment.sourceEnd() + offset;
				insertNewLine();
				indent();
				break;
			case org.eclipse.php.internal.core.compiler.ast.nodes.Comment.TYPE_MULTILINE:
				previousCommentIsSingleLine = false;
				// ignore multi line comments in the middle of code
				// example while /* kuku */ ( /* kuku */$a > 0 )
				if (getBufferFirstChar(0) != '\0') {
					replaceBuffer.setLength(0);
					IRegion reg = document.getLineInformationOfOffset(end);
					// TODO: Do line width calculation based on the
					// formatted content instead of the original content
					lineWidth = end - reg.getOffset();
					resetEnableStatus(document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart()));
					for (; iter.hasNext();) {
						org.eclipse.php.internal.core.compiler.ast.nodes.Comment nextComment = iter
								.next();
						resetEnableStatus(
								document.get(nextComment.sourceStart() + offset,
										nextComment.sourceEnd()
												- nextComment.sourceStart()));
					}
					start = end;
					break comments;
				}

				// buffer contains only whitespace chars
				indentOnFirstColumn = !startAtFirstColumn
						|| !this.preferences.never_indent_block_comments_on_first_column;
				if (startLine == commentStartLine) {
					indentOnFirstColumn = false;
					IRegion startLinereg = document
							.getLineInformation(startLine);
					// TODO: Do line width calculation based on the
					// formatted content instead of the original content
					lineWidth = comment.sourceStart() + offset
							- startLinereg.getOffset();
					if (position >= 0) {
						// if (getBufferFirstChar(position
						// + lineSeparator.length()) == '\0') {
						afterNewLine = replaceBuffer.substring(
								position + lineSeparator.length(),
								replaceBuffer.length());
						replaceBuffer.replace(position, replaceBuffer.length(),
								""); //$NON-NLS-1$
						insertSpaces(1);
						// } else {
						// insertSpace();
						// }
					} else {
						// if (getBufferFirstChar(0) == '\0') {
						replaceBuffer.setLength(0);
						insertSpaces(1);
						// } else {
						// insertSpace();
						// }
					}
				} else {
					if (position >= 0) {
						// if (getBufferFirstChar(position
						// + lineSeparator.length()) == '\0') {
						replaceBuffer.replace(position + lineSeparator.length(),
								replaceBuffer.length(), ""); //$NON-NLS-1$
						lineWidth = 0;
						// } else {
						// insertNewLine();
						// }
					} else {
						// if (getBufferFirstChar(0) == '\0') {
						replaceBuffer.setLength(0);
						lineWidth = 0;
						// } else {
						// insertNewLine();
						// }
					}
					if (indentationLevelDesending || blockEnd) {
						// add single indentationChar * indentationSize
						// Because the comment is the previous
						// indentation
						// level
						for (int i = 0; i < preferences.indentationSize; i++) {
							appendToBuffer(preferences.indentationChar);
							lineWidth += (preferences.indentationChar == CodeFormatterPreferences.SPACE_CHAR)
									? 0 : 3;
						}
					}
					needIndentNewLine = true;
				}
				resetCommentIndentVariables();
				if (startLine != commentStartLine && blockEnd) {
					recordCommentIndentVariables = true;
				}
				doNotIndent = true;
				if (indentOnFirstColumn) {
					indent();
					doNotIndent = false;
					if (lineWidth > 0) {
						startAtFirstColumn = false;
					}
				}

				handleCharsWithoutComments(start,
						comment.sourceStart() + offset);
				doNotIndent = false;
				start = comment.sourceEnd() + offset;
				resetEnableStatus(document.get(comment.sourceStart() + offset,
						comment.sourceEnd() - comment.sourceStart()));

				if (startLine == commentStartLine) {
					initCommentIndentVariables(offset, startLine, comment,
							endWithNewLineIndent);
					lineWidth = indentLengthForComment;
				}
				if (startAtFirstColumn
						&& this.preferences.never_indent_block_comments_on_first_column) {
					indentLengthForComment = 0;
					indentStringForComment = ""; //$NON-NLS-1$
				}
				if (this.editsEnabled
						&& this.preferences.comment_format_block_comment
						&& !(comment instanceof VarComment)) {
					appendToBuffer("/*"); //$NON-NLS-1$
					commentContent = document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart());

					// boolean needInsertNewLine = commentContent
					// .endsWith(lineSeparator);
					// if (!needInsertNewLine) {
					// String[] delimiters = document.getLegalLineDelimiters();
					// for (int i = 0; i < delimiters.length; i++) {
					// needInsertNewLine = commentContent
					// .endsWith(delimiters[i]);
					// if (needInsertNewLine) {
					// break;
					// }
					// }
					// }
					commentContent = commentContent.trim();
					commentContent = commentContent.substring(2,
							commentContent.length() - 2);
					List<String> lines = Arrays
							.asList(commentContent.split("\r\n?|\n", -1)); //$NON-NLS-1$
					commentWords = new ArrayList<String>();
					if (lines.size() == 1) {
						String word = lines.get(0).trim();
						commentWords.add(word);
						initCommentWords();
						StringBuffer sb = new StringBuffer();
						for (String w : commentWords) {
							if (w.trim().length() == 0) {
								continue;
							}
							sb.append(w).append(" "); //$NON-NLS-1$
						}
						// +1 means ' ' after "/*",+2 means "*/"
						if (this.preferences.comment_line_length == 9999
								|| lineWidth + 1 + sb.length()
										+ 2 <= this.preferences.comment_line_length) {
							appendToBuffer(" "); //$NON-NLS-1$
							appendToBuffer(sb.toString());
							appendToBuffer("*/"); //$NON-NLS-1$
							commentWords = new ArrayList<String>();
							handleCharsWithoutComments(
									comment.sourceStart() + offset,
									comment.sourceEnd() + offset, true);
							// if (needInsertNewLine) {
							insertNewLine();
							// needInsertNewLine = false;
							// } else {
							// IRegion reg = document
							// .getLineInformation(commentEndLine);
							// int lengthAfterCommentEnd = reg.getOffset()
							// + reg.getLength()
							// - (comment.sourceEnd() + offset);
							// if (lengthAfterCommentEnd <= 0) {
							// insertNewLine();
							// } else {
							// String stringAfterCommentEnd = document
							// .get(comment.sourceEnd() + offset,
							// lengthAfterCommentEnd);
							// if (stringAfterCommentEnd.trim().length() == 0) {
							// insertNewLine();
							// } else {
							// insertSpaces(1);
							// afterNewLine = EMPTY_STRING;
							// }
							// }
							// }
							break;
						}
						commentWords = new ArrayList<String>();
					}
					newLineOfComment = false;
					if (this.preferences.comment_new_lines_at_block_boundaries) {
						insertNewLineForPHPBlockComment(indentLengthForComment,
								indentStringForComment);
						newLineOfComment = true;
					}
					boolean isFirst = true;
					for (int j = 0; j < lines.size(); j++) {
						String word = lines.get(j).trim();
						if (word.startsWith("*")) { //$NON-NLS-1$
							word = word.substring(1);
						}
						if (word.length() > 0) {
							commentWords.add(word);
							if (this.preferences.join_lines_in_comments) {
								if (!isFirst) {
									insertNewLineForPHPBlockComment(
											indentLengthForComment,
											indentStringForComment);
									newLineOfComment = true;
								}
								isFirst = false;
								formatCommentBlockWords(indentLengthForComment,
										indentStringForComment);
							}
						} else
							if (!this.preferences.comment_clear_blank_lines_in_block_comment) {
							if (j != 0 && j != lines.size() - 1) {
								formatCommentBlockWords(indentLengthForComment,
										indentStringForComment);
								// don't duplicate first blank line
								if (isFirst
										&& this.preferences.comment_new_lines_at_block_boundaries) {
									newLineOfComment = true;
									isFirst = false;
									continue;
								}
								insertNewLineForPHPBlockComment(
										indentLengthForComment,
										indentStringForComment);
								newLineOfComment = true;
								isFirst = false;
							}
						}
					}
					if (!commentWords.isEmpty()) {
						formatCommentBlockWords(indentLengthForComment,
								indentStringForComment);
						isFirst = false;
					}
					if (isFirst
							&& this.preferences.comment_new_lines_at_block_boundaries) {
						appendToBuffer("/"); //$NON-NLS-1$
					} else if (newLineOfComment
							|| this.preferences.comment_new_lines_at_block_boundaries) {
						insertNewLine();
						if (indentLengthForComment >= 0) {
							appendToBuffer(indentStringForComment);
						} else {
							indent();
						}
						appendToBuffer(" */"); //$NON-NLS-1$
					} else {
						indertWordToComment("*/"); //$NON-NLS-1$
					}
					newLineOfComment = false;
					handleCharsWithoutComments(comment.sourceStart() + offset,
							comment.sourceEnd() + offset, true);
				} else {
					commentContent = document.get(
							comment.sourceStart() + offset,
							comment.sourceEnd() - comment.sourceStart());
					List<String> lines = Arrays
							.asList(commentContent.split("\r\n?|\n", -1)); //$NON-NLS-1$
					appendToBuffer(lines.get(0));
					// indent all lines, even empty lines
					for (int i = 1; i < lines.size(); i++) {
						insertNewLineForPHPBlockComment(indentLengthForComment,
								indentStringForComment, false);
						appendToBuffer(lines.get(i)
								.replaceFirst("^[ \\t\\v\\f]+", "")); //$NON-NLS-1$ //$NON-NLS-2$
					}
					handleCharsWithoutComments(comment.sourceStart() + offset,
							comment.sourceEnd() + offset, true);
				}
				insertNewLine();
				break;
			}
			if (needIndentNewLine) {
				indent();
				needIndentNewLine = false;
				afterNewLine = EMPTY_STRING;
			}
			appendToBuffer(afterNewLine);
		}
		inComment = false;
		ignoreEmptyLineSetting = oldIgnoreEmptyLineSetting;
		handleCharsWithoutComments(start, end);
	}

