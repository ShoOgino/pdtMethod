	/*
	 * The smart copy method also recieve the gap in miliseconds between this machine and the (possibly) remote machine.
	 * By using this data, the smart copy can decide which file should be copied.
	 * A positive time difference means that this machine time is ahead of the other machine time.
	 */
	private static boolean smartCopyDirectory(String from, String to, Map ignoredResources, long timeDifference, IProgressMonitor monitor) {
		try {
			File fromDir = new File(from);
			File toDir = new File(to);

			File[] fromFiles = fromDir.listFiles();
			int fromSize = fromFiles.length;

			monitor = ProgressUtil.getMonitorFor(monitor);
			monitor.beginTask(NLS.bind(PHPServerCoreMessages.getString("FileUtil.copying"), new String[] { from, to }), 550); //$NON-NLS-1$

			File[] toFiles = null;

			// delete old files and directories from this directory
			if (toDir.exists() && toDir.isDirectory()) {
				toFiles = toDir.listFiles();
				int toSize = toFiles.length;

				// check if this exact file exists in the new directory
				for (int i = 0; i < toSize; i++) {
					String name = toFiles[i].getName();
					boolean isDir = toFiles[i].isDirectory();
					boolean found = false;
					for (int j = 0; j < fromSize; j++) {
						if (name.equals(fromFiles[j].getName()) && isDir == fromFiles[j].isDirectory())
							found = true;
					}

					// delete file if it can't be found or isn't the correct type
					/*					if (!found) {
					 if (isDir)
					 deleteDirectory(toFiles[i], new NullProgressMonitor());
					 else
					 toFiles[i].delete();
					 } */
					if (monitor.isCanceled())
						return false;
				}
			} else {
				if (toDir.isFile()) {
					toDir.delete();
				}
				if (!toDir.mkdirs()) {
					monitor.done();
					Display.getDefault().asyncExec(new Runnable() {
						public void run() {
							ErrorDialog.openError(Display.getDefault().getActiveShell(), PHPServerCoreMessages.getString("FileUtil.publishError"), PHPServerCoreMessages.getString("FileUtil.serverPublishError"), new Status(IStatus.ERROR, Activator.PLUGIN_ID, 0, PHPServerCoreMessages.getString("FileUtil.writePermissionError"), null)); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
						}
					});
					return false;
				}
			}
			monitor.worked(50);

			// cycle through files and only copy when it doesn't exist
			// or is newer
			toFiles = toDir.listFiles();

			int toSize = 0;
			if (toFiles != null)
				toSize = toFiles.length;

			//int toSize = toFiles.length;
			int dw = 0;
			if (toSize > 0)
				dw = 500 / toSize;

			for (int i = 0; i < fromSize; i++) {
				File current = fromFiles[i];

				// check if this is a new or newer file
				boolean copy = true;
				if (!current.isDirectory()) {
					String name = current.getName();
					// Deduct the time gap to clear the time gap before comparizon.
					long mod = current.lastModified() - timeDifference;
					for (int j = 0; j < toSize; j++) {
						if (name.equals(toFiles[j].getName()) && mod <= toFiles[j].lastModified())
							copy = false;
					}
				}

				if (copy) {
					String fromFile = current.getAbsolutePath();
					String toFile = to;
					if (!toFile.endsWith(File.separator))
						toFile += File.separator;
					toFile += current.getName();
					if (!ignoredResources.containsKey(current.getName())) {
						if (current.isFile()) {
							copyFile(fromFile, toFile);
							monitor.worked(dw);
						} else if (current.isDirectory()) {
							monitor.subTask(NLS.bind(PHPServerCoreMessages.getString("FileUtil.copying"), new String[] { fromFile, toFile })); //$NON-NLS-1$
							if (!smartCopyDirectory(fromFile, toFile, ProgressUtil.getSubMonitorFor(monitor, dw))) {
								monitor.done();
								return false;
							}
						}
					} else {
						monitor.worked(dw);
					}
				}
				if (monitor.isCanceled()) {
					return false;
				}
			}
			monitor.worked(500 - dw * toSize);
			monitor.done();
			return true;
		} catch (Exception e) {
			Logger.logException("Error smart copying directory " + from + " - " + to, e); //$NON-NLS-1$ //$NON-NLS-2$
			return false;
		}
	}

