	// 0. Prepare the storages:
	public Change createChange(IProgressMonitor monitor) {
		// BucketMap<String, CodeData> existingIncludes = new BucketMap<String,
		// CodeData>();
		// BucketMap<PHPFileData, CodeData> missingHardIncludes = new
		// BucketMap<PHPFileData, CodeData>();
		// BucketMap<PHPFileData, CodeData> missingSoftIncludes = new
		// BucketMap<PHPFileData, CodeData>();
		// List<PHPIncludeFileData> unneededIncludes = new
		// ArrayList<PHPIncludeFileData>();
		// List<PHPIncludeFileData> unresolvedIncludes = new
		// ArrayList<PHPIncludeFileData>();
		//
		//		monitor.beginTask(PHPRefactoringCoreMessages.getString("OrganizeIncludesProcessorDelegate.0"), 11); //$NON-NLS-1$
		//
		// // 1. Find the elements:
		// if (monitor.isCanceled())
		// return null;
		// DoubleBucketMap<String, CodeDataMatch, CodeData> foundClasses =
		// CodeDataSearchEngine.searchClasses(model, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// DoubleBucketMap<String, CodeDataMatch, CodeData> foundInterfaces =
		// CodeDataSearchEngine.searchInterfaces(model, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// DoubleBucketMap<String, CodeDataMatch, CodeData> foundFunctions =
		// CodeDataSearchEngine.searchFunctions(model, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// DoubleBucketMap<String, CodeDataMatch, CodeData> foundConstants =
		// CodeDataSearchEngine.searchConstants(model, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// DoubleBucketMap<String, CodeDataMatch, CodeData> foundCallbacks =
		// CodeDataSearchEngine.searchCallbacks(model, new
		// SubProgressMonitor(monitor, 1));

		// 2. resolve includes for the elements:
		if (monitor.isCanceled())
			return null;
		// resolveIncludes(foundClasses, existingIncludes, missingHardIncludes,
		// missingSoftIncludes, new SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// resolveIncludes(foundInterfaces, existingIncludes,
		// missingHardIncludes, missingSoftIncludes, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// resolveIncludes(foundFunctions, existingIncludes,
		// missingHardIncludes, missingSoftIncludes, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// resolveIncludes(foundConstants, existingIncludes,
		// missingHardIncludes, missingSoftIncludes, new
		// SubProgressMonitor(monitor, 1));
		// if (monitor.isCanceled())
		// return null;
		// resolveIncludes(foundCallbacks, existingIncludes,
		// missingHardIncludes, missingSoftIncludes, new
		// SubProgressMonitor(monitor, 1));
		//
		// // 3. Collect unneeded includes:
		// if (monitor.isCanceled())
		// return null;
		// collectUnneededIncludes(existingIncludes, unneededIncludes,
		// unresolvedIncludes, new SubProgressMonitor(monitor, 1));
		//
		// // 4. Create the change:
		// OrganizeIncludesChange change = new OrganizeIncludesChange(this);
		// change.addEdits(existingIncludes, missingHardIncludes,
		// missingSoftIncludes, unneededIncludes, unresolvedIncludes);

		// TextEditChangeGroup[] textEditChangeGroups =
		// change.getTextEditChangeGroups();
		// if (textEditChangeGroups.length == 0)
		// return null;
		// return change;
		return null;
	}

