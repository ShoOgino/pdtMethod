	/**
	 * adds the Php structured documents regions reparsing...
	 */
	protected StructuredDocumentEvent core_reparse(int rescanStart, int rescanEnd, CoreNodeList oldNodes, boolean firstTime) {
		assert oldNodes != null;

		// if first time - we do not need to restore the php states... 
		// so resume as usual 
		if (firstTime)
			return super.core_reparse(rescanStart, rescanEnd, oldNodes, firstTime);

		// Gets the first region 
		IStructuredDocumentRegion head = oldNodes.getLength() == 0 ? null : oldNodes.item(0);

		// Gets the current parser 
		final RegionParser parser = fStructuredDocument.getParser();
		assert parser instanceof PhpSourceParser;
		PhpSourceParser phpSourceParser = ((PhpSourceParser) parser);

		// if it is a Php structured document region, 
		// we want to restore the previous state of the Php Lexer, 
		// then the PhpTokenizer will be able to resume 
		// tokenzing the edited text. 

		// if it is an XML code - reset the php states
		// and resume as usual ...		
		if (head.getType()  != PHPRegionTypes.PHP_CONTENT) {
			phpSourceParser.setLastStates(null, false);
			return super.core_reparse(rescanStart, rescanEnd, oldNodes, firstTime);
		}
		
		// Gets the old region (to restore the last state)
		PHPStructuredDocumentRegion oldPhpStructureDocument = (PHPStructuredDocumentRegion) head;
		
		// finally... set the old php lexer 
		// (before parsing of the regions) 
		phpSourceParser.setLastStates(oldPhpStructureDocument.lexerState, oldPhpStructureDocument.inPhpState);

		// set the old structured regions 
		lastOldNode = oldNodes.item(oldNodes.getLength() - 1);
		firstOldNode = oldPhpStructureDocument;

		// reset the new region list
		newRegionList.clear();

		// do the reparse
		super.core_reparse(rescanStart, rescanEnd, oldNodes, firstTime);

		// now we should check if we need to resume to 
		// the next structured documents...
		IStructuredDocumentRegion next = lastOldNode.getNext();
		
		// resume reparsing if the states were changes 
		// incomparison to the old ones
		boolean inEnhancedReparseStep = true; // start the enhanced reparsing phase
		while (inEnhancedReparseStep && next != null && next instanceof PHPStructuredDocumentRegion) {
			// go to the next old php region - safe cast
			oldPhpStructureDocument = (PHPStructuredDocumentRegion) next;

			// if the state was changed comparing the oldNodes states - resume reparsing 
			if (oldPhpStructureDocument.inPhpState != phpSourceParser.isLastPhpTokenizerState() || 
			   (oldPhpStructureDocument.lexerState != null && !oldPhpStructureDocument.lexerState.equals(phpSourceParser.getLastPhpLexerState()) || 
		       (phpSourceParser.getLastPhpLexerState() != null && oldPhpStructureDocument.lexerState == null)) )   {

				// update the last node if we extends the dirty end we got
				lastOldNode = oldPhpStructureDocument;

				// resume to next region
				next = oldPhpStructureDocument.getNext();

				// reparse next region
				rescanStart = rescanEnd;
				rescanEnd = rescanStart + oldPhpStructureDocument.getLength();
				super.core_reparse(rescanStart, rescanEnd, new CoreNodeList(oldPhpStructureDocument, oldPhpStructureDocument), firstTime);

			} else {
				// else stop enhanced reparsing.
				inEnhancedReparseStep = false;
			}
		}

		// implement minimumEvent method over all new nodes
		final StructuredDocumentEvent structuredDocumentEvent = super.minimumEvent(new CoreNodeList(firstOldNode, lastOldNode), toUnionList(newRegionList));
		structuredDocumentEvent.setDeletedText(fDeletedText);
		return structuredDocumentEvent;
	}

