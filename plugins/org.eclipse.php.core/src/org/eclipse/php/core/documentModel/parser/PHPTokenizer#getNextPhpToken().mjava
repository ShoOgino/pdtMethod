	private ITextRegion getNextPhpToken() throws IOException {

		if (!storedPhpTokens.isEmpty()) {
			return (ITextRegion) storedPhpTokens.remove(0);
		}
		PhpLexer phpLexer = getPhpLexer();

		// load the starting non-whitespace token (assume that it is so)
		if (fShouldLoadBuffered) {
			context = fBufferedContext;
			start = fBufferedStart;
			textLength = length = fBufferedLength;
			fShouldLoadBuffered = false;
		} else {
			context = phpLexer.yylex();
			start = phpLexer.getTokenStart();
			textLength = length = phpLexer.yylength();
			if (yy_atEOF) {
				fTokenCount++;
				return null;
			}
		}

		if (PHPRegionTypes.PHP_CLOSETAG == context) {
			char[] tmpBuffer = phpLexer.getYy_buffer();
			int[] tmpParameters = phpLexer.getParamenters();
			reset(yy_reader, tmpBuffer, tmpParameters);
			yypushback(length - 2); // we want only the "?>" to get into the PHP region and the whiteSpace to be in the HTML
			fInPhpState = false;
			resetPhpLexer();
			// the 2 stands for "?>" length
			return PHPRegionFactory.getInstance().createToken(PHPRegionContext.PHP_CLOSE, start, 2, 2, null, null, null);
		}

		if (PhpLexer.isPHPCommentState(context)) {
			handlePhpComment();
			return (ITextRegion) storedPhpTokens.remove(0);
		}
		// store the next token
		fBufferedContext = phpLexer.yylex();
		fBufferedStart = phpLexer.getTokenStart();
		fBufferedLength = phpLexer.yylength();
		if (fBufferedContext == PHPRegionTypes.WHITESPACE) {
			fShouldLoadBuffered = false;
			length += fBufferedLength;
		} else {
			fShouldLoadBuffered = true;
		}
		if (context == null) {
			fInPhpState = false;
			resetPhpLexer();
			// EOF
			if (Debug.debugTokenizer) {
				System.out.println(getClass().getName() + " discovered " + fTokenCount + " tokens."); //$NON-NLS-2$//$NON-NLS-1$
			}
			return null;
		}
		fTokenCount++;

		return new PHPContentRegion(start, textLength, length, context);
	}

