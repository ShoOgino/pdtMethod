	private static IModelElement[] getGroupOptions(ISourceModule sourceModule, String prefix, int elementType, int mask, int matchRule, IDLTKSearchScope scope) {
		final Set<IModelElement> elements = new TreeSet<IModelElement>(new AlphabeticComparator());
		Set<String> groups = new HashSet<String>();

		// Build the mixin request key:
		if (elementType == IDLTKSearchConstants.TYPE) {
			IType[] classesAndInterfaces = PHPModelUtils.getClassesAndInterfaces(prefix, matchRule, scope);
			try {
				for (IType type : classesAndInterfaces) {
					int flags = type.getFlags();
					if ((mask & EXCLUDE_CLASSES) == 0 && PHPFlags.isClass(flags)) {
						elements.add(type);
					}
					if ((mask & EXCLUDE_INTERFACES) == 0 && PHPFlags.isInterface(flags)) {
						elements.add(type);
					}
				}
			} catch (ModelException e) {
				PHPCorePlugin.log(e);
			}
		} else {
			elements.addAll(Arrays.asList(PHPModelUtils.getFunctions(prefix, matchRule, scope)));
		}

		// Calculate minimal namespaces:
		int prefixLength = prefix.length();
		for (IModelElement element : elements) {
			String elementName = element.getElementName();
			int nsIdx = elementName.substring(prefixLength).indexOf('_');
			if ((nsIdx >= 0 && prefixLength > 0 || prefixLength == 0 && nsIdx > 0) && nsIdx < elementName.length() - 1) {
				groups.add(elementName.substring(0, prefixLength + nsIdx));
			}
		}

		Set<IModelElement> outOfGroupsElements = new HashSet<IModelElement>();
		outOfGroupsElements.addAll(elements);

		// Calclulate classes to search:
		List<String> filteredGroups = new LinkedList<String>();
		for (String group : groups) {
			List<String> filteredElements = new LinkedList<String>();
			for (IModelElement element : elements) {
				String elementName = element.getElementName();
				if (elementName.startsWith(group)) {
					int underscore = elementName.lastIndexOf('_');
					if (underscore == group.length()) {
						filteredElements.add(elementName);
					}
					outOfGroupsElements.remove(element);
				}
			}
			if (filteredElements.size() == 1) {
				filteredGroups.add(group);
			}
		}
		for (String filteredGroup : filteredGroups) {
			groups.remove(filteredGroup);
		}

		if (groups.size() > 0) {
			List<IModelElement> groupElements = new LinkedList<IModelElement>();
			for (String group : groups) {
				String fakeElementName = new StringBuilder(group).append("_*").toString();
				if (elementType == IDLTKSearchConstants.TYPE) {
					groupElements.add(new FakeGroupType((ModelElement) sourceModule, fakeElementName));
				} else if (elementType == IDLTKSearchConstants.METHOD) {
					groupElements.add(new FakeGroupMethod((ModelElement) sourceModule, fakeElementName));
				}
			}

			// Add all elements that don't fall into any group
			groupElements.addAll(outOfGroupsElements);
			return (IModelElement[]) groupElements.toArray(new IModelElement[groupElements.size()]);
		}
		return (IModelElement[]) elements.toArray(new IModelElement[elements.size()]);
	}

