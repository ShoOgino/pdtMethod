	/**
	 * Parses @@var comment using regular expressions
	 * 
	 * @param content
	 *            Content of the @@var comment token
	 * @param start
	 *            Token start position
	 * @param end
	 *            Token end position
	 * @return {@link VarComment}
	 */
	public static VarComment parseVarComment(String content, int start, int end) {
		Matcher m = VAR_COMMENT_PATTERN.matcher(content);
		if (m.matches()) {
			int varStart = start + m.group(1).length();
			String varName = m.group(2);
			int varEnd = varStart + varName.length();

			List<TypeReference> typeReferences = new LinkedList<TypeReference>();
			int typeStart = varEnd + m.group(3).length();
			String types = m.group(4);

			int pipeIdx = types.indexOf(Constants.TYPE_SEPERATOR_CHAR);
			while (pipeIdx >= 0) {
				String typeName = types.substring(0, pipeIdx);
				int typeEnd = typeStart + typeName.length();
				if (typeName.length() > 0) {
					typeReferences.add(new TypeReference(typeStart, typeEnd,
							typeName));
				}
				types = types.substring(pipeIdx + 1);
				typeStart += pipeIdx + 1;
				pipeIdx = types.indexOf(Constants.TYPE_SEPERATOR_CHAR);
			}
			String typeName = types;
			int typeEnd = typeStart + typeName.length();
			if (typeName.length() > 0) {
				typeReferences.add(new TypeReference(typeStart, typeEnd,
						typeName));
			}

			VariableReference varReference = new VariableReference(varStart,
					varEnd, varName);
			VarComment varComment = new VarComment(start, end, varReference,
					(TypeReference[]) typeReferences
							.toArray(new TypeReference[typeReferences.size()]));
			return varComment;
		}
		return null;
	}

