	private static List<IRegion> collectComments(TextSequence textSequence) {
		StringBuffer buffer = new StringBuffer(textSequence);
		List<IRegion> commentRegions = new ArrayList<IRegion>();
		int start = 0;
		int foundIndex = 0;
		while ((foundIndex = buffer.indexOf("/", start)) != -1) { //$NON-NLS-1$
			int commentStartPosition = foundIndex;
			String currentType = TextSequenceUtilities.getType(textSequence,
					commentStartPosition);
			if (PHPPartitionTypes.isPHPCommentState(currentType)
					&& !PHPPartitionTypes.isPHPQuotesState(currentType)
					&& commentStartPosition + 2 < textSequence.length()) {
				String startCommentString = textSequence.subSequence(
						commentStartPosition, commentStartPosition + 2)
						.toString();
				if (startCommentString.equals(START_BLOCK_COMMENT)) {
					// we are inside comment.
					Matcher commentEndMatcher = COMMENT_END_PATTERN
							.matcher(textSequence);
					boolean foundEnd = commentEndMatcher
							.find(commentStartPosition);
					if (foundEnd) {
						int commentEndPosition = commentEndMatcher.end();
						IRegion range = new Region(commentStartPosition,
								commentEndPosition - commentStartPosition);
						commentRegions.add(range);
						start = commentEndPosition;
					} else {
						start = commentStartPosition + 2;
					}
				} else if (startCommentString.equals(START_LINE_COMMENT)) {
					// we are inside line comment.
					for (int commentEndPosition = commentStartPosition + 2; commentEndPosition < textSequence
							.length(); commentEndPosition++) {
						if (textSequence.charAt(commentEndPosition) == END_LINE) {
							IRegion range = new Region(commentStartPosition,
									commentEndPosition - commentStartPosition);
							commentRegions.add(range);
							start = commentEndPosition;
							break;
						}
					}
					start = commentStartPosition + 2;
				} else {
					start = commentStartPosition + 1;
				}
			} else {
				start = commentStartPosition + 2;
			}
		}
		return commentRegions;
	}

