	private IModelElement[] internalASTResolve(ISourceModule sourceModule,
			IModelAccessCache cache, int offset, int end) throws ModelException {
		String source;

		try {

			source = sourceModule.getSource();
			offset = PHPTextSequenceUtilities.readIdentifierStartIndex(source,
					offset, true);
		} catch (IndexOutOfBoundsException ex) {
			// ISourceModule.getSource() may throw
			// ArrayIndexOutOfBoundsException and
			// PHPTextSequenceUtilities.readIdentifierStartIndex() may throw
			// StringIndexOutOfBoundExceptio in case when main thread
			// modifies editor content in parallel to this action in background
			// thread
			return null;
		}

		end = PHPTextSequenceUtilities
				.readIdentifierEndIndex(source, end, true);

		int methodEnd = PHPTextSequenceUtilities.getMethodEndIndex(source, end);
		if (methodEnd != -1) {
			end = methodEnd;
		}

		ModuleDeclaration parsedUnit = SourceParserUtil.getModuleDeclaration(
				sourceModule, null);

		// boolean inDocBlock=false;
		if (parsedUnit instanceof PHPModuleDeclaration) {
			PHPModuleDeclaration phpModuleDeclaration = (PHPModuleDeclaration) parsedUnit;
			List<PHPDocBlock> phpBlocks = phpModuleDeclaration
					.getPhpDocBlocks();
			for (PHPDocBlock phpDocBlock : phpBlocks) {
				int realStart = phpDocBlock.sourceStart();
				int realEnd = phpDocBlock.sourceEnd();
				if (realStart <= offset && realEnd >= end) {
					// inDocBlock=true;
					PHPDocTag[] tags = phpDocBlock.getTags();
					return lookForMatchingTypes(tags, sourceModule, offset,
							end, cache);
				}
			}
		}
		ASTNode node = ASTUtils.findMinimalNode(parsedUnit, offset, end);
		if (node == null) {
			return null;
		}

		IContext context = ASTUtils.findContext(sourceModule, parsedUnit, node);
		if (context == null) {
			return null;
		}
		if (context instanceof IModelCacheContext) {
			((IModelCacheContext) context).setCache(cache);
		}

		IDLTKSearchScope scope = SearchEngine.createSearchScope(sourceModule
				.getScriptProject());

		// Function call:
		if (node instanceof PHPCallExpression) {
			return processPHPCallExpression((PHPCallExpression) node,
					sourceModule, parsedUnit, offset, context, cache);
		}
		// Static field or constant access:
		else if (node instanceof StaticDispatch) {
			StaticDispatch dispatch = (StaticDispatch) node;
			String fieldName = null;
			if (dispatch instanceof StaticConstantAccess) {
				fieldName = ((StaticConstantAccess) dispatch).getConstant()
						.getName();
			} else if (dispatch instanceof StaticFieldAccess) {
				ASTNode field = ((StaticFieldAccess) dispatch).getField();
				if (field instanceof VariableReference) {
					fieldName = ((VariableReference) field).getName();
				}
			}
			if (fieldName != null && dispatch.getDispatcher() != null) {
				IEvaluatedType dispatcherType = PHPTypeInferenceUtils
						.resolveExpression(sourceModule, parsedUnit, context,
								dispatch.getDispatcher());
				if (dispatcherType != null) {
					IModelElement[] elements = PHPTypeInferenceUtils
							.getModelElements(dispatcherType,
									(ISourceModuleContext) context, offset);
					List<IModelElement> fields = new LinkedList<IModelElement>();
					if (elements != null) {
						for (IModelElement element : elements) {
							if (element instanceof IType) {
								IType type = (IType) element;
								try {
									fields.addAll(Arrays.asList(PHPModelUtils.getTypeHierarchyField(
											type, cache.getSuperTypeHierarchy(
													type,
													new NullProgressMonitor()),
											fieldName, true,
											new NullProgressMonitor())));
								} catch (Exception e) {
									PHPCorePlugin.log(e);
								}
							}
						}
					}
					return fields.toArray(new IModelElement[fields.size()]);
				}
			}
		}
		// Dynamic field access:
		else if (node instanceof FieldAccess) {
			FieldAccess fieldAccess = (FieldAccess) node;
			ASTNode field = fieldAccess.getField();
			String fieldName = null;
			if (field instanceof SimpleReference) {
				fieldName = ((SimpleReference) field).getName();
			}
			if (fieldName != null && fieldAccess.getDispatcher() != null) {
				IEvaluatedType dispatcherType = PHPTypeInferenceUtils
						.resolveExpression(sourceModule, parsedUnit, context,
								fieldAccess.getDispatcher());
				if (dispatcherType != null) {
					IModelElement[] elements = PHPTypeInferenceUtils
							.getModelElements(dispatcherType,
									(ISourceModuleContext) context, offset);
					List<IModelElement> fields = new LinkedList<IModelElement>();
					if (elements != null) {
						for (IModelElement element : elements) {
							if (element instanceof IType) {
								IType type = (IType) element;
								try {
									fields.addAll(Arrays.asList(PHPModelUtils
											.getTypeField(type, fieldName, true)));
								} catch (ModelException e) {
									PHPCorePlugin.log(e);
								}
							}
						}
					}
					return fields.toArray(new IModelElement[fields.size()]);
				}
			}
		} else if (node instanceof NamespaceReference) {
			String name = ((NamespaceReference) node).getName();
			IType[] namespace = PHPModelUtils.getNamespaceOf(name
					+ NamespaceReference.NAMESPACE_SEPARATOR, sourceModule,
					offset, cache, null);
			return namespace == null ? EMPTY : namespace;
		}
		// Class/Interface reference:
		else if (node instanceof TypeReference) {
			TypeReference typeReference = (TypeReference) node;
			IEvaluatedType evaluatedType = PHPTypeInferenceUtils
					.resolveExpression(sourceModule, node);
			if (evaluatedType == null) {
				return EMPTY;
			}
			String name = evaluatedType.getTypeName();
			IModelElement[] types = PHPModelUtils.getTypes(name, sourceModule,
					offset, cache, null,
					!(evaluatedType instanceof PHPTraitType));
			if (types == null || types.length == 0) {
				// This can be a constant or namespace in PHP 5.3:
				if (name.charAt(0) == NamespaceReference.NAMESPACE_SEPARATOR) {
					name = name.substring(1);
				}

				if (evaluatedType instanceof PHPTraitType) {
					types = PhpModelAccess.getDefault().findTraits(null, name,
							MatchRule.EXACT, Modifiers.AccNameSpace, 0, scope,
							null);
				} else {
					types = PhpModelAccess.getDefault().findTypes(null, name,
							MatchRule.EXACT, Modifiers.AccNameSpace, 0, scope,
							null);
				}

				if (types == null || types.length == 0) {
					name = NamespaceReference.NAMESPACE_SEPARATOR + name;
					types = PHPModelUtils.getFields(name, sourceModule, offset,
							cache, null);
				}
				if (types == null || types.length == 0) {
					types = PHPModelUtils.getFunctions(name, sourceModule,
							offset, cache, null);
				}
				if (types == null || types.length == 0) {
					types = PHPModelUtils.getFunctions(typeReference.getName(),
							sourceModule, offset, cache, null);
				}
			}
			return types;
		}
		// 'new' statement
		else if (node instanceof ClassInstanceCreation) {
			ClassInstanceCreation newNode = (ClassInstanceCreation) node;
			Expression className = newNode.getClassName();

			if ((className instanceof SimpleReference || className instanceof FullyQualifiedReference)) {
				IEvaluatedType evaluatedType = PHPTypeInferenceUtils
						.resolveExpression(sourceModule, node);
				return getConstructorsIfAny(extractClasses(PHPModelUtils
						.getTypes(evaluatedType.getTypeName(), sourceModule,
								offset, cache, null)));
			} else if ((className instanceof StaticFieldAccess)) {
				StaticFieldAccess staticFieldAccess = (StaticFieldAccess) className;
				if ((offset >= staticFieldAccess.getDispatcher().sourceStart())
						&& (offset <= staticFieldAccess.getDispatcher()
								.sourceEnd())) {
					className = staticFieldAccess.getDispatcher();
					IEvaluatedType evaluatedType = PHPTypeInferenceUtils
							.resolveExpression(sourceModule, className);
					return extractClasses(PHPModelUtils.getTypes(
							evaluatedType.getTypeName(), sourceModule, offset,
							cache, null));
				} else if ((offset >= staticFieldAccess.getField()
						.sourceStart())
						&& (offset <= staticFieldAccess.getField().sourceEnd())) {
					className = staticFieldAccess.getField();

					String fieldName = null;
					ASTNode field = staticFieldAccess.getField();
					if (field instanceof VariableReference) {
						fieldName = ((VariableReference) field).getName();
					}
					if (fieldName != null
							&& staticFieldAccess.getDispatcher() != null) {
						IEvaluatedType dispatcherType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context,
										staticFieldAccess.getDispatcher());
						if (dispatcherType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(dispatcherType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> fields = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											fields.addAll(Arrays
													.asList(PHPModelUtils
															.getTypeField(type,
																	fieldName,
																	true)));
										} catch (ModelException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}
					}
				}

			}
		}
		// Class name in declaration
		else if ((node instanceof TypeDeclaration || node instanceof MethodDeclaration)
				&& ((Declaration) node).getNameStart() <= offset
				&& ((Declaration) node).getNameEnd() >= offset) {

			IModelElement element = sourceModule.getElementAt(node
					.sourceStart());
			if (element != null) {
				return new IModelElement[] { element };
			}
		} else if (node instanceof SimpleReference) {
			SimpleReference reference = (SimpleReference) node;

			node = ASTUtils.findMinimalNode(parsedUnit, offset, node.end() + 1);
			if (node instanceof TraitAliasStatement) {
				node = ASTUtils.findMinimalNode(parsedUnit, offset,
						node.end() + 1);
				if (node instanceof TraitUseStatement) {
					TraitUseStatement statement = (TraitUseStatement) node;
					List<IModelElement> methods = new LinkedList<IModelElement>();
					for (TypeReference typeReference : statement.getTraitList()) {
						IType[] types = PHPModelUtils.getTypes(
								typeReference.getName(), sourceModule, offset,
								cache, null, false);
						for (IType t : types) {
							IModelElement[] children = t.getChildren();
							for (IModelElement modelElement : children) {
								String name = modelElement.getElementName();
								if (name.startsWith("$")) { //$NON-NLS-1$
									name = name.substring(1);
								}
								if (name.equals(reference.getName())) {
									methods.add(modelElement);
								}
							}
						}
					}

					return methods.toArray(new IMethod[methods.size()]);
				}
			}
		}
		/*
		 * else if (node instanceof Scalar) { Scalar scalar = (Scalar) node; if
		 * (PHPModelUtils.isQuotesString(scalar.getValue())) {
		 * 
		 * IEvaluatedType evaluatedType = PHPTypeInferenceUtils
		 * .resolveExpression(sourceModule, node); if (evaluatedType != null) {
		 * 
		 * IType[] types = PHPModelUtils.getTypes( evaluatedType.getTypeName(),
		 * sourceModule, offset, null, null); return types; } } }
		 */
		return null;
	}

