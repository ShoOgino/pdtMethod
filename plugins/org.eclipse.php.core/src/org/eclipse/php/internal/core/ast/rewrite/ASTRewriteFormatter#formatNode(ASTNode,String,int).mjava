	/**
	 * Creates edits that describe how to format the given string. Returns <code>null</code> if the code could not be formatted for the given kind.
	 * @param node Node describing the type of the string
	 * @param str The unformatted string
	 * @param indentationLevel 
	 * @return Returns the edit representing the result of the formatter
	 * @throws IllegalArgumentException If the offset and length are not inside the string, a
	 *  IllegalArgumentException is thrown.
	 */
	private TextEdit formatNode(ASTNode node, String str, int indentationLevel) {
		// (shalom) We create chunk of php codes that we inject to the formatter.
		// Every node is created with a <?php prefix and, optionally, some more prefix string that is needed for the formatting.
		int code;
		String prefix = "<?php "; //$NON-NLS-1$
		String suffix = ""; //$NON-NLS-1$
		if (node instanceof Statement) {
			if (node.getType() == ASTNode.SWITCH_CASE) {
				prefix += "switch(1) {"; //$NON-NLS-1$
				suffix = "}"; //$NON-NLS-1$
			}
			if (node instanceof MethodDeclaration) {
				prefix += "class x{";
				suffix = "}"; //$NON-NLS-1$
			}

		} else if (node instanceof Expression && node.getType() != ASTNode.SINGLE_FIELD_DECLARATION) {
		} else if (node instanceof BodyDeclaration) {
		} else if (node instanceof Comment) {
			prefix += "class x{";
			suffix = "}"; //$NON-NLS-1$
		} else {
			if (node.getType() == ASTNode.CATCH_CLAUSE) {
				prefix += "try {}"; //$NON-NLS-1$
			}
		}

		String concatStr = prefix + str + suffix;
		TextEdit edit = formatString(0, concatStr, prefix.length(), str.length(), indentationLevel);

		if (prefix.length() > 0) {
			edit = shifEdit(edit, prefix.length(), prefix);
		}
		return edit;
	}

