	/**
	 * This method finds all class fields that match the given prefix.
	 * @param type
	 * @param prefix
	 * @param mask
	 * @return
	 */
	public static IField[] getClassFields(IType type, String prefix, int mask) {
		boolean exactName = (mask & EXACT_NAME) != 0;
		boolean searchConstants = (mask & ONLY_VARIABLES) == 0;

		final Set<IField> fields = new TreeSet<IField>(new AlphabeticComparator());
		try {
			List<IType> searchTypes = new LinkedList<IType>();

			if (prefix.length() == 0) {
				searchTypes.add(type);

				ITypeHierarchy superTypeHierarchy = type.newSupertypeHierarchy(null);
				IType[] allSuperclasses = superTypeHierarchy.getAllSuperclasses(type);
				searchTypes.addAll(Arrays.asList(allSuperclasses));

			} else if (type.getSuperClasses() != null) {
				SearchEngine searchEngine = new SearchEngine();
				IDLTKSearchScope scope;
				SearchPattern pattern;

				int matchRule;
				if (prefix.length() == 0 && !exactName) {
					prefix = WILDCARD;
					matchRule = SearchPattern.R_PATTERN_MATCH;
				} else {
					matchRule = exactName ? SearchPattern.R_EXACT_MATCH : SearchPattern.R_CAMELCASE_MATCH | SearchPattern.R_PREFIX_MATCH;
				}

				scope = SearchEngine.createSuperHierarchyScope(type);

				if (searchConstants) {
					// search for constants in hierarchy
					pattern = SearchPattern.createPattern(prefix, IDLTKSearchConstants.FIELD, IDLTKSearchConstants.DECLARATIONS, matchRule, PHPLanguageToolkit.getDefault());

					searchEngine.search(pattern, new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope, new SearchRequestor() {
						public void acceptSearchMatch(SearchMatch match) throws CoreException {
							fields.add((IField) match.getElement());
						}
					}, null);
				}

				// search for variables in hierarchy
				pattern = SearchPattern.createPattern(prefix.startsWith(DOLLAR) ? prefix : DOLLAR + prefix, IDLTKSearchConstants.FIELD, IDLTKSearchConstants.DECLARATIONS, matchRule, PHPLanguageToolkit.getDefault());

				searchEngine.search(pattern, new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope, new SearchRequestor() {
					public void acceptSearchMatch(SearchMatch match) throws CoreException {
						fields.add((IField) match.getElement());
					}
				}, null);

			} else {
				searchTypes.add(type);
			}

			for (IType searchType : searchTypes) {
				IField[] typeFields = searchType.getFields();

				for (IField typeField : typeFields) {
					String elementName = typeField.getElementName();
					int flags = typeField.getFlags();
					if (PHPFlags.isConstant(flags)) {
						if (exactName) {
							if (elementName.equals(prefix)) {
								fields.add(typeField);
								break;
							}
						} else if (elementName.startsWith(prefix)) {
							fields.add(typeField);
						}
					} else { // variable
						String tmp = prefix;
						if (!tmp.startsWith(DOLLAR)) {
							tmp = DOLLAR + tmp;
						}
						if (exactName) {
							if (elementName.equals(tmp)) {
								fields.add(typeField);
								break;
							}
						} else if (elementName.startsWith(tmp)) {
							fields.add(typeField);
						}
					}
				}
			}
		} catch (Exception e) {
			if (DLTKCore.DEBUG_COMPLETION) {
				e.printStackTrace();
			}
		}
		return fields.toArray(new IField[fields.size()]);
	}

