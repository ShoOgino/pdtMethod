	/**
	 * Creates a placeholder node of the given type. <code>null</code> if the type is not supported
	 * @param nodeType Type of the node to create. Use the type constants in {@link NodeInfoStore}.
	 * @return Returns a place holder node.
	 */
	public final ASTNode newPlaceholderNode(int nodeType) {
	    try {
		    ASTNode node= this.ast.createInstance(nodeType);
		    
			switch (node.getType()) {
		    	case ASTNode.ASSIGNMENT:
		    		Assignment assignment = (Assignment) node;
		    		assignment.setLeftHandSide(this.ast.newVariable("a"));
		    		assignment.setOperator(Assignment.OP_EQUAL);
		    		assignment.setRightHandSide(this.ast.newVariable("a"));
		    		break;
		    	case ASTNode.INFIX_EXPRESSION:
		    		InfixExpression expression = (InfixExpression) node;
		    		expression.setLeft(this.ast.newScalar("a"));
		    		expression.setOperator(InfixExpression.OP_MINUS);
		    		expression.setRight(this.ast.newVariable("a"));
		    		break;
		    	case ASTNode.VARIABLE:
		    		Variable variable = (Variable) node;
		    		variable.setName(this.ast.newIdentifier(""));
		    		break;
				case ASTNode.FIELD_DECLARATION:
//				    ((FieldsDeclaration) node).fragments().add(this.ast.newVariableDeclarationFragment());
				    break;
//				case ASTNode.MODIFIER:
//				    ((Modifier) node).setKeyword(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
//					break;
				case ASTNode.TRY_STATEMENT :
//					((TryStatement) node).setFinally(this.ast.newBlock()); // have to set at least a finally block to be legal code
					break;
//				case ASTNode.VARIABLE_DECLARATION_EXPRESSION :
//				    ((VariableDeclarationExpression) node).fragments().add(this.ast.newVariableDeclarationFragment());
//			    	break;
//				case ASTNode.FIELD_DECLARATION :
//				    ((VariableDeclarationStatement) node).fragments().add(this.ast.newVariableDeclarationFragment());
//		    		break;
//				case ASTNode.PARAMETERIZED_TYPE :
//				    ((ParameterizedType) node).typeArguments().add(this.ast.newWildcardType());
//		    		break;
			}
		    return node;
	    } catch (IllegalArgumentException e) {
	        return null;
	    }
 	}

