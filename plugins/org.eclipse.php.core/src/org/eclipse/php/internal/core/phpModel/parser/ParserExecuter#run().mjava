	/**
	 * The parsing action - in a separate (async) thread
	 * The mutex keeps that only one parsing will be performed
	 */
	public final void run() {

		IWorkspaceRunnable runner = new IWorkspaceRunnable() {

			public void run(IProgressMonitor monitor) throws CoreException {
				try {
					final CompletionLexer lexer = parserManager.createCompletionLexer(reader);
					lexer.setUseAspTagsAsPhp(useAspTagsAsPhp);
					lexer.setParserClient(client);
					lexer.setTasksPatterns(tasksPatterns);

					if (phpParser == null) {
						phpParser = parserManager.createPhpParser();
					}
					phpParser.setScanner(lexer);
					phpParser.setParserClient(client);

					client.startParsing(filename);

					phpParser.parse();

				} catch (Exception e) {
					Logger.logException(e);

				} finally {

					try {
						if (client != null && phpParser != null) {
							client.finishParsing(phpParser.getLength(), phpParser.getCurrentLine(), lastModified);
						}

					} catch (Exception ex) {
						Logger.logException(ex);

					} finally {
						try {
							reader.close();
						} catch (IOException exception) {
							Logger.logException(exception);
						}
					}
				}
			}
		};
		//		Job currentJob = Job.getJobManager().currentJob();
		try {
			//			if (currentJob.getThread() != Thread.currentThread()) {
			IWorkspace workspace = ResourcesPlugin.getWorkspace();
			IResource resource = workspace.getRoot().findMember(new Path(filename));
			ISchedulingRule rule = resource != null ? resource.getProject() : workspace.getRoot();
			workspace.run(runner, rule, 0, null);
			//			} else {
			//				runner.run(null);
			//			}
		} catch (OperationCanceledException e) {
			// don't do anything, it's ok
		} catch (CoreException e) {
			Logger.logException(e);
		}
	}

