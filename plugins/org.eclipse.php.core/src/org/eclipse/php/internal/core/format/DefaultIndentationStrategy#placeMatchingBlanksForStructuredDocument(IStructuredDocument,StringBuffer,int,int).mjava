	public static void placeMatchingBlanksForStructuredDocument(
			final IStructuredDocument document, final StringBuffer result,
			final int lineNumber, final int forOffset)
			throws BadLocationException {
		boolean enterKeyPressed = document.getLineDelimiter().equals(
				result.toString());
		int lastNonEmptyLineIndex = getIndentationBaseLine(document,
				lineNumber, forOffset, false);
		final int indentationBaseLineIndex = getIndentationBaseLine(document,
				lineNumber, forOffset, true);
		final IRegion lastNonEmptyLine = document
				.getLineInformation(lastNonEmptyLineIndex);
		final IRegion indentationBaseLine = document
				.getLineInformation(indentationBaseLineIndex);
		final String blanks = FormatterUtils.getLineBlanks(document,
				indentationBaseLine);
		result.append(blanks);
		IRegion currentLine = document.getLineInformationOfOffset(forOffset);
		if (!enterKeyPressed
				&& document
						.get(currentLine.getOffset(),
								forOffset - currentLine.getOffset()).trim()
						.length() != 0) {
			return;
		}

		ASTNode node = getASTNode(document, forOffset);
		if (node != null) {
			if (enterKeyPressed) {
				node = getIndentNode(node);
			}
			ASTNode parentNode = node.getParent();
			parentNode = getIndentNode(parentNode);
			if (parentNode == null || isInlinePHP(node, parentNode)) {
				originalPlaceMatchingBlanks(document, result, lineNumber,
						forOffset, enterKeyPressed, indentationBaseLineIndex,
						lastNonEmptyLine, blanks);
			} else {
				IRegion startLine = document.getLineInformationOfOffset(node
						.getStart());
				IRegion endLine = document.getLineInformationOfOffset(node
						.getEnd());
				if (currentLine.getOffset() == startLine.getOffset()
						&& !enterKeyPressed/* && result.length() != 0 */) {

					IRegion parentStartLine = document
							.getLineInformationOfOffset(parentNode.getStart());
					result.setLength(result.length() - blanks.length());
					char[] lineChars = document
							.get(parentStartLine.getOffset(),
									parentNode.getStart()
											- parentStartLine.getOffset())
							.toCharArray();
					for (int i = 0; i < lineChars.length; i++) {
						char c = lineChars[i];
						if (Character.isWhitespace(c)) {
							result.append(c);
						} else {
							result.append(" ");
						}
					}
					if (!(parentNode instanceof Program)
							&& !(parentNode instanceof InfixExpression)
							&& !(node instanceof Block)) {
						addIndent(document, result);
					}
					return;
				} else {
					result.setLength(result.length() - blanks.length());
					char[] lineChars = document.get(startLine.getOffset(),
							node.getStart() - startLine.getOffset())
							.toCharArray();
					if (currentLine.getOffset() != endLine.getOffset()
							&& !(node instanceof InfixExpression)) {
						for (int i = 0; i < lineChars.length; i++) {
							char c = lineChars[i];
							if (Character.isWhitespace(c)) {
								result.append(c);
							} else {
								result.append(" ");
							}
						}
						if (!enterKeyPressed && (node instanceof IfStatement)) {
							String currentString = document.get(
									currentLine.getOffset(),
									currentLine.getOffset()
											+ currentLine.getLength());
							if (!currentString.trim().toLowerCase()
									.startsWith("else")) {
								addIndent(document, result);
							}
						} else {
							addIndent(document, result);

						}

					} else {
						for (int i = 0; i < lineChars.length; i++) {
							char c = lineChars[i];
							if (Character.isWhitespace(c)) {
								result.append(c);
							} else {
								return;
							}
						}
					}
				}
			}

		} else {
			originalPlaceMatchingBlanks(document, result, lineNumber,
					forOffset, enterKeyPressed, indentationBaseLineIndex,
					lastNonEmptyLine, blanks);
		}

	}

