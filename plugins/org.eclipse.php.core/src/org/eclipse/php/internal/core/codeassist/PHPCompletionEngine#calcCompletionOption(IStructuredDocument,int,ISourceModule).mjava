	protected void calcCompletionOption(IStructuredDocument document, int offset, ISourceModule sourceModule) throws BadLocationException {

		this.sourceModule = sourceModule;

		phpVersion = PhpVersionProjectPropertyHandler.getVersion(sourceModule.getScriptProject().getProject());

		// Find the structured document region:
		IStructuredDocumentRegion sdRegion = document.getRegionAtCharacterOffset(offset);
		int lastOffset = offset;
		while (sdRegion == null && lastOffset >= 0) {
			lastOffset--;
			sdRegion = document.getRegionAtCharacterOffset(lastOffset);
		}

		if (sdRegion == null) {
			return;
		}

		ITextRegion textRegion = null;
		// 	in case we are at the end of the document, asking for completion
		if (offset == document.getLength()) {
			textRegion = sdRegion.getLastRegion();
		} else {
			textRegion = sdRegion.getRegionAtCharacterOffset(offset);
		}

		if (textRegion == null) {
			return;
		}

		regionContainer = sdRegion;

		if (textRegion instanceof ITextRegionContainer) {
			regionContainer = (ITextRegionContainer) textRegion;
			textRegion = regionContainer.getRegionAtCharacterOffset(offset);
		}

		if (textRegion == null) {
			return;
		}

		if (textRegion.getType() == PHPRegionContext.PHP_OPEN) {
			return;
		}
		if (textRegion.getType() == PHPRegionContext.PHP_CLOSE) {
			if (regionContainer.getStartOffset(textRegion) == offset) {
				ITextRegion regionBefore = regionContainer.getRegionAtCharacterOffset(offset - 1);
				if (regionBefore instanceof IPhpScriptRegion) {
					textRegion = regionBefore;
				}
			} else {
				return;
			}
		}

		// find the start String for completion
		int startOffset = regionContainer.getStartOffset(textRegion);

		//in case we are standing at the beginning of a word and asking for completion
		//should not take into account the found region
		//find the previous region and update the start offset
		if (startOffset == offset) {
			ITextRegion preTextRegion = regionContainer.getRegionAtCharacterOffset(offset - 1);
			IStructuredDocumentRegion preSdRegion = null;
			if (preTextRegion != null || (preSdRegion = sdRegion.getPrevious()) != null && (preTextRegion = preSdRegion.getRegionAtCharacterOffset(offset - 1)) != null) {
				if (preTextRegion.getType() == EMPTY) { //$NON-NLS-1$
					// FIXME needs to be fixed. The problem is what to do if the cursor is exatly between problematic regions, e.g. single line comment and quoted string??
				}
			}
			startOffset = sdRegion.getStartOffset(textRegion);
		}

		boolean inPHPDoc = false;
		String partitionType = null;
		int internalOffset = 0;
		if (textRegion instanceof IPhpScriptRegion) {
			phpScriptRegion = (IPhpScriptRegion) textRegion;
			internalOffset = offset - regionContainer.getStartOffset() - phpScriptRegion.getStart() - 1;

			partitionType = phpScriptRegion.getPartition(internalOffset);
			//if we are at the begining of multi-line comment or docBlock then we should get completion.
			if (partitionType == PHPPartitionTypes.PHP_MULTI_LINE_COMMENT || partitionType == PHPPartitionTypes.PHP_DOC) {
				String regionType = phpScriptRegion.getPhpToken(internalOffset).getType();
				if (regionType == PHPRegionTypes.PHP_COMMENT_START || regionType == PHPRegionTypes.PHPDOC_COMMENT_START) {
					if (phpScriptRegion.getPhpToken(internalOffset).getStart() == internalOffset) {
						partitionType = phpScriptRegion.getPartition(internalOffset - 1);
					}
				}
			}
			if (partitionType == PHPPartitionTypes.PHP_DEFAULT || partitionType == PHPPartitionTypes.PHP_QUOTED_STRING || partitionType == PHPPartitionTypes.PHP_SINGLE_LINE_COMMENT) {
			} else if (partitionType == PHPPartitionTypes.PHP_DOC) {
				inPHPDoc = true;
			} else {
				return;
			}
			internalPHPRegion = (ContextRegion) phpScriptRegion.getPhpToken(internalOffset);
		}

		if (phpScriptRegion == null) {
			return;
		}

		TextSequence statementText = PHPTextSequenceUtilities.getStatement(offset, sdRegion, true);
		String type = internalPHPRegion.getType();
		int totalLength = statementText.length();
		int endPosition = PHPTextSequenceUtilities.readBackwardSpaces(statementText, totalLength); // read whitespace
		int startPosition = PHPTextSequenceUtilities.readIdentifierStartIndex(statementText, endPosition, true);
		String lastWord = statementText.subSequence(startPosition, endPosition).toString();
		hasWhitespaceAtEnd = totalLength != endPosition;

		if (inPHPDoc) {
			if (isInPhpDocCompletion(statementText, offset, lastWord)) {
				// the current position is php doc block.
				return;
			}

			int tagStart = startPosition - 1;
			while (tagStart > 0 && statementText.charAt(tagStart) != TAG_SIGN) {
				--tagStart;
			}
			if (statementText.charAt(tagStart) == TAG_SIGN) {
				++tagStart;
				int tagEnd = PHPTextSequenceUtilities.readIdentifierEndIndex(statementText, tagStart, false);
				String tagName = statementText.subSequence(tagStart, tagEnd).toString();

				wordEndOffset = offset;
				while (!Character.isWhitespace(document.getChar(wordEndOffset))) {
					++wordEndOffset;
				}

				if (isVariableCompletion(offset, tagName, tagEnd == endPosition ? EMPTY : lastWord)) {
					// the current position is a variable completion after @param PHP-doc tag
					return;
				}
				if (isReturnTypeCompletion(offset, tagName, tagEnd == endPosition ? EMPTY : lastWord)) {
					// the current position is a class completion after @return PHP-doc tag
					return;
				}
			}

		} else { // not inside of PHPDoc

			if (isInArrayOptionQuotes(type, offset, statementText)) {
				// the current position is inside quotes as a parameter for an array.
				return;
			}

			if (isPHPSingleQuote(regionContainer, phpScriptRegion, internalPHPRegion, document, offset) || isLineComment(regionContainer, phpScriptRegion, offset)) {
				// we dont have code completion inside single quotes.
				return;
			}

			wordEndOffset = regionContainer.getStartOffset() + phpScriptRegion.getStart() + internalPHPRegion.getTextEnd();

			if (isInFunctionDeclaration(statementText, offset)) {
				// the current position is inside function declaration.
				return;
			}

			if (isInCatchStatement(statementText, offset)) {
				// the current position is inside catch statement.
				return;
			}

			if (hasWhitespaceAtEnd && isNewOrInstanceofStatement(lastWord, EMPTY, offset, type)) { //$NON-NLS-1$
				// the current position is inside new or instanceof statement.
				return;
			}

			int line = document.getLineOfOffset(offset);
			if (isClassFunctionCompletion(statementText, offset, line, lastWord, startPosition)) {
				// the current position is in class function.
				return;
			}

			endPosition = PHPTextSequenceUtilities.readBackwardSpaces(statementText, startPosition); // read whitespace
			startPosition = PHPTextSequenceUtilities.readIdentifierStartIndex(statementText, endPosition, true);
			String firstWord = statementText.subSequence(startPosition, endPosition).toString();

			ITextRegion nextRegion = internalPHPRegion;
			do {
				nextRegion = phpScriptRegion.getPhpToken(nextRegion.getEnd());
				if (!PHPPartitionTypes.isPHPCommentState(nextRegion.getType()) && nextRegion.getType() != PHPRegionTypes.WHITESPACE) {
					break;
				}
			} while (nextRegion.getEnd() < phpScriptRegion.getLength());

			nextWord = document.get(regionContainer.getStartOffset() + phpScriptRegion.getStart() + nextRegion.getStart(), nextRegion.getTextLength());

			hasOpenBraceAtEnd = hasPaamayimNekudotaimAtEnd = hasNSSeparatorAtEnd = false;
			
			if (OPEN_BRACE.equals(nextWord)) {
				hasOpenBraceAtEnd = true;
			}
			else if (PAAMAYIM_NEKUDOTAIM.equals(nextWord)) {
				hasPaamayimNekudotaimAtEnd = true;
			}
			else if (NS_SEPARATOR.equals(nextWord)) {
				hasNSSeparatorAtEnd = true;
			}

			if (!hasWhitespaceAtEnd && isNewOrInstanceofStatement(firstWord, lastWord, offset, type)) {
				// the current position is inside new or instanceof statement.
				if (lastWord.startsWith(DOLLAR)) {
					getRegularCompletion(lastWord, offset);
				}
				return;
			}

			if (hasWhitespaceAtEnd && CodeAssistUtils.isFunctionCall(lastWord, sourceModule.getScriptProject())) {
				// the current position is between the end of a function call and open bracket.
				return;
			}

			if (isInArrayOption(firstWord, lastWord, startPosition, offset, statementText, type)) {
				// the current position is after '[' sign show special completion.
				return;
			}

			if (isInClassDeclaration(statementText, offset)) {
				// the current position is inside class declaration.
				return;
			}

			getRegularCompletion(lastWord, offset);
		}
	}

