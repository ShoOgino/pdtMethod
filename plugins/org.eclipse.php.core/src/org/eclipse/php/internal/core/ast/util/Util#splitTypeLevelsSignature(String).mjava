	/*
	 * Creates a member value from the given constant, and sets the valueKind on the
	 * given memberValuePair
	 */
	/*
	 * public static Object getAnnotationMemberValue(MemberValuePair
	 * memberValuePair, Constant constant) { switch (constant.typeID()) { case
	 * TypeIds.T_int : memberValuePair.valueKind = IMemberValuePair.K_INT; return
	 * new Integer(constant.intValue()); case TypeIds.T_byte :
	 * memberValuePair.valueKind = IMemberValuePair.K_BYTE; return new
	 * Byte(constant.byteValue()); case TypeIds.T_short : memberValuePair.valueKind
	 * = IMemberValuePair.K_SHORT; return new Short(constant.shortValue()); case
	 * TypeIds.T_char : memberValuePair.valueKind = IMemberValuePair.K_CHAR; return
	 * new Character(constant.charValue()); case TypeIds.T_float :
	 * memberValuePair.valueKind = IMemberValuePair.K_FLOAT; return new
	 * Float(constant.floatValue()); case TypeIds.T_double :
	 * memberValuePair.valueKind = IMemberValuePair.K_DOUBLE; return new
	 * Double(constant.doubleValue()); case TypeIds.T_boolean :
	 * memberValuePair.valueKind = IMemberValuePair.K_BOOLEAN; return
	 * Boolean.valueOf(constant.booleanValue()); case TypeIds.T_long :
	 * memberValuePair.valueKind = IMemberValuePair.K_LONG; return new
	 * Long(constant.longValue()); case TypeIds.T_JavaLangString :
	 * memberValuePair.valueKind = IMemberValuePair.K_STRING; return
	 * constant.stringValue(); default: memberValuePair.valueKind =
	 * IMemberValuePair.K_UNKNOWN; return null; } }
	 *//**
		 * Split signatures of all levels from a type unique key.
		 * 
		 * Example: For following type X<Y<Z>,V<W>,U>.A<B>, unique key is:
		 * "LX<LY<LZ;>;LV<LW;>;LU;>.LA<LB;>;"
		 * 
		 * The return splitted signatures array is: [ ['L','X','<','L','Y','<','L','Z'
		 * ,';'>',';','L','V',' <','L','W',';'>',';','L','U','>',';'], ['L','A','
		 * <','L','B',';','>',';']
		 * 
		 * @param typeSignature
		 *            ParameterizedSourceType type signature
		 * @return char[][] Array of signatures for each level of given unique key
		 */
	public final static char[][] splitTypeLevelsSignature(String typeSignature) {
		// In case of IJavaElement signature, replace '$' by '.'
		char[] source = Signature.removeCapture(typeSignature.toCharArray());
		CharOperation.replace(source, '$', '.');

		// Init counters and arrays
		char[][] signatures = new char[10][];
		int signaturesCount = 0;
		// int[] lengthes = new int [10];
		int paramOpening = 0;

		// Scan each signature character
		for (int idx = 0, ln = source.length; idx < ln; idx++) {
			switch (source[idx]) {
			case '>':
				paramOpening--;
				if (paramOpening == 0) {
					if (signaturesCount == signatures.length) {
						System.arraycopy(signatures, 0, signatures = new char[signaturesCount + 10][], 0,
								signaturesCount);
					}
				}
				break;
			case '<':
				paramOpening++;
				break;
			case '*':
			case ';':
				break;
			case '.':
				if (paramOpening == 0) {
					if (signaturesCount == signatures.length) {
						System.arraycopy(signatures, 0, signatures = new char[signaturesCount + 10][], 0,
								signaturesCount);
					}
					signatures[signaturesCount] = new char[idx + 1];
					System.arraycopy(source, 0, signatures[signaturesCount], 0, idx);
					signatures[signaturesCount][idx] = Signature.C_SEMICOLON;
					signaturesCount++;
				}
				break;
			case '/':
				source[idx] = '.';
				break;
			}
		}

		// Resize signatures array
		char[][] typeSignatures = new char[signaturesCount + 1][];
		typeSignatures[0] = source;
		for (int i = 1, j = signaturesCount - 1; i <= signaturesCount; i++, j--) {
			typeSignatures[i] = signatures[j];
		}
		return typeSignatures;
	}

