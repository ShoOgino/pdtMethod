/**
 * Method doScan.
 * 
 * @see doScan(searchString, req...) 
 * this version can handle two strings as options to search string
 * it originally written to support ?> or %> close tags to php
 * The two strings must be on the same length
 *
 * @param searchString1 - target string to search for ex.: "-->", "</tagname"
 * @param searchString2 - target string to search for ex.: "-->", "</tagname"
 * @param requireTailSeparator - whether the target must be immediately followed by whitespace or '>'
 * @param context - the context of the scanned region if non-zero length
 * @param exitState - the state to go to if the region was of non-zero length
 * @param abortState - the state to go to if the searchString was found immediately
 * @return String - the context found: the desired context on a non-zero length match, the abortContext on immediate success
 * @throws IOException
 */
private final String doScan(String searchString1, String searchString2, boolean requireTailSeparator, String searchContext, int exitState, int immediateFallbackState) throws IOException {
	assert searchString1.length() == searchString2.length();
	
	boolean stillSearching = true;
	// Disable further block (probably)
	fIsBlockingEnabled = false;
	int searchStringLength = searchString1.length();
	int n = 0;
	char lastCheckChar;
	int i;
	boolean same = false;
	char quoteChar = 0;
	while (stillSearching) {
		n = 0;
	
		// Ensure that enough data from the input exists to compare against the search String.
		n = yy_advance();
		while(n != YYEOF && yy_currentPos < searchStringLength)
			n = yy_advance();
		// If the input was too short or we've exhausted the input, stop immediately.
		if (n == YYEOF) {
			stillSearching = false;
		}
		else {
			same = true;
			// Ensure that we've not encountered a complete block (<%%>) that was *shorter* than the closeTagString and
			// thus found twice at current-targetLength [since the first scan would have come out this far anyway].
			// Check the characters in the target versus the last targetLength characters read from the buffer
			// and see if it matches
			
			// ignores the "?>" case i.e php end tags in a string
			final char current = yy_buffer[yy_currentPos];
			if (current == '"' || current == '\'') {
				if (quoteChar == 0) {
					quoteChar = current;
				} else {
					if (quoteChar == current) {
						quoteChar = 0;
						continue;
					}					
				}				
			} 			
			if (quoteChar != 0) {
				continue;
			}		
			///////////////////////////
			
			// safety check for array accesses (yy_currentPos is the *last* character we can check against)
			if(yy_currentPos >= searchStringLength &&  yy_currentPos <= yy_buffer.length) {
				for(i = 0; i < searchStringLength; i++) {
					final char c = yy_buffer[i + yy_currentPos - searchStringLength];
					// to enable search of ?> or %> 
					if(same && fIsCaseSensitiveBlocking) {
						same = c == searchString1.charAt(i) || c == searchString2.charAt(i) ;
					}
				}
			}
			// safety check failed; no match is possible right now
			else {
				same = false;
			}
			if (same && requireTailSeparator && yy_currentPos < yy_buffer.length) {
				// Additional check for close tags to ensure that targetString="</script" doesn't match
				// "</scriptS"
				lastCheckChar = yy_buffer[yy_currentPos];
				// Succeed on "</script>" and "</script "
				if(lastCheckChar == '>' || Character.isWhitespace(lastCheckChar))
					stillSearching = false;
			}
			else {
				stillSearching = !same || (yy_currentPos < yy_startRead + searchStringLength);
			}
		}
	}
	if (n != YYEOF || same) {
		// We've stopped short of the end or definitely found a match
		yy_markedPos = yy_currentPos - searchStringLength;
		yy_currentPos = yy_markedPos + 1;
		// If the searchString occurs at the very beginning of what would have
		// been a Block, resume scanning normally immediately
		if (yy_markedPos == yy_startRead) {
			yybegin(immediateFallbackState);
			return primGetNextToken();
		}
	}
	else {
		// We ran through the rest of the input
		yy_markedPos = yy_currentPos;
		yy_currentPos++;
	}
	yybegin(exitState);
	// If the ending occurs at the very beginning of what would have
	// been a Block, resume scanning normally immediately
	if(yy_markedPos == yy_startRead)
		return primGetNextToken();
	return searchContext;
}

