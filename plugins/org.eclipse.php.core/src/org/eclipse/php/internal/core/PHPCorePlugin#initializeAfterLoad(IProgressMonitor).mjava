	/**
	 * Initializes DLTKCore internal structures to allow subsequent operations
	 * (such as the ones that need a resolved classpath) to run full speed. A
	 * client may choose to call this method in a background thread early after
	 * the workspace has started so that the initialization is transparent to
	 * the user.
	 * <p>
	 * However calling this method is optional. Services will lazily perform
	 * initialization when invoked. This is only a way to reduce initialization
	 * overhead on user actions, if it can be performed before at some
	 * appropriate moment.
	 * </p>
	 * <p>
	 * This initialization runs accross all Java projects in the workspace. Thus
	 * the workspace root scheduling rule is used during this operation.
	 * </p>
	 * <p>
	 * This method may return before the initialization is complete. The
	 * initialization will then continue in a background thread.
	 * </p>
	 * <p>
	 * This method can be called concurrently.
	 * </p>
	 * 
	 * @param monitor
	 *            a progress monitor, or <code>null</code> if progress reporting
	 *            and cancellation are not desired
	 * @exception CoreException
	 *                if the initialization fails, the status of the exception
	 *                indicates the reason of the failure
	 * @since 3.1
	 */
	public static void initializeAfterLoad(IProgressMonitor monitor)
			throws CoreException {
		try {
			if (monitor != null) {
				monitor.beginTask(
						CoreMessages.PHPCorePlugin_initializingPHPToolkit, 125);
			}
			// dummy query for waiting until the indexes are ready
			IDLTKSearchScope scope = SearchEngine
					.createWorkspaceScope(PHPLanguageToolkit.getDefault());
			try {
				if (monitor != null) {
					monitor
							.subTask(CoreMessages.PHPCorePlugin_initializingSearchEngine);
					monitor.worked(25);
				}

				PhpModelAccess.getDefault().findMethods("", MatchRule.PREFIX,
						Modifiers.AccGlobal, 0, scope, monitor);
				if (monitor != null) {
					monitor.worked(25);
				}

				PhpModelAccess.getDefault().findTypes("", MatchRule.PREFIX,
						Modifiers.AccGlobal, 0, scope, monitor);
				if (monitor != null) {
					monitor.worked(25);
				}

				PhpModelAccess.getDefault().findFields("", MatchRule.PREFIX,
						Modifiers.AccGlobal, 0, scope, monitor);
				if (monitor != null) {
					monitor.worked(25);
				}

				PhpModelAccess.getDefault().findIncludes("", MatchRule.PREFIX,
						scope, monitor);
				if (monitor != null) {
					monitor.worked(25);
				}

			} catch (OperationCanceledException e) {
				if (monitor != null && monitor.isCanceled()) {
					throw e;
				}
				// else indexes were not ready: catch the exception so that jars
				// are still refreshed
			}
		} finally {
			if (monitor != null) {
				monitor.done();
			}
			toolkitInitialized = true;
		}
	}

