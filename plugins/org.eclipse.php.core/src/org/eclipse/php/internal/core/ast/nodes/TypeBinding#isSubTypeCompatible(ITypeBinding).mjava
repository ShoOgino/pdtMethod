	/**
	 * Returns whether this type is subtype compatible with the given type.
	 * 
	 * @param type the type to check compatibility against
	 * @return <code>true</code> if this type is subtype compatible with the
	 * given type, and <code>false</code> otherwise
	 * 
	 * NOTE: if one of the resolved types are not compatible with this type
	 * <code>false</code> is returned 
	 */
	public boolean isSubTypeCompatible(ITypeBinding otherType) {
		
		if (otherType == null || elements == null || elements.length == 0) {
			return false;
		}

		int compatible = 0;
		for (IModelElement element : elements) {
			IType type = (IType) element;
			try {
				if (type.getSuperClasses() == null || type.getSuperClasses().length == 0) {
					return false;
				}
				ITypeHierarchy supertypeHierarchy = type.newSupertypeHierarchy(new NullProgressMonitor());
				IModelElement[] otherElements = ((TypeBinding) otherType).elements;
				if (otherElements != null) {
					for (IModelElement modelElement : otherElements) {
						if (modelElement instanceof IType && supertypeHierarchy.contains((IType) modelElement)) {
							compatible++;
						}
					}
				}
			} catch (ModelException e) {
				if (DLTKCore.DEBUG) {
					e.printStackTrace();
				}
			}
		}

		// all resolved types were compatible with this type
		return compatible == elements.length;
	}

