	/**
	 * Getting an instance and finding its type.
	 */
	private static IType[] innerGetClassName(ISourceModule sourceModule,
			TextSequence statementText, int propertyEndPosition,
			boolean isClassTriger, int offset) {

		PHPVersion phpVersion = ProjectOptions.getPhpVersion(sourceModule
				.getScriptProject().getProject());

		int classNameStart = PHPTextSequenceUtilities.readIdentifierStartIndex(
				phpVersion, statementText, propertyEndPosition, true);
		String className = statementText.subSequence(classNameStart,
				propertyEndPosition).toString();
		if (isClassTriger && className != null && className.length() != 0) {
			if ("self".equals(className)
					|| "parent".equals(className)
					|| (phpVersion.isGreaterThan(PHPVersion.PHP5) && "static"
							.equals(className))) {
				IType classData = PHPModelUtils.getCurrentType(sourceModule,
						offset - className.length() - 2); // the offset before
				// "self::",
				// "parent::" or
				// "static::"
				if (classData != null) {
					return new IType[] { classData };
				}
			}
			if (className.length() > 0) {
				if (className.startsWith("$")
						&& phpVersion.isGreaterThan(PHPVersion.PHP5)) {
					int statementStart = statementText
							.getOriginalOffset(classNameStart);
					return getVariableType(sourceModule, className,
							statementStart);
				} else {
					ModuleDeclaration moduleDeclaration = SourceParserUtil
							.getModuleDeclaration(sourceModule, null);
					FileContext context = new FileContext(sourceModule,
							moduleDeclaration, offset);
					IEvaluatedType type = PHPClassType.fromTypeName(className,
							sourceModule, offset);
					IType[] modelElements = PHPTypeInferenceUtils
							.getModelElements(type, context, offset);
					if (modelElements != null) {
						return modelElements;
					}
					return EMPTY_TYPES;
				}
			}
		}
		if (className.length() == 0) {
			// this can happen if the first char before the property is ']'
			String testedVar = statementText
					.subSequence(0, propertyEndPosition).toString().trim();
			if (testedVar != null && testedVar.length() != 0) {
				// check for $GLOBALS['myVar'] scenario
				Matcher m = globalPattern.matcher(testedVar);
				if (m.matches()) {
					// $GLOBALS['myVar'] => 'myVar'
					String quotedVarName = testedVar.substring(
							testedVar.indexOf('[') + 1, testedVar.indexOf(']'))
							.trim();
					// 'myVar' => $myVar
					className = DOLLAR
							+ quotedVarName.substring(1,
									quotedVarName.length() - 1); //$NON-NLS-1$
					// check for $array[0] scenario
				} else if (testedVar.endsWith("}") || testedVar.endsWith("]")) {
					className = testedVar;
				}
			}
		}
		// if its object call calc the object type.
		if (className.length() > 0 && className.charAt(0) == '$') {
			int statementStart = statementText
					.getOriginalOffset(classNameStart);
			return getVariableType(sourceModule, className, statementStart);
		}
		// if its function call calc the return type.
		if (propertyEndPosition > 0
				&& statementText.charAt(propertyEndPosition - 1) == ')') {
			int functionNameEnd = PHPModelUtils.getFunctionNameEndOffset(
					statementText, propertyEndPosition - 1);
			int functionNameStart = PHPTextSequenceUtilities
					.readIdentifierStartIndex(phpVersion, statementText,
							functionNameEnd, false);

			String functionName = statementText.subSequence(functionNameStart,
					functionNameEnd).toString();
			// if its a non class function
			Set<IType> returnTypes = new LinkedHashSet<IType>();
			if (functionNameStart == functionNameEnd
					&& statementText.charAt(functionNameStart) == '('
					&& propertyEndPosition - 1 > functionNameStart + 1
					&& phpVersion.isGreaterThan(PHPVersion.PHP5_3)) {
				TextSequence newClassStatementText = statementText
						.subTextSequence(functionNameStart + 1,
								propertyEndPosition - 1);
				String newClassName = PHPModelUtils
						.getClassNameForNewStatement(newClassStatementText,
								phpVersion);
				try {
					return PHPModelUtils.getTypes(newClassName, sourceModule,
							offset, null, null);
				} catch (ModelException e) {
					if (DLTKCore.DEBUG) {
						e.printStackTrace();
					}
				}
				// String newClassName = statementText
				// .subSequence(functionNameStart + 1,
				// propertyEndPosition - 1).toString().trim();
				// if (newClassName.startsWith("new")
				// && newClassName.endsWith(")")) {
				// int newClassNameEnd = PHPModelUtils.getFunctionNameEndOffset(
				// newClassStatementText,
				// newClassStatementText.length() - 1);
				// int newClassNameStart = PHPTextSequenceUtilities
				// .readIdentifierStartIndex(phpVersion,
				// newClassStatementText, newClassNameEnd,
				// false);
				// if (newClassNameStart > 3) {// should have blank chars after
				// // 'new'
				// newClassName = newClassStatementText.subSequence(
				// newClassNameStart, newClassNameEnd).toString();
				//
				// }
				// }

			} else {
				IType[] types = getFunctionReturnType(null, functionName,
						sourceModule, offset);
				if (types != null) {
					returnTypes.addAll(Arrays.asList(types));
				}
			}
			return returnTypes.toArray(new IType[returnTypes.size()]);
		}
		return EMPTY_TYPES;
	}

