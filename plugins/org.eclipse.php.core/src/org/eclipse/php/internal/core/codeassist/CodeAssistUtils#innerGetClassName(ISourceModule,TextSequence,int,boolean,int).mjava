	/**
	 * Getting an instance and finding its type.
	 */
	private static IType[] innerGetClassName(ISourceModule sourceModule,
			TextSequence statementText, int propertyEndPosition,
			boolean isClassTriger, int offset) {

		PHPVersion phpVersion = ProjectOptions.getPhpVersion(sourceModule
				.getScriptProject().getProject());

		int classNameStart = PHPTextSequenceUtilities.readIdentifierStartIndex(
				phpVersion, statementText, propertyEndPosition, true);
		String className = statementText.subSequence(classNameStart,
				propertyEndPosition).toString();
		if (isClassTriger && className != null && className.length() != 0) {
			if ("self".equals(className)
					|| "parent".equals(className)
					|| (phpVersion.isGreaterThan(PHPVersion.PHP5) && "static"
							.equals(className))) {
				IType classData = PHPModelUtils.getCurrentType(sourceModule,
						offset - className.length() - 2); // the offset before
				// "self::",
				// "parent::" or
				// "static::"
				if (classData != null) {
					return new IType[] { classData };
				}
			}
			if (className.length() > 0) {
				if (className.startsWith("$")
						&& phpVersion.isGreaterThan(PHPVersion.PHP5)) {
					int statementStart = statementText
							.getOriginalOffset(classNameStart);
					return getVariableType(sourceModule, className,
							statementStart);
				} else {
					ModuleDeclaration moduleDeclaration = SourceParserUtil
							.getModuleDeclaration(sourceModule, null);
					FileContext context = new FileContext(sourceModule,
							moduleDeclaration, offset);
					IEvaluatedType type = PHPClassType.fromTypeName(className,
							sourceModule, offset);
					IType[] modelElements = PHPTypeInferenceUtils
							.getModelElements(type, context, offset);
					if (modelElements != null) {
						return modelElements;
					}
					return EMPTY_TYPES;
				}
			}
		}
		// check for $GLOBALS['myVar'] scenario
		if (className.length() == 0) {
			// this can happen if the first char before the property is ']'
			String testedVar = statementText
					.subSequence(0, propertyEndPosition).toString().trim();
			if (testedVar != null && testedVar.length() != 0) {
				Matcher m = globalPattern.matcher(testedVar);
				if (m.matches()) {
					// $GLOBALS['myVar'] => 'myVar'
					String quotedVarName = testedVar.substring(
							testedVar.indexOf('[') + 1, testedVar.indexOf(']'))
							.trim();
					// 'myVar' => $myVar
					className = DOLLAR
							+ quotedVarName.substring(1,
									quotedVarName.length() - 1); //$NON-NLS-1$
				}
			}
		}
		// if its object call calc the object type.
		if (className.length() > 0 && className.charAt(0) == '$') {
			int statementStart = statementText
					.getOriginalOffset(classNameStart);
			return getVariableType(sourceModule, className, statementStart);
		}
		// if its function call calc the return type.
		if (propertyEndPosition > 0
				&& statementText.charAt(propertyEndPosition - 1) == ')') {
			int functionNameEnd = getFunctionNameEndOffset(statementText,
					propertyEndPosition - 1);
			int functionNameStart = PHPTextSequenceUtilities
					.readIdentifierStartIndex(phpVersion, statementText,
							functionNameEnd, false);

			String functionName = statementText.subSequence(functionNameStart,
					functionNameEnd).toString();
			// if its a non class function
			Set<IType> returnTypes = new LinkedHashSet<IType>();
			IType[] types = getFunctionReturnType(null, functionName,
					sourceModule, offset);
			if (types != null) {
				returnTypes.addAll(Arrays.asList(types));
			}
			return returnTypes.toArray(new IType[returnTypes.size()]);
		}
		return EMPTY_TYPES;
	}

