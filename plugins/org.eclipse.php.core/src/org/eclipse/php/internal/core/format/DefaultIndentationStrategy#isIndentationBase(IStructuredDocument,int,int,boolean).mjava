	private static boolean isIndentationBase(
			final IStructuredDocument document, final int forOffset,
			int currLineIndex, boolean checkMultiLine)
			throws BadLocationException {

		final IRegion lineInfo = document.getLineInformation(currLineIndex);

		if (lineInfo.getLength() == 0) {
			return false;
		}

		final int checkedOffset = Math.min(
				lineInfo.getOffset() + lineInfo.getLength(), forOffset);

		int lineStart = lineInfo.getOffset();

		if (isBlanks(document, lineStart, checkedOffset, forOffset))
			return false;

		PHPHeuristicScanner scanner = PHPHeuristicScanner
				.createHeuristicScanner(document, checkedOffset, true);
		if (inBracelessBlock(scanner, document, checkedOffset)) {
			return true;
		}

		while (Character.isWhitespace(document.getChar(lineStart)))
			lineStart++;

		// need to get to the first tRegion - so that we wont get the state of
		// the
		// tRegion in the previos line

		// checked line beginning offset (after incrementing spaces in beginning
		final String checkedLineBeginState = FormatterUtils.getPartitionType(
				document, lineStart, true);

		// checked line end
		final String checkedLineEndState = FormatterUtils.getPartitionType(
				document, checkedOffset, true);

		// the current potential line for formatting begin offset
		final String forLineEndState = FormatterUtils.getPartitionType(
				document, forOffset);
		if (isMultilineAfterBraceless(document, checkedOffset)) {
			// braceless block end go up
			return false;
		}
		if (!lineContainIncompleteBlock(document, checkedOffset, lineStart,
				currLineIndex)
				&& (shouldNotConsiderAsIndentationBase(checkedLineBeginState,
						forLineEndState))) {
			return false;
		}
		if (!lineContainIncompleteBlock(document, checkedOffset, lineStart,
				currLineIndex)
				&& (shouldNotConsiderAsIndentationBase(checkedLineBeginState,
						forLineEndState) || (checkMultiLine
						&& isInMultiLineStatement(document,
								checkedLineBeginState, checkedLineEndState,
								checkedOffset, lineStart, currLineIndex) && !isMultilineContentInsideBraceless(
							document, checkedOffset))))
			return false;

		// Fix bug #201688
		if (((checkedLineBeginState == PHPPartitionTypes.PHP_MULTI_LINE_COMMENT) || (checkedLineBeginState == PHPPartitionTypes.PHP_DOC))
				&& (checkedLineBeginState == forLineEndState)) {
			// the whole document
			final IStructuredDocumentRegion sdRegion = document
					.getRegionAtCharacterOffset(lineStart);
			// the whole PHP script
			ITextRegion phpScriptRegion = sdRegion
					.getRegionAtCharacterOffset(lineStart);
			int phpContentStartOffset = sdRegion
					.getStartOffset(phpScriptRegion);

			if (phpScriptRegion instanceof ITextRegionContainer) {
				ITextRegionContainer container = (ITextRegionContainer) phpScriptRegion;
				phpScriptRegion = container
						.getRegionAtCharacterOffset(lineStart);
				phpContentStartOffset += phpScriptRegion.getStart();
			}

			if (phpScriptRegion instanceof IPhpScriptRegion) {
				IPhpScriptRegion scriptRegion = (IPhpScriptRegion) phpScriptRegion;
				// the region we are trying to check if it is the indent base
				// for the line we need to format
				ContextRegion checkedRegion = (ContextRegion) scriptRegion
						.getPhpToken(lineStart - phpContentStartOffset);
				// the current region we need to format
				ContextRegion currentRegion = (ContextRegion) scriptRegion
						.getPhpToken(forOffset - phpContentStartOffset);
				String checkedType = checkedRegion.getType();
				String currentType = currentRegion.getType();
				// if we are in the beginning of a comment (DOC or Multi
				// comment) and we have before another
				// Doc comment or Multi comment, the base line we'll be the
				// beginning of the previous multi comment
				if (currentType.equals(PHPRegionTypes.PHPDOC_COMMENT_START)
						|| currentType.equals(PHPRegionTypes.PHP_COMMENT_START)) {
					return checkedType
							.equals(PHPRegionTypes.PHPDOC_COMMENT_START)
							|| checkedType
									.equals(PHPRegionTypes.PHP_COMMENT_START);
				}
			}
		}

		return lineShouldInedent(checkedLineBeginState, checkedLineEndState)
				|| forLineEndState == checkedLineBeginState;
	}

