	private IModelElement[] internalResolve(IStructuredDocument sDoc,
			ISourceModule sourceModule, int offset, int end) {
		try {
			IStructuredDocumentRegion sRegion = sDoc
					.getRegionAtCharacterOffset(offset);
			if (sRegion != null) {
				ITextRegion tRegion = sRegion
						.getRegionAtCharacterOffset(offset);

				ITextRegionCollection container = sRegion;
				if (tRegion instanceof ITextRegionContainer) {
					container = (ITextRegionContainer) tRegion;
					tRegion = container.getRegionAtCharacterOffset(offset);
				}

				if (tRegion != null
						&& tRegion.getType() == PHPRegionContext.PHP_CONTENT) {
					IPhpScriptRegion phpScriptRegion = (IPhpScriptRegion) tRegion;
					tRegion = phpScriptRegion.getPhpToken(offset
							- container.getStartOffset()
							- phpScriptRegion.getStart());
					if (tRegion == null) {
						return EMPTY;
					}
					// Determine element name:
					int elementStart = container.getStartOffset()
							+ phpScriptRegion.getStart() + tRegion.getStart();
					TextSequence statement = PHPTextSequenceUtilities
							.getStatement(elementStart + tRegion.getLength(),
									sRegion, true);
					int endPosition = PHPTextSequenceUtilities
							.readBackwardSpaces(statement, statement.length());
					int startPosition = PHPTextSequenceUtilities
							.readIdentifierStartIndex(phpVersion, statement,
									endPosition, true);
					String elementName = statement.subSequence(startPosition,
							endPosition).toString();

					// Determine previous word:
					int prevWordEnd = PHPTextSequenceUtilities
							.readBackwardSpaces(statement, startPosition);
					int prevWordStart = PHPTextSequenceUtilities
							.readIdentifierStartIndex(phpVersion, statement,
									prevWordEnd, false);
					String prevWord = statement.subSequence(prevWordStart,
							prevWordEnd).toString();

					// Determine next word:
					ITextRegion nextRegion = tRegion;
					do {
						nextRegion = phpScriptRegion.getPhpToken(nextRegion
								.getEnd());
						if (!PHPPartitionTypes.isPHPCommentState(nextRegion
								.getType())
								&& nextRegion.getType() != PHPRegionTypes.WHITESPACE) {
							break;
						}
					} while (nextRegion.getEnd() < phpScriptRegion.getLength());

					String nextWord = sDoc.get(
							container.getStartOffset()
									+ phpScriptRegion.getStart()
									+ nextRegion.getStart(),
							nextRegion.getTextLength());

					if (elementName.length() > 0) {
						IType containerType = PHPModelUtils.getCurrentType(
								sourceModule, offset);
						if (containerType == null) {
							containerType = PHPModelUtils.getCurrentNamespace(
									sourceModule, offset);
						}

						// If we are in function declaration:
						if (FUNCTION.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
							if (containerType != null) {
								return PHPModelUtils.getTypeMethod(
										containerType, elementName, true);
							}
							return getFunction(sourceModule, elementName);
						}

						// If we are in class declaration:
						if (CLASS.equalsIgnoreCase(prevWord)
								|| INTERFACE.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$ //$NON-NLS-2$
							if (containerType != null) {
								if (containerType.getElementName()
										.equalsIgnoreCase(elementName)) {
									containerType = PHPModelUtils
											.getCurrentNamespace(sourceModule,
													offset);
								}
								if (containerType != null) {
									return PHPModelUtils.getTypeType(
											containerType, elementName, true);
								}
							}
							return getClass(sourceModule, elementName);
						}

						// Class instantiation:
						if (NEW.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
							return getConstructorsIfAny(extractClasses(PHPModelUtils
									.getTypes(elementName, sourceModule,
											offset, null, null)));
						}

						// Handle extends and implements:
						// Check that the statement suites the condition. If
						// class or interface keywords don't appear in the
						// beginning of the statement or they are alone there.
						boolean isClassDeclaration = false;
						if (statement.length() > 6
								&& (CLASS.equals(statement.subSequence(0, 5)
										.toString())
										&& (isClassDeclaration = true) || statement
										.length() > 10
										&& INTERFACE.equals(statement
												.subSequence(0, 9).toString()))) { //$NON-NLS-1$ //$NON-NLS-2$

							IModelElement[] generalizationTypes = getGeneralizationTypes(
									sourceModule, isClassDeclaration, prevWord,
									elementName, offset);
							if (generalizationTypes != null) {
								return generalizationTypes;
							}

							// Multiple extensions and implementations:
							int listStartPosition = PHPTextSequenceUtilities
									.readIdentifierListStartIndex(statement,
											endPosition);

							// Determine pre-list word:
							int preListWordEnd = PHPTextSequenceUtilities
									.readBackwardSpaces(statement,
											listStartPosition);
							int preListWordStart = PHPTextSequenceUtilities
									.readIdentifierStartIndex(statement,
											preListWordEnd, false);
							String preListWord = statement.subSequence(
									preListWordStart, preListWordEnd)
									.toString();

							generalizationTypes = getGeneralizationTypes(
									sourceModule, isClassDeclaration,
									preListWord, elementName, offset);
							if (generalizationTypes != null) {
								return generalizationTypes;
							}
						}

						// Previous trigger:
						String trigger = null;
						if (startPosition > 2) {
							trigger = statement.subSequence(startPosition - 2,
									startPosition).toString();
						}

						// If this is variable:
						if (elementName.charAt(0) == '$'
								&& !PAAMAYIM_NEKUDOTAIM.equals(trigger)) { //$NON-NLS-1$
							// Don't show escaped variables within PHP string:
							if (PHPPartitionTypes.isPHPQuotesState(tRegion
									.getType())) {
								try {
									char charBefore = sDoc.get(
											elementStart - 2, 1).charAt(0);
									if (charBefore == '\\') {
										return EMPTY;
									}
								} catch (BadLocationException e) {
									PHPCorePlugin.log(e);
								}
							}

							// If we are in var definition:
							if (containerType != null) {
								if (VAR.equalsIgnoreCase(prevWord)
										|| PRIVATE.equalsIgnoreCase(prevWord)
										|| STATIC.equalsIgnoreCase(prevWord)
										|| PUBLIC.equalsIgnoreCase(prevWord)
										|| PROTECTED.equalsIgnoreCase(prevWord)) {
									return PHPModelUtils.getTypeField(
											containerType, elementName, true);
								}
								if (THIS.equalsIgnoreCase(elementName)) { //$NON-NLS-1$
									return new IModelElement[] { containerType };
								}
							}

							return getGlobalOrMethodFields(sourceModule,
									offset, elementName);
						}

						// If we are at class constant definition:
						if (containerType != null) {
							if (CONST.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
								return PHPModelUtils.getTypeField(
										containerType, elementName, true);
							}
						}

						// We are at class trigger:
						if (PAAMAYIM_NEKUDOTAIM.equals(nextWord)) { //$NON-NLS-1$
							return PHPModelUtils.getTypes(elementName,
									sourceModule, offset, null, null);
						}
						if (NS_SEPARATOR.equals(nextWord)) { //$NON-NLS-1$
							IDLTKSearchScope scope = SearchEngine
									.createSearchScope(sourceModule
											.getScriptProject());
							return PhpModelAccess.getDefault().findTypes(null,
									elementName, MatchRule.EXACT,
									Modifiers.AccNameSpace, 0, scope, null);
						}

						IType[] types = CodeAssistUtils.getTypesFor(
								sourceModule, statement, startPosition, offset);

						// Is it function or method:
						if (OPEN_BRACE.equals(nextWord)
								|| PHPPartitionTypes.isPHPDocState(tRegion
										.getType())) { //$NON-NLS-1$
							if (types != null && types.length > 0) {
								List<IMethod> methods = new LinkedList<IMethod>();
								for (IType t : types) {
									methods.addAll(Arrays.asList(PHPModelUtils
											.getTypeHierarchyMethod(t,
													elementName, true, null)));
								}
								return methods.toArray(new IMethod[methods
										.size()]);
							}
							return PHPModelUtils.getFunctions(elementName,
									sourceModule, offset, null, null);
						}

						if (types != null && types.length > 0) {
							// Check whether this is a class constant:
							if (startPosition > 0) {
								if (PAAMAYIM_NEKUDOTAIM.equals(trigger)
										&& elementName.charAt(0) != '$') { //$NON-NLS-1$
									List<IModelElement> fields = new LinkedList<IModelElement>();
									for (IType t : types) {
										IField[] typeFields = PHPModelUtils
												.getTypeField(t, elementName,
														true);
										for (IField currentField : typeFields) {
											fields.add(currentField);
										}
									}
									return fields
											.toArray(new IModelElement[fields
													.size()]);
								}
							}

							// What can it be? Only class variables:
							Set<IModelElement> fields = new TreeSet<IModelElement>(
									new SourceFieldComparator());
							for (IType t : types) {
								fields.addAll(Arrays.asList(PHPModelUtils
										.getTypeHierarchyField(t, elementName,
												true, null)));
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}

						// This can be only global constant, if we've reached
						// here:
						IField[] fields = PHPModelUtils.getFields(elementName,
								sourceModule, offset, null, null);
						if (fields != null && fields.length > 0) {
							return fields;
						}

						// Return class if nothing else found.
						return PHPModelUtils.getTypes(elementName,
								sourceModule, offset, null, null);
					}
				}
			}
		} catch (Exception e) {
			PHPCorePlugin.log(e);
		}
		return EMPTY;
	}

