	private IModelElement[] internalResolve(IStructuredDocument sDoc, ISourceModule sourceModule, int offset, int end) {
		try {
			IStructuredDocumentRegion sRegion = sDoc.getRegionAtCharacterOffset(offset);
			if (sRegion != null) {
				ITextRegion tRegion = sRegion.getRegionAtCharacterOffset(offset);

				ITextRegionCollection container = sRegion;
				if (tRegion instanceof ITextRegionContainer) {
					container = (ITextRegionContainer) tRegion;
					tRegion = container.getRegionAtCharacterOffset(offset);
				}

				if (tRegion.getType() == PHPRegionContext.PHP_CONTENT) {
					IPhpScriptRegion phpScriptRegion = (IPhpScriptRegion) tRegion;
					tRegion = phpScriptRegion.getPhpToken(offset - container.getStartOffset() - phpScriptRegion.getStart());

					// Determine element name:
					int elementStart = container.getStartOffset() + phpScriptRegion.getStart() + tRegion.getStart();
					TextSequence statement = PHPTextSequenceUtilities.getStatement(elementStart + tRegion.getLength(), sRegion, true);
					int endPosition = PHPTextSequenceUtilities.readBackwardSpaces(statement, statement.length());
					int startPosition = PHPTextSequenceUtilities.readIdentifierStartIndex(phpVersion, statement, endPosition, true);
					String elementName = statement.subSequence(startPosition, endPosition).toString();

					// Determine previous word:
					int prevWordEnd = PHPTextSequenceUtilities.readBackwardSpaces(statement, startPosition);
					int prevWordStart = PHPTextSequenceUtilities.readIdentifierStartIndex(phpVersion, statement, prevWordEnd, false);
					String prevWord = statement.subSequence(prevWordStart, prevWordEnd).toString();

					// Determine next word:
					ITextRegion nextRegion = tRegion;
					do {
						nextRegion = phpScriptRegion.getPhpToken(nextRegion.getEnd());
						if (!PHPPartitionTypes.isPHPCommentState(nextRegion.getType()) && nextRegion.getType() != PHPRegionTypes.WHITESPACE) {
							break;
						}
					} while (nextRegion.getEnd() < phpScriptRegion.getLength());

					String nextWord = sDoc.get(container.getStartOffset() + phpScriptRegion.getStart() + nextRegion.getStart(), nextRegion.getTextLength());

					if (elementName.length() > 0) {
						IType containerType = PHPModelUtils.getCurrentType(sourceModule, offset);
						if (containerType == null) {
							containerType = PHPModelUtils.getCurrentNamespace(sourceModule, offset);
						}

						// If we are in function declaration:
						if (FUNCTION.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
							if (containerType != null) {
								IMethod typeMethod = PHPModelUtils.getTypeMethod(containerType, elementName);
								if (typeMethod != null) {
									return new IMethod[] { typeMethod };
								}
								return EMPTY;
							}
							return getFunction(sourceModule, elementName);
						}

						// If we are in class declaration:
						if (CLASS.equalsIgnoreCase(prevWord) || INTERFACE.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$ //$NON-NLS-2$
							if (containerType != null) {
								if (containerType.getElementName().equalsIgnoreCase(elementName)) {
									containerType = PHPModelUtils.getCurrentNamespace(sourceModule, offset);
								}
								IType typeType = PHPModelUtils.getTypeType(containerType, elementName);
								if (typeType != null) {
									return new IType[] { typeType };
								}
								return EMPTY;
							}
							return getClass(sourceModule, elementName);
						}

						// Class instantiation:
						if (NEW.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
							return extractClasses(PHPTypeInferenceUtils.getTypes(elementName, sourceModule, offset));
						}

						// Handle extends and implements:
						// Check that the statement suites the condition. If class or interface keywords don't appear in the beginning of the statement or they are alone there.
						boolean isClassDeclaration = false;
						if (statement.length() > 6 && (CLASS.equals(statement.subSequence(0, 5).toString()) && (isClassDeclaration = true) || statement.length() > 10 && INTERFACE.equals(statement.subSequence(0, 9).toString()))) { //$NON-NLS-1$ //$NON-NLS-2$

							IModelElement[] generalizationTypes = getGeneralizationTypes(sourceModule, isClassDeclaration, prevWord, elementName, offset);
							if (generalizationTypes != null) {
								return generalizationTypes;
							}

							// Multiple extensions and implementations:
							int listStartPosition = PHPTextSequenceUtilities.readIdentifierListStartIndex(statement, endPosition);

							// Determine pre-list word:
							int preListWordEnd = PHPTextSequenceUtilities.readBackwardSpaces(statement, listStartPosition);
							int preListWordStart = PHPTextSequenceUtilities.readIdentifierStartIndex(statement, preListWordEnd, false);
							String preListWord = statement.subSequence(preListWordStart, preListWordEnd).toString();

							generalizationTypes = getGeneralizationTypes(sourceModule, isClassDeclaration, preListWord, elementName, offset);
							if (generalizationTypes != null) {
								return generalizationTypes;
							}
						}

						// Previous trigger:
						String trigger = null;
						if (startPosition > 2) {
							trigger = statement.subSequence(startPosition - 2, startPosition).toString();
						}

						// If this is variable:
						if (elementName.charAt(0) == '$' && !PAAMAYIM_NEKUDOTAIM.equals(trigger)) { //$NON-NLS-1$
							// Don't show escaped variables within PHP string:
							if (PHPPartitionTypes.isPHPQuotesState(tRegion.getType())) {
								try {
									char charBefore = sDoc.get(elementStart - 2, 1).charAt(0);
									if (charBefore == '\\') {
										return EMPTY;
									}
								} catch (BadLocationException e) {
									PHPCorePlugin.log(e);
								}
							}

							// If we are in var definition:
							if (containerType != null) {
								if (VAR.equalsIgnoreCase(prevWord) || PRIVATE.equalsIgnoreCase(prevWord) || STATIC.equalsIgnoreCase(prevWord) || PUBLIC.equalsIgnoreCase(prevWord) || PROTECTED.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
									IField typeField = PHPModelUtils.getTypeField(containerType, elementName);
									if (typeField != null) {
										return new IField[] { typeField };
									}
									return EMPTY;
								}
								if (THIS.equalsIgnoreCase(elementName)) { //$NON-NLS-1$
									return new IModelElement[] { containerType };
								}
							}

							IModelElement[] elements = getGlobalOrMethodFields(sourceModule, offset, elementName);
							Collection<IModelElement> filtered = PHPModelUtils.filterElements(sourceModule, Arrays.asList(elements));
							return (IModelElement[]) filtered.toArray(new IModelElement[filtered.size()]);
						}

						// If we are at class constant definition:
						if (containerType != null) {
							if (CONST.equalsIgnoreCase(prevWord)) { //$NON-NLS-1$
								IField typeField = PHPModelUtils.getTypeField(containerType, elementName);
								if (typeField != null) {
									return new IField[] { typeField };
								}
								return EMPTY;
							}
						}

						// We are at class trigger:
						if (PAAMAYIM_NEKUDOTAIM.equals(nextWord)) { //$NON-NLS-1$
							IType[] types = PHPTypeInferenceUtils.getTypes(elementName, sourceModule, offset);
							Collection<IType> filtered = PHPModelUtils.filterElements(sourceModule, Arrays.asList(types));
							return (IType[]) filtered.toArray(new IType[filtered.size()]);
						}
						if (NS_SEPARATOR.equals(nextWord)) { //$NON-NLS-1$
							return PHPTypeInferenceUtils.getNamespaces(elementName, sourceModule);
						}

						IType[] types = CodeAssistUtils.getTypesFor(sourceModule, statement, startPosition, offset);

						// Is it function or method:
						if (OPEN_BRACE.equals(nextWord) || PHPPartitionTypes.isPHPDocState(tRegion.getType())) { //$NON-NLS-1$
							if (types != null && types.length > 0) {
								List<IMethod> methods = new LinkedList<IMethod>();
								for (IType t : types) {
									methods.addAll(Arrays.asList(CodeAssistUtils.getTypeMethods(t, elementName, CodeAssistUtils.EXACT_NAME)));
								}
								return methods.toArray(new IMethod[methods.size()]);
							}
							IMethod[] methods = PHPTypeInferenceUtils.getMethods(elementName, sourceModule, offset);
							Collection<IMethod> filtered = PHPModelUtils.filterElements(sourceModule, Arrays.asList(methods));
							return (IMethod[]) filtered.toArray(new IMethod[filtered.size()]);
						}

						if (types != null && types.length > 0) {
							// Check whether this is a class constant:
							if (startPosition > 0) {
								if (PAAMAYIM_NEKUDOTAIM.equals(trigger) && elementName.charAt(0) != '$') { //$NON-NLS-1$
									List<IModelElement> fields = new LinkedList<IModelElement>();
									for (IType t : types) {
										IField typeField = PHPModelUtils.getTypeField(t, elementName);
										if (typeField != null) {
											fields.add(typeField);
										}
									}
									return fields.toArray(new IModelElement[fields.size()]);
								}
							}

							// What can it be? Only class variables:
							Set<IModelElement> fields = new TreeSet<IModelElement>(new Comparator<IModelElement>() {
								public int compare(IModelElement o1, IModelElement o2) {
									try {
										ISourceRange r1 = ((SourceRefElement)o1).getSourceRange();
										ISourceRange r2 = ((SourceRefElement)o2).getSourceRange();
										return (int) Math.signum(r1.getOffset() - r2.getOffset());
									} catch (ModelException e) {
										if (DLTKCore.DEBUG_SELECTION) {
											e.printStackTrace();
										}
									}
									return 0;
								}
							});
							for (IType t : types) {
								fields.addAll(Arrays.asList(CodeAssistUtils.getTypeFields(t, elementName, CodeAssistUtils.EXACT_NAME)));
							}
							return fields.toArray(new IModelElement[fields.size()]);
						}

						// This can be only global constant, if we've reached here:
						IField[] fields = PHPTypeInferenceUtils.getFields(elementName, sourceModule, offset);
						Collection<IField> constants = PHPModelUtils.filterElements(sourceModule, Arrays.asList(fields));
						if (constants.size() > 0) {
							return (IField[]) constants.toArray(new IField[constants.size()]);
						}

						// Return class if nothing else found.
						IType[] elements = PHPTypeInferenceUtils.getTypes(elementName, sourceModule, offset);
						Collection<IType> filtered = PHPModelUtils.filterElements(sourceModule, Arrays.asList(elements));
						return (IType[]) filtered.toArray(new IType[filtered.size()]);
					}
				}
			}
		} catch (Exception e) {
			if (DLTKCore.DEBUG_SELECTION) {
				e.printStackTrace();
			}
		}
		return EMPTY;
	}

