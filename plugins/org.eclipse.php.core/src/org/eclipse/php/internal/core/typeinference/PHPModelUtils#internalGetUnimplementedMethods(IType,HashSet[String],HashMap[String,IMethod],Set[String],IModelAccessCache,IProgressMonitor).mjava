	private static void internalGetUnimplementedMethods(IType type,
			HashSet<String> nonAbstractMethods,
			HashMap<String, IMethod> abstractMethods,
			Set<String> processedTypes, IModelAccessCache cache,
			IProgressMonitor monitor) throws ModelException {

		int typeFlags = type.getFlags();
		for (IMethod method : type.getMethods()) {
			String methodName = method.getElementName();
			int methodFlags = method.getFlags();
			boolean isAbstract = PHPFlags.isAbstract(methodFlags);
			if (isAbstract || PHPFlags.isInterface(typeFlags)) {
				if (!abstractMethods.containsKey(methodName)) {
					abstractMethods.put(methodName, method);
				}
			} else if (!isAbstract) {
				nonAbstractMethods.add(methodName);
			}
		}

		String[] superClasses = type.getSuperClasses();
		if (superClasses != null) {
			for (String superClass : superClasses) {
				if (!processedTypes.add(superClass)) {
					continue;
				}

				Collection<IType> types = null;
				if (cache == null) {
					IDLTKSearchScope scope = SearchEngine
							.createSearchScope(type.getScriptProject());
					IType[] superTypes = PhpModelAccess.getDefault().findTypes(
							superClass, MatchRule.EXACT, 0,
							Modifiers.AccNameSpace, scope, null);
					types = fileNetworkFilter(type.getSourceModule(), Arrays
							.asList(superTypes), null);
				} else {
					String namespaceName = null;
					int i = superClass
							.lastIndexOf(NamespaceReference.NAMESPACE_SEPARATOR);
					if (i != -1) {
						namespaceName = superClass.substring(0, i);
						superClass = superClass.substring(i + 1);
					}
					types = cache.getClassesOrInterfaces(
							type.getSourceModule(), superClass, namespaceName,
							monitor);
				}
				if (types != null) {
					for (IType superType : types) {
						internalGetUnimplementedMethods(superType,
								nonAbstractMethods, abstractMethods,
								processedTypes, cache, monitor);
					}
				}
			}
		}
	}

