	/**
	 * Converts all modifications recorded by this rewriter into an object representing the the corresponding text
	 * edits to the source of a {@link ITypeRoot} from which the AST was created from.
	 * The type root's source itself is not modified by this method call.
	 * <p>
	 * Important: This API can only be used if the modified AST has been created from a
	 * {@link ITypeRoot} with source. That means {@link ASTParser#setSource(IProgram)},
	 * {@link ASTParser#setSource(IClassFile)} or {@link ASTParser#setSource(ITypeRoot)}
	 * has been used when initializing the {@link ASTParser}. A {@link IllegalArgumentException} is thrown
	 * otherwise. An {@link IllegalArgumentException} is also thrown when the type roots buffer does not correspond
	 * anymore to the AST. Use {@link #rewriteAST(IDocument, Map)} for all ASTs created from other content.
	 * </p>
	 * <p>
	 * For nodes in the original that are being replaced or deleted,
	 * this rewriter computes the adjusted source ranges
	 * by calling <code>getTargetSourceRangeComputer().computeSourceRange(node)</code>.
	 * </p>
	 * <p>
	 * Calling this methods does not discard the modifications
	 * on record. Subsequence modifications are added to the ones
	 * already on record. If this method is called again later,
	 * the resulting text edit object will accurately reflect
	 * the net cumulative affect of all those changes.
	 * </p>
	 * 
	 * @return text edit object describing the changes to the
	 * document corresponding to the changes recorded by this rewriter
	 * @throws ModelException A {@link ModelException} is thrown when
	 * the underlying compilation units buffer could not be accessed.
	 * @throws IllegalArgumentException An {@link IllegalArgumentException}
	 * is thrown if the document passed does not correspond to the AST that is rewritten.
	 * 
	 * @since 3.2
	
	TODO: Rewrite action goes here

	public TextEdit rewriteAST() throws ModelException, IllegalArgumentException {
		ASTNode rootNode= getRootNode();
		if (rootNode == null) {
			return new MultiTextEdit(); // no changes
		}
		
		ASTNode root= rootNode.getProgramRoot();
		if (!(root instanceof Program)) {
			throw new IllegalArgumentException("This API can only be used if the AST is created from a compilation unit or class file"); //$NON-NLS-1$
		}
		Program astRoot= (Program) root;
		ITypeRoot typeRoot = astRoot.getTypeRoot();
		if (typeRoot == null || typeRoot.getBuffer() == null) {
			throw new IllegalArgumentException("This API can only be used if the AST is created from a compilation unit or class file"); //$NON-NLS-1$
		}
		
		char[] content= typeRoot.getBuffer().getCharacters();
		LineInformation lineInfo= LineInformation.create(astRoot);
		String lineDelim= typeRoot.findRecommendedLineSeparator();
		Map options= typeRoot.getJavaProject().getOptions(true);
		
		return internalRewriteAST(content, lineInfo, lineDelim, astRoot.comments(), options, rootNode);
	}
	 */

	private TextEdit internalRewriteAST(IDocument document, char[] content, LineInformation lineInfo, String lineDelim, List commentNodes, Map options, ASTNode rootNode) {
		TextEdit result = new MultiTextEdit();
		//validateASTNotModified(rootNode);

		TargetSourceRangeComputer sourceRangeComputer = getExtendedSourceRangeComputer();
		this.eventStore.prepareMovedNodes(sourceRangeComputer);

		ASTRewriteAnalyzer visitor = new ASTRewriteAnalyzer(ast.lexer(), document, lineInfo, lineDelim, result, this.eventStore, this.nodeStore, commentNodes, options, sourceRangeComputer);
		rootNode.accept(visitor);

		this.eventStore.revertMovedNodes();
		return result;
	}

