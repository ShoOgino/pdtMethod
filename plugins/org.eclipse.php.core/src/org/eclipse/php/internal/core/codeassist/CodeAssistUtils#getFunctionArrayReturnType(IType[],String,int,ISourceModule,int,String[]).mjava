	/**
	 * example:(new class1())->avc2()[1][1]->avc1()
	 * 
	 * @param types
	 * @param method
	 * @param mask
	 * @param sourceModule
	 * @param offset
	 * @return
	 */
	private static IType[] getFunctionArrayReturnType(IType[] types,
			String method, int mask, ISourceModule sourceModule, int offset,
			String[] argNames) {
		PHPTypeInferencer typeInferencer = new PHPTypeInferencer();
		ModuleDeclaration moduleDeclaration = SourceParserUtil
				.getModuleDeclaration(sourceModule, null);
		IContext context = ASTUtils.findContext(sourceModule,
				moduleDeclaration, offset);
		// XXX context cannot be null
		if (context == null) {
			context = new BasicContext(sourceModule, moduleDeclaration);
			Logger.log(Logger.WARNING, "Context is null!"); //$NON-NLS-1$
		}

		IEvaluatedType evaluatedType;
		boolean usePhpDoc = (mask & USE_PHPDOC) != 0;
		if (usePhpDoc) {
			PHPDocMethodReturnTypeGoal phpDocGoal = new PHPDocMethodReturnTypeGoal(
					context, types, method);
			evaluatedType = typeInferencer.evaluateTypePHPDoc(phpDocGoal);
			if (evaluatedType instanceof MultiTypeType) {
				List<IType> tmpList = new LinkedList<IType>();
				List<IEvaluatedType> possibleTypes = ((MultiTypeType) evaluatedType)
						.getTypes();
				for (IEvaluatedType possibleType : possibleTypes) {
					IType[] tmpArray = PHPTypeInferenceUtils.getModelElements(
							possibleType, (ISourceModuleContext) context,
							offset, (IModelAccessCache) null);
					if (tmpArray != null && tmpArray.length > 0) {
						tmpList.addAll(Arrays.asList(tmpArray));
					}
				}
				// the elements are filtered already
				return tmpList.toArray(new IType[tmpList.size()]);
			}

			// modelElements = PHPTypeInferenceUtils.getModelElements(
			// evaluatedType, (ISourceModuleContext) context, offset);
			// if (modelElements != null) {
			// return modelElements;
			// }
		}

		MethodElementReturnTypeGoal methodGoal = new MethodElementReturnTypeGoal(
				context, types, method, argNames);
		evaluatedType = typeInferencer.evaluateType(methodGoal);

		if (evaluatedType instanceof MultiTypeType) {
			List<IType> tmpList = new LinkedList<IType>();
			List<IEvaluatedType> possibleTypes = ((MultiTypeType) evaluatedType)
					.getTypes();
			for (IEvaluatedType possibleType : possibleTypes) {
				IType[] tmpArray = PHPTypeInferenceUtils.getModelElements(
						possibleType, (ISourceModuleContext) context, offset,
						(IModelAccessCache) null);
				if (tmpArray != null) {
					tmpList.addAll(Arrays.asList(tmpArray));
				}
			}
			// the elements are filtered already
			return tmpList.toArray(new IType[tmpList.size()]);
		}

		return EMPTY_TYPES;
	}

