	/**
	 * Returns one of the keyword constants or <code>TokenIDENT</code> for a
	 * scanned identifier.
	 * 
	 * @param s
	 *            a scanned identifier
	 * @return one of the constants defined in {@link Symbols}
	 */
	private int getToken(String s) {
		Assert.isNotNull(s);

		switch (s.length()) {
		case 2:
			if ("if".equals(s)) {
				return TokenIF;
			}
			if ("do".equals(s)) {
				return TokenDO;
			}
			break;
		case 3:
			if ("for".equals(s)) {
				return TokenFOR;
			}
			if ("try".equals(s)) {
				return TokenTRY;
			}
			if ("new".equals(s)) {
				return TokenNEW;
			}
			break;
		case 4:
			if ("case".equals(s)) {
				return TokenCASE;
			}
			if ("else".equals(s)) {
				return TokenELSE;
			}
			if ("enum".equals(s)) {
				return TokenENUM;
			}
			if ("goto".equals(s)) {
				return TokenGOTO;
			}
			break;
		case 5:
			if ("break".equals(s)) {
				return TokenBREAK;
			}
			if ("catch".equals(s)) {
				return TokenCATCH;
			}
			if ("class".equals(s)) {
				return TokenCLASS;
			}
			if ("while".equals(s)) {
				return TokenWHILE;
			}
			if ("array".equals(s)) {
				return TokenARRAY;
			}
			break;
		case 6:
			if ("return".equals(s)) {
				return TokenRETURN;
			}
			if ("static".equals(s)) {
				return TokenSTATIC;
			}
			if ("switch".equals(s)) {
				return TokenSWITCH;
			}
			break;
		case 7:
			if ("default".equals(s)) {
				return TokenDEFAULT;
			}
			if ("finally".equals(s)) {
				return TokenFINALLY;
			}
			if ("foreach".equals(s)) {
				return TokenFOR;
			}
			break;
		case 9:
			if ("interface".equals(s)) {
				return TokenINTERFACE;
			}
			break;
		case 12:
			if ("synchronized".equals(s)) {
				return TokenSYNCHRONIZED;
			}
			break;
		}
		return TokenIDENT;
	}

