	@Override
	public StructuredDocumentEvent updateRegion(Object requester,
			IStructuredDocumentRegion flatnode, String changes,
			int requestStart, int lengthToReplace) {
		isFullReparsed = true;
		try {
			final int offset = requestStart - flatnode.getStartOffset()
					- getStart();

			// support the <?php case
			if (offset < 4) {
				return null;
			}
			// checks for odd quotes
			final String deletedText = lengthToReplace == 0 ? "" : flatnode.getParentDocument().get(requestStart, lengthToReplace); //$NON-NLS-1$
			final int length = changes.length();
			if (startQuoted(deletedText) || startQuoted(changes)) {
				return null;
			}

			// get the region to re-parse
			ITextRegion tokenStart = tokensContaier.getToken(offset == 0 ? 0
					: offset - 1);
			ITextRegion tokenEnd = tokensContaier.getToken(offset
					+ lengthToReplace);

			// make sure, region to re-parse doesn't start with unknown token
			while (PHPRegionTypes.UNKNOWN_TOKEN.equals(tokenStart.getType())
					&& (tokenStart.getStart() > 0)) {
				tokenStart = tokensContaier.getToken(tokenStart.getStart() - 1);
			}

			// move sure, region to re-parse doesn't end with unknown token
			while (PHPRegionTypes.UNKNOWN_TOKEN.equals(tokenEnd.getType())
					&& (tokensContaier.getLastToken() != tokenEnd)) {
				tokenEnd = tokensContaier.getToken(tokenEnd.getEnd() + 1);
			}

			boolean shouldDeprecatedKeyword = false;
			int previousIndex = tokensContaier.phpTokens.indexOf(tokenStart) - 1;
			if (previousIndex >= 0) {
				ITextRegion previousRegion = tokensContaier.phpTokens
						.get(previousIndex);
				if (PhpTokenContainer.deprecatedKeywordAfter(previousRegion
						.getType())) {
					shouldDeprecatedKeyword = true;
				}
				if (tokenStart.getType().equals(PHPRegionTypes.PHP_COMMENT)
						&& tokenStart.getLength() == 1
						&& previousRegion.getType().equals(
								PHPRegionTypes.PHP_COMMENT_START)) {
					requestStart = previousRegion.getStart();
				}

			}

			int newTokenOffset = tokenStart.getStart();

			if (isHereDoc(tokenStart)) {
				return null;
			}

			// get start and end states
			final LexerState startState = tokensContaier
					.getState(newTokenOffset);
			final LexerState endState = tokensContaier.getState(tokenEnd
					.getEnd() + 1);

			final PhpTokenContainer newContainer = new PhpTokenContainer();
			final AbstractPhpLexer phpLexer = getPhpLexer(new DocumentReader(
					flatnode, changes, requestStart, lengthToReplace,
					newTokenOffset), startState);

			Object state = startState;
			try {
				String yylex = phpLexer.getNextToken();
				if (shouldDeprecatedKeyword
						&& PhpTokenContainer.isKeyword(yylex)) {
					yylex = PHPRegionTypes.PHP_STRING;
				}
				int yylength;
				final int toOffset = offset + length;
				while (yylex != null && newTokenOffset <= toOffset
						&& yylex != PHPRegionTypes.PHP_CLOSETAG) {
					yylength = phpLexer.getLength();
					newContainer.addLast(yylex, newTokenOffset, yylength,
							yylength, state);
					newTokenOffset += yylength;
					state = phpLexer.createLexicalStateMemento();
					yylex = phpLexer.getNextToken();
				}
				if (yylex == PHPRegionTypes.WHITESPACE) {
					yylength = phpLexer.getLength();
					newContainer.adjustWhitespace(yylex, newTokenOffset,
							yylength, yylength, state);
				}
			} catch (IOException e) {
				Logger.logException(e);
			}

			// if the fast reparser couldn't lex - - reparse all
			if (newContainer.isEmpty()) {
				return null;
			}

			// if the two streams end with the same lexer sate -
			// 1. replace the regions
			// 2. adjust next regions start location
			// 3. update state changes
			final int size = length - lengthToReplace;
			final int end = newContainer.getLastToken().getEnd();

			if (!state.equals(endState) || tokenEnd.getEnd() + size != end) {
				return null;
			}

			// 1. replace the regions
			tokensContaier.removeTokensSubList(tokenStart, tokenEnd);
			ITextRegion[] newTokens = newContainer.getPhpTokens();

			// now, add the new ones
			tokensContaier.addNewTokens(newTokens);

			// 2. adjust next regions start location
			tokensContaier.adjustNextRegion(size);

			// 3. update state changes
			tokensContaier.updateStateChanges(newContainer, tokenStart
					.getStart(), end);
			isFullReparsed = false;

			return super.updateRegion(requester, flatnode, changes,
					requestStart, lengthToReplace);

		} catch (BadLocationException e) {
			PHPCorePlugin.log(e);
			return null; // causes to full reparse in this case
		}
	}

