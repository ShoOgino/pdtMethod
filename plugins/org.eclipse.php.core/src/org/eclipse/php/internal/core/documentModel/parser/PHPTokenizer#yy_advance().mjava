	/**
	 * Gets the next input character.
	 * 
	 * @return the next character of the input stream, EOF if the end of the
	 *         stream is reached.
	 * @exception IOException
	 *                if any I/O-Error occurs
	 */
	private int yy_advance() throws java.io.IOException {

		/* standard case */
		if (yy_currentPos < yy_endRead)
			return yy_buffer[yy_currentPos++];

		/* if the eof is reached, we don't need to work hard */
		if (yy_atEOF)
			return YYEOF;

		/* otherwise: need to refill the buffer */

		/* first: make room (if you can) */
		if (yy_startRead > 0) {
			System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, yy_endRead
					- yy_startRead);

			/* translate stored positions */
			yy_endRead -= yy_startRead;
			yy_currentPos -= yy_startRead;
			yy_markedPos -= yy_startRead;
			yy_pushbackPos -= yy_startRead;
			yy_startRead = 0;
		}

		/* is the buffer big enough? */
		if (yy_currentPos >= yy_buffer.length) {
			/* if not: blow it up */
			char newBuffer[] = new char[yy_currentPos * 2];
			System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
			yy_buffer = newBuffer;
		}

		/* finally: fill the buffer with new input */
		int numRead = yy_reader.read(yy_buffer, yy_endRead, yy_buffer.length
				- yy_endRead);

		if (numRead == -1)
			return YYEOF;

		yy_endRead += numRead;

		return yy_buffer[yy_currentPos++];
	}

