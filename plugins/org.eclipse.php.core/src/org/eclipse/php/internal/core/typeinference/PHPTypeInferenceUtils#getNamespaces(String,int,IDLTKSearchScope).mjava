	/**
	 * This method returns namespaces by prefix.
	 * As this method can be heavy FakeType is returned.
	 * 
	 * @param prefix Namespace prefix
	 * @param matchRule Search match rule
	 * @param scope Search scope
	 * @return namespace element array
	 */
	public static IType[] getNamespaces(String prefix, int matchRule, final IDLTKSearchScope scope) {
		final Collection<IType> elements = new LinkedList<IType>();

		final HandleFactory handleFactory = new HandleFactory();
		SearchEngine searchEngine = new SearchEngine();

		try {
			searchEngine.searchAllTypeNames(null, 0, prefix.toCharArray(), matchRule, IDLTKSearchConstants.DECLARATIONS, scope, new TypeNameRequestor() {
				public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, char[][] superTypes, String path) {
					if (PHPFlags.isNamespace(modifiers)) {
						Openable openable = handleFactory.createOpenable(path, scope);
						ModelElement parent = openable;
						elements.add(new FakeType(parent, new String(simpleTypeName), modifiers, null));
					}
				}
			}, IDLTKSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
		} catch (ModelException e) {
			Logger.logException(e);
		}

		return (IType[]) elements.toArray(new IType[elements.size()]);
	}

