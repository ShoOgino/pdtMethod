  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  public int next_token() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      boolean zzR = false;
      for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                                                             zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          zzR = false;
          break;
        case '\r':
          yyline++;
          zzR = true;
          break;
        case '\n':
          if (zzR)
            zzR = false;
          else {
            yyline++;
          }
          break;
        default:
          zzR = false;
        }
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean zzPeek;
        if (zzMarkedPosL < zzEndReadL)
          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        else if (zzAtEOF)
          zzPeek = false;
        else {
          boolean eof = zzRefill();
          zzEndReadL = zzEndRead;
          zzMarkedPosL = zzMarkedPos;
          zzBufferL = zzBuffer;
          if (eof) 
            zzPeek = false;
          else 
            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        }
        if (zzPeek) yyline--;
      }
      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 16: 
          { startTagsState(PHPDocTagKinds.TODO);
          }
        case 80: break;
        case 44: 
          { setNewTag(PHPDocTagKinds.RETURN);
          }
        case 81: break;
        case 51: 
          { startTagsState(PHPDocTagKinds.VERSION);
          }
        case 82: break;
        case 45: 
          { setNewTag(PHPDocTagKinds.GLOBAL);
          }
        case 83: break;
        case 32: 
          { startTagsState(PHPDocTagKinds.ACCESS);
          }
        case 84: break;
        case 71: 
          { startTagsState(PHPDocTagKinds.DEPRECATED);
          }
        case 85: break;
        case 13: 
          { startTagsState(PHPDocTagKinds.VAR);
          }
        case 86: break;
        case 69: 
          { setNewTag(PHPDocTagKinds.COPYRIGHT);
          }
        case 87: break;
        case 15: 
          { setNewTag(PHPDocTagKinds.VAR);
          }
        case 88: break;
        case 42: 
          { setNewTag(PHPDocTagKinds.STATIC);
          }
        case 89: break;
        case 59: 
          { startTagsState(PHPDocTagKinds.PROPERTY);
          }
        case 90: break;
        case 18: 
          { startTagsState(PHPDocTagKinds.DESC);
          }
        case 91: break;
        case 63: 
          { setNewTag(PHPDocTagKinds.CATEGORY);
          }
        case 92: break;
        case 12: 
          { startTagsState(PHPDocTagKinds.SEE);
          }
        case 93: break;
        case 14: 
          { setNewTag(PHPDocTagKinds.SEE);
          }
        case 94: break;
        case 50: 
          { startTagsState(PHPDocTagKinds.LICENSE);
          }
        case 95: break;
        case 21: 
          { setNewTag(PHPDocTagKinds.TODO);
          }
        case 96: break;
        case 43: 
          { setNewTag(PHPDocTagKinds.THROWS);
          }
        case 97: break;
        case 8: 
          { maxNumberofLines = 5;
    handleDocEnd_shortDesc();
    return -1;
          }
        case 98: break;
        case 11: 
          { updateStartPos();
        yybegin(ST_IN_SHORT_DESC);
          }
        case 99: break;
        case 65: 
          { setNewTag(PHPDocTagKinds.INTERNAL);
          }
        case 100: break;
        case 20: 
          { startTagsState(PHPDocTagKinds.NAME);
          }
        case 101: break;
        case 19: 
          { startTagsState(PHPDocTagKinds.LINK);
          }
        case 102: break;
        case 7: 
          { maxNumberofLines = 4;
    handleDocEnd_shortDesc();
    return -1;
          }
        case 103: break;
        case 17: 
          { startTagsState(PHPDocTagKinds.USES);
          }
        case 104: break;
        case 23: 
          { setNewTag(PHPDocTagKinds.DESC);
          }
        case 105: break;
        case 52: 
          { setNewTag(PHPDocTagKinds.EXAMPLE);
          }
        case 106: break;
        case 9: 
          { handleDocEnd_longDesc();return -1;
          }
        case 107: break;
        case 29: 
          { setNewTag(PHPDocTagKinds.SINCE);
          }
        case 108: break;
        case 31: 
          { setNewTag(PHPDocTagKinds.FINAL);
          }
        case 109: break;
        case 79: 
          { setNewTag(PHPDocTagKinds.PROPERTY_WRITE);
          }
        case 110: break;
        case 47: 
          { setNewTag(PHPDocTagKinds.METHOD);
          }
        case 111: break;
        case 55: 
          { setNewTag(PHPDocTagKinds.VERSION);
          }
        case 112: break;
        case 38: 
          { startTagsState(PHPDocTagKinds.IGNORE);
          }
        case 113: break;
        case 67: 
          { startTagsState(PHPDocTagKinds.COPYRIGHT);
          }
        case 114: break;
        case 36: 
          { startTagsState(PHPDocTagKinds.RETURN);
          }
        case 115: break;
        case 68: 
          { setNewTag(PHPDocTagKinds.STATICVAR);
          }
        case 116: break;
        case 58: 
          { startTagsState(PHPDocTagKinds.CATEGORY);
          }
        case 117: break;
        case 78: 
          { startTagsState(PHPDocTagKinds.PROPERTY_WRITE);
          }
        case 118: break;
        case 49: 
          { startTagsState(PHPDocTagKinds.PACKAGE);
          }
        case 119: break;
        case 37: 
          { startTagsState(PHPDocTagKinds.GLOBAL);
          }
        case 120: break;
        case 25: 
          { setNewTag(PHPDocTagKinds.NAME);
          }
        case 121: break;
        case 26: 
          { startTagsState(PHPDocTagKinds.SINCE);
          }
        case 122: break;
        case 24: 
          { setNewTag(PHPDocTagKinds.LINK);
          }
        case 123: break;
        case 41: 
          { setNewTag(PHPDocTagKinds.AUTHOR);
          }
        case 124: break;
        case 22: 
          { setNewTag(PHPDocTagKinds.USES);
          }
        case 125: break;
        case 60: 
          { startTagsState(PHPDocTagKinds.INTERNAL);
          }
        case 126: break;
        case 75: 
          { setNewTag(PHPDocTagKinds.FILESOURCE);
          }
        case 127: break;
        case 61: 
          { setNewTag(PHPDocTagKinds.ABSTRACT);
          }
        case 128: break;
        case 62: 
          { setNewTag(PHPDocTagKinds.TUTORIAL);
          }
        case 129: break;
        case 54: 
          { setNewTag(PHPDocTagKinds.LICENSE);
          }
        case 130: break;
        case 30: 
          { setNewTag(PHPDocTagKinds.PARAM);
          }
        case 131: break;
        case 3: 
          { hendleNewLine();
          }
        case 132: break;
        case 1: 
          { updateStartPos();
          }
        case 133: break;
        case 28: 
          { startTagsState(PHPDocTagKinds.FINAL);
          }
        case 134: break;
        case 35: 
          { startTagsState(PHPDocTagKinds.THROWS);
          }
        case 135: break;
        case 40: 
          { setNewTag(PHPDocTagKinds.ACCESS);
          }
        case 136: break;
        case 4: 
          { startLongDescState();
          }
        case 137: break;
        case 34: 
          { startTagsState(PHPDocTagKinds.STATIC);
          }
        case 138: break;
        case 73: 
          { setNewTag(PHPDocTagKinds.SUBPACKAGE);
          }
        case 139: break;
        case 5: 
          { appendText();
          }
        case 140: break;
        case 77: 
          { setNewTag(PHPDocTagKinds.PROPERTY_READ);
          }
        case 141: break;
        case 66: 
          { startTagsState(PHPDocTagKinds.STATICVAR);
          }
        case 142: break;
        case 39: 
          { startTagsState(PHPDocTagKinds.METHOD);
          }
        case 143: break;
        case 27: 
          { startTagsState(PHPDocTagKinds.PARAM);
          }
        case 144: break;
        case 53: 
          { setNewTag(PHPDocTagKinds.PACKAGE);
          }
        case 145: break;
        case 56: 
          { startTagsState(PHPDocTagKinds.ABSTRACT);
          }
        case 146: break;
        case 57: 
          { startTagsState(PHPDocTagKinds.TUTORIAL);
          }
        case 147: break;
        case 74: 
          { setNewTag(PHPDocTagKinds.DEPRECATED);
          }
        case 148: break;
        case 72: 
          { startTagsState(PHPDocTagKinds.FILESOURCE);
          }
        case 149: break;
        case 33: 
          { startTagsState(PHPDocTagKinds.AUTHOR);
          }
        case 150: break;
        case 76: 
          { startTagsState(PHPDocTagKinds.PROPERTY_READ);
          }
        case 151: break;
        case 46: 
          { setNewTag(PHPDocTagKinds.IGNORE);
          }
        case 152: break;
        case 64: 
          { setNewTag(PHPDocTagKinds.PROPERTY);
          }
        case 153: break;
        case 6: 
          { appendText();
    startLongDescState();
          }
        case 154: break;
        case 10: 
          { handleDocEnd_inTags();return -1;
          }
        case 155: break;
        case 70: 
          { startTagsState(PHPDocTagKinds.SUBPACKAGE);
          }
        case 156: break;
        case 48: 
          { startTagsState(PHPDocTagKinds.EXAMPLE);
          }
        case 157: break;
        case 2: 
          { 
          }
        case 158: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            zzDoEOF();
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }

