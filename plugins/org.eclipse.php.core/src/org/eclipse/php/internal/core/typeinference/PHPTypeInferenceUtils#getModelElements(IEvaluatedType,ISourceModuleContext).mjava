	/**
	 * Converts IEvaluatedType to IModelElement, if found. This method filters elements using file network dependencies.
	 * @param evaluatedType Evaluated type
	 * @return model elements
	 */
	public static IModelElement[] getModelElements(IEvaluatedType evaluatedType, ISourceModuleContext context) {
		IModelElement[] elements = null;
		ISourceModule sourceModule = context.getSourceModule();

		if (evaluatedType instanceof ModelClassType) {
			return new IModelElement[] { ((ModelClassType) evaluatedType).getTypeDeclaration() };
		}
		if (evaluatedType instanceof PHPClassType) {
			IScriptProject scriptProject = sourceModule.getScriptProject();
			if (!ScriptProject.hasScriptNature(scriptProject.getProject())) {
				List<IModelElement> result = new LinkedList<IModelElement>();
				try {
					IType[] types = sourceModule.getTypes();
					for (IType t : types) {
						if (t.getElementName().equalsIgnoreCase(evaluatedType.getTypeName())) {
							result.add(t);
							break;
						}
					}
				} catch (ModelException e) {
					if (DLTKCore.DEBUG) {
						e.printStackTrace();
					}
				}
				return result.toArray(new IModelElement[result.size()]);
			} else {
				IDLTKSearchScope scope = SearchEngine.createSearchScope(scriptProject);
				elements = PHPMixinModel.getInstance(scriptProject).getClass(((PHPClassType) evaluatedType).getTypeName(), scope);
			}
		} else if (evaluatedType instanceof AmbiguousType) {
			List<IModelElement> tmpList = new LinkedList<IModelElement>();
			IEvaluatedType[] possibleTypes = ((AmbiguousType) evaluatedType).getPossibleTypes();
			for (IEvaluatedType possibleType : possibleTypes) {
				IModelElement[] tmpArray = getModelElements(possibleType, context);
				if (tmpArray != null) {
					tmpList.addAll(Arrays.asList(tmpArray));
				}
			}
			elements = tmpList.toArray(new IModelElement[tmpList.size()]);
		}
		return PHPModelUtils.filterElements(sourceModule, elements);
	}

