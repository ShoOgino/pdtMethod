	protected boolean isClassFunctionCompletion(TextSequence statementText, int offset, int line, String functionName, int startFunctionPosition) {
		startFunctionPosition = PHPTextSequenceUtilities.readBackwardSpaces(statementText, startFunctionPosition);
		if (startFunctionPosition <= 2) {
			return false;
		}
		boolean isClassTriger = false;
		boolean isParent = false;
		String triggerText = statementText.subSequence(startFunctionPosition - 2, startFunctionPosition).toString();
		if (triggerText.equals(OBJECT_FUNCTIONS_TRIGGER)) {
		} else if (triggerText.equals(CLASS_FUNCTIONS_TRIGGER)) {
			isClassTriger = true;
			if (startFunctionPosition >= 8) {
				String parentText = statementText.subSequence(startFunctionPosition - 8, startFunctionPosition - 2).toString();
				if (parentText.equals("parent")) { //$NON-NLS-1$
					isParent = true;
				}
			}
		} else {
			return false;
		}
		
		if (internalPHPRegion.getType() == PHPRegionTypes.PHP_OBJECT_OPERATOR || internalPHPRegion.getType() == PHPRegionTypes.PHP_PAAMAYIM_NEKUDOTAYIM) {
			try {
				ITextRegion nextRegion = phpScriptRegion.getPhpToken(internalPHPRegion.getEnd());
				wordEndOffset = regionContainer.getStartOffset() + phpScriptRegion.getStart() + nextRegion.getTextEnd();
			} catch (BadLocationException e) {
			}
		}

		IType[] types = CodeAssistUtils.getTypesFor(sourceModule, statementText, startFunctionPosition, offset, line, determineObjsFromOtherFiles());
		if (types != null) {
			if (hasWhitespaceAtEnd && functionName.length() > 0) {
				// check if current position is between the end of a function call and open bracket.
				return CodeAssistUtils.isClassFunctionCall(sourceModule, types, functionName);
			}
	
			if (isClassTriger) {
				if (isParent) {
					// Collect parents:
					Set<IType> parents = new HashSet<IType>();
					for (IType type : types) {
						try {
							ITypeHierarchy hierarchy = type.newSupertypeHierarchy(null);
							parents.addAll(Arrays.asList(hierarchy.getAllSuperclasses(type)));
						} catch (ModelException e) {
							if (DLTKCore.DEBUG_COMPLETION) {
								e.printStackTrace();
							}
						}
					}
					showClassCall(offset, parents.toArray(new IType[parents.size()]), functionName, false, false);
				} else {
					showClassStaticCall(offset, types, functionName);
				}
			} else {
				String parent = statementText.toString().substring(0, statementText.toString().lastIndexOf(OBJECT_FUNCTIONS_TRIGGER)).trim();
				boolean isThisVar = parent.equals("$this"); //$NON-NLS-1$
				//boolean addVariableDollar = parent.endsWith("()");
				boolean addVariableDollar = false;
				showClassCall(offset, types, functionName, isThisVar, addVariableDollar);
			}
		}
		return true;
	}

