	/*
	 * Returns the declaring type signature of the element represented by the
	 * given binding key. Returns the signature of the element if it is a type.
	 * 
	 * @return the declaring type signature
	 */
	/*
	 * public static String getDeclaringTypeSignature(String key) {
	 * keyToSignature keyToSignature = new KeyToSignature(key,
	 * KeyToSignature.DECLARING_TYPE); keyToSignature.parse(); return
	 * keyToSignature.signature.toString(); }
	 */
	/*
	 * Appends to the given buffer the fully qualified name (as it appears in
	 * the source) of the given type private static void
	 * getFullyQualifiedName(Type type, StringBuffer buffer) { switch
	 * (type.getNodeType()) { case ASTNode.ARRAY_TYPE: ArrayType arrayType =
	 * (ArrayType) type; getFullyQualifiedName(arrayType.getElementType(),
	 * buffer); for (int i = 0, length = arrayType.getDimensions(); i < length;
	 * i++) { buffer.append('['); buffer.append(']'); } break; case
	 * ASTNode.PARAMETERIZED_TYPE: ParameterizedType parameterizedType =
	 * (ParameterizedType) type;
	 * getFullyQualifiedName(parameterizedType.getType(), buffer);
	 * buffer.append('<'); Iterator iterator =
	 * parameterizedType.typeArguments().iterator(); boolean isFirst = true;
	 * while (iterator.hasNext()) { if (!isFirst) buffer.append(','); else
	 * isFirst = false; Type typeArgument = (Type) iterator.next();
	 * getFullyQualifiedName(typeArgument, buffer); } buffer.append('>'); break;
	 * case ASTNode.PRIMITIVE_TYPE: buffer.append(((PrimitiveType)
	 * type).getPrimitiveTypeCode().toString()); break; case
	 * ASTNode.QUALIFIED_TYPE: buffer.append(((QualifiedType)
	 * type).getName().getFullyQualifiedName()); break; case
	 * ASTNode.SIMPLE_TYPE: buffer.append(((SimpleType)
	 * type).getName().getFullyQualifiedName()); break; case
	 * ASTNode.WILDCARD_TYPE: buffer.append('?'); WildcardType wildcardType =
	 * (WildcardType) type; Type bound = wildcardType.getBound(); if (bound ==
	 * null) return; if (wildcardType.isUpperBound()) {
	 * buffer.append(" extends "); //$NON-NLS-1$ } else {
	 * buffer.append(" super "); //$NON-NLS-1$ } getFullyQualifiedName(bound,
	 * buffer); break; } }
	 */
	/**
	 * Returns a trimmed version the simples names returned by Signature.
	 */
	public static String[] getTrimmedSimpleNames(String name) {
		String[] result = Signature.getSimpleNames(name);
		for (int i = 0, length = result.length; i < length; i++) {
			result[i] = result[i].trim();
		}
		return result;
	}

