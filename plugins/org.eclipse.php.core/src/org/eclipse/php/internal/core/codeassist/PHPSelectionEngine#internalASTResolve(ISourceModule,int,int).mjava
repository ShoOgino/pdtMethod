	private IModelElement[] internalASTResolve(ISourceModule sourceModule,
			int offset, int end) throws ModelException {
		String source;

		try {
			source = sourceModule.getSource();
			offset = PHPTextSequenceUtilities.readIdentifierStartIndex(source,
					offset, true);
		} catch (IndexOutOfBoundsException ex) {
			// ISourceModule.getSource() may throw
			// ArrayIndexOutOfBoundsException and
			// PHPTextSequenceUtilities.readIdentifierStartIndex() may throw
			// StringIndexOutOfBoundExceptio in case when main thread
			// modifies editor content in parallel to this action in background
			// thread
			return null;
		}

		end = PHPTextSequenceUtilities
				.readIdentifierEndIndex(source, end, true);

		int methodEnd = PHPTextSequenceUtilities.getMethodEndIndex(source, end);
		if (methodEnd != -1) {
			end = methodEnd;
		}

		ModuleDeclaration parsedUnit = SourceParserUtil.getModuleDeclaration(
				sourceModule, null);

		// boolean inDocBlock=false;
		if (parsedUnit instanceof PHPModuleDeclaration) {
			PHPModuleDeclaration phpModuleDeclaration = (PHPModuleDeclaration) parsedUnit;
			List<PHPDocBlock> phpBlocks = phpModuleDeclaration
					.getPhpDocBlocks();
			for (PHPDocBlock phpDocBlock : phpBlocks) {
				int realStart = phpDocBlock.sourceStart();
				int realEnd = phpDocBlock.sourceEnd();
				if (realStart <= offset && realEnd >= end) {
					// inDocBlock=true;
					PHPDocTag[] tags = phpDocBlock.getTags();
					if (tags != null) {
						for (PHPDocTag phpDocTag : tags) {
							if (phpDocTag.sourceStart() <= offset
									&& phpDocTag.sourceEnd() >= end) {
								SimpleReference[] references = phpDocTag
										.getReferences();
								if (references != null) {
									for (SimpleReference simpleReference : references) {
										if (simpleReference instanceof TypeReference) {
											TypeReference typeReference = (TypeReference) simpleReference;
											if (typeReference.sourceStart() <= offset
													&& typeReference
															.sourceEnd() >= end) {
												IType[] types = filterNS(PHPModelUtils
														.getTypes(typeReference
																.getName(),
																sourceModule,
																offset, null));
												return types;

											}
										}
									}
								}
							}
						}
					}
					return null;
				}
			}
		}
		ASTNode node = ASTUtils.findMinimalNode(parsedUnit, offset, end);
		if (node != null) {

			IContext context = ASTUtils.findContext(sourceModule, parsedUnit,
					node);
			if (context != null) {

				// Function call:
				if (node instanceof PHPCallExpression) {
					PHPCallExpression callExpression = (PHPCallExpression) node;
					if (callExpression.getReceiver() != null) {
						IEvaluatedType receiverType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, callExpression.getReceiver());
						// (new class1())->avc2()[1][1]->avc1()
						if ((receiverType instanceof MultiTypeType)
								&& callExpression.getReceiver() instanceof PHPCallExpression) {
							PHPCallExpression receiverCallExpression = (PHPCallExpression) callExpression
									.getReceiver();
							if (((PHPCallArgumentsList) receiverCallExpression
									.getArgs()).getArrayDereferenceList() != null
									&& !((PHPCallArgumentsList) receiverCallExpression
											.getArgs())
											.getArrayDereferenceList()
											.getChilds().isEmpty()) {
								receiverType = new AmbiguousType(
										((MultiTypeType) receiverType)
												.getTypes().toArray(
														new IEvaluatedType[0]));
							}
						}
						if (receiverType != null) {
							IModelElement[] elements = null;
							if ((receiverType instanceof PHPClassType)
									&& ((PHPClassType) receiverType).isGlobal()) {

								IDLTKSearchScope scope = SearchEngine
										.createSearchScope(sourceModule
												.getScriptProject());
								elements = PhpModelAccess.getDefault()
										.findTypes(receiverType.getTypeName(),
												MatchRule.EXACT, 0, 0, scope,
												null);
								LinkedList<IModelElement> result = new LinkedList<IModelElement>();
								for (IModelElement element : elements) {
									IModelElement parent = element.getParent();
									while (parent.getParent() instanceof IType) {
										parent = parent.getParent();
									}
									if ((parent instanceof IType)
											&& PHPFlags
													.isNamespace(((IType) parent)
															.getFlags())) {
										// Do nothing
									} else {
										result.add(element);
									}
								}
								elements = result.toArray(new IType[result
										.size()]);
							} else {
								elements = PHPTypeInferenceUtils
										.getModelElements(receiverType,
												(ISourceModuleContext) context,
												offset);
							}
							List<IModelElement> methods = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											IMethod[] method = PHPModelUtils
													.getFirstTypeHierarchyMethod(
															type, null,
															callExpression
																	.getName(),
															true, null);
											methods.addAll(Arrays
													.asList(method));
										} catch (CoreException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return methods.toArray(new IModelElement[methods
									.size()]);
						}
					} else {
						SimpleReference callName = callExpression.getCallName();
						String methodName = callName instanceof FullyQualifiedReference ? ((FullyQualifiedReference) callName)
								.getFullyQualifiedName() : callName.getName();
						IMethod[] functions = PHPModelUtils.getFunctions(
								methodName, sourceModule, offset, null, null);
						return functions == null ? EMPTY : functions;
					}
				}
				// Static field or constant access:
				else if (node instanceof StaticDispatch) {
					StaticDispatch dispatch = (StaticDispatch) node;
					String fieldName = null;
					if (dispatch instanceof StaticConstantAccess) {
						fieldName = ((StaticConstantAccess) dispatch)
								.getConstant().getName();
					} else if (dispatch instanceof StaticFieldAccess) {
						ASTNode field = ((StaticFieldAccess) dispatch)
								.getField();
						if (field instanceof VariableReference) {
							fieldName = ((VariableReference) field).getName();
						}
					}
					if (fieldName != null && dispatch.getDispatcher() != null) {
						IEvaluatedType dispatcherType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, dispatch.getDispatcher());
						if (dispatcherType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(dispatcherType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> fields = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											fields.addAll(Arrays
													.asList(PHPModelUtils
															.getTypeField(type,
																	fieldName,
																	true)));
										} catch (ModelException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}
					}
				}
				// Dynamic field access:
				else if (node instanceof FieldAccess) {
					FieldAccess fieldAccess = (FieldAccess) node;
					ASTNode field = fieldAccess.getField();
					String fieldName = null;
					if (field instanceof SimpleReference) {
						fieldName = ((SimpleReference) field).getName();
					}
					if (fieldName != null
							&& fieldAccess.getDispatcher() != null) {
						IEvaluatedType dispatcherType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, fieldAccess.getDispatcher());
						if (dispatcherType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(dispatcherType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> fields = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											fields.addAll(Arrays
													.asList(PHPModelUtils
															.getTypeField(type,
																	fieldName,
																	true)));
										} catch (ModelException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}
					}
				} else if (node instanceof NamespaceReference) {
					String name = ((NamespaceReference) node).getName();
					IType[] namespace = PHPModelUtils.getNamespaceOf(name
							+ NamespaceReference.NAMESPACE_SEPARATOR,
							sourceModule, offset, null, null);
					return namespace == null ? EMPTY : namespace;
				}
				// Class/Interface reference:
				else if (node instanceof TypeReference) {
					IEvaluatedType evaluatedType = PHPTypeInferenceUtils
							.resolveExpression(sourceModule, node);
					if (evaluatedType == null) {
						return EMPTY;
					}
					String name = evaluatedType.getTypeName();
					IType[] types = PHPModelUtils.getTypes(name, sourceModule,
							offset, null, null,
							!(evaluatedType instanceof PHPTraitType));
					if (types == null || types.length == 0) {
						// This can be a constant or namespace in PHP 5.3:
						if (name.charAt(0) == NamespaceReference.NAMESPACE_SEPARATOR) {
							name = name.substring(1);
						}
						IDLTKSearchScope scope = SearchEngine
								.createSearchScope(sourceModule
										.getScriptProject());
						if (evaluatedType instanceof PHPTraitType) {
							types = PhpModelAccess.getDefault().findTraits(
									null, name, MatchRule.EXACT,
									Modifiers.AccNameSpace, 0, scope, null);
						} else {
							types = PhpModelAccess.getDefault().findTypes(null,
									name, MatchRule.EXACT,
									Modifiers.AccNameSpace, 0, scope, null);
						}

						if (types == null || types.length == 0) {
							name = NamespaceReference.NAMESPACE_SEPARATOR
									+ name;
							return PHPModelUtils.getFields(name, sourceModule,
									offset, null, null);
						}
					}
					return types;
				}
				// 'new' statement
				else if (node instanceof ClassInstanceCreation) {
					ClassInstanceCreation newNode = (ClassInstanceCreation) node;

					Expression className = newNode.getClassName();
					if ((className instanceof SimpleReference || className instanceof FullyQualifiedReference)) {
						IEvaluatedType evaluatedType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, node);
						return getConstructorsIfAny(extractClasses(PHPModelUtils
								.getTypes(evaluatedType.getTypeName(),
										sourceModule, offset, null, null)));
					}
				}
				// Class name in declaration
				else if ((node instanceof TypeDeclaration || node instanceof MethodDeclaration)
						&& ((Declaration) node).getNameStart() <= offset
						&& ((Declaration) node).getNameEnd() >= offset) {

					IModelElement element = sourceModule.getElementAt(node
							.sourceStart());
					if (element != null) {
						return new IModelElement[] { element };
					}
				}/*
				 * else if (node instanceof Scalar) { Scalar scalar = (Scalar)
				 * node; if (PHPModelUtils.isQuotesString(scalar.getValue())) {
				 * 
				 * IEvaluatedType evaluatedType = PHPTypeInferenceUtils
				 * .resolveExpression(sourceModule, node); if (evaluatedType !=
				 * null) {
				 * 
				 * IType[] types = PHPModelUtils.getTypes(
				 * evaluatedType.getTypeName(), sourceModule, offset, null,
				 * null); return types; } } }
				 */
			}
		}
		return null;
	}

