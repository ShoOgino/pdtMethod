	private IModelElement[] internalASTResolve(ISourceModule sourceModule,
			int offset, int end) throws ModelException {

		String source = sourceModule.getSource();
		offset = PHPTextSequenceUtilities.readIdentifierStartIndex(source,
				offset, true);
		end = PHPTextSequenceUtilities
				.readIdentifierEndIndex(source, end, true);

		int methodEnd = PHPTextSequenceUtilities.getMethodEndIndex(source, end);
		if (methodEnd != -1) {
			end = methodEnd;
		}

		ModuleDeclaration parsedUnit = SourceParserUtil.getModuleDeclaration(
				sourceModule, null);

		ASTNode node = ASTUtils.findMinimalNode(parsedUnit, offset, end);
		if (node != null) {

			IContext context = ASTUtils.findContext(sourceModule, parsedUnit,
					node);
			if (context != null) {

				// Function call:
				if (node instanceof PHPCallExpression) {
					PHPCallExpression callExpression = (PHPCallExpression) node;
					if (callExpression.getReceiver() != null) {
						IEvaluatedType receiverType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, callExpression.getReceiver());
						if (receiverType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(receiverType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> methods = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											IMethod[] method = PHPModelUtils
													.getFirstTypeHierarchyMethod(
															type, null,
															callExpression
																	.getName(),
															true, null);
											methods.addAll(Arrays
													.asList(method));
										} catch (CoreException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return methods.toArray(new IModelElement[methods
									.size()]);
						}
					} else {
						SimpleReference callName = callExpression.getCallName();
						String methodName = callName instanceof FullyQualifiedReference ? ((FullyQualifiedReference) callName)
								.getFullyQualifiedName() : callName.getName();
						IMethod[] functions = PHPModelUtils.getFunctions(
								methodName, sourceModule, offset, null, null);
						return functions == null ? EMPTY : functions;
					}
				}
				// Static field or constant access:
				else if (node instanceof StaticDispatch) {
					StaticDispatch dispatch = (StaticDispatch) node;
					String fieldName = null;
					if (dispatch instanceof StaticConstantAccess) {
						fieldName = ((StaticConstantAccess) dispatch)
								.getConstant().getName();
					} else if (dispatch instanceof StaticFieldAccess) {
						ASTNode field = ((StaticFieldAccess) dispatch)
								.getField();
						if (field instanceof VariableReference) {
							fieldName = ((VariableReference) field).getName();
						}
					}
					if (fieldName != null && dispatch.getDispatcher() != null) {
						IEvaluatedType dispatcherType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, dispatch.getDispatcher());
						if (dispatcherType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(dispatcherType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> fields = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											fields.addAll(Arrays
													.asList(PHPModelUtils
															.getTypeField(type,
																	fieldName,
																	true)));
										} catch (ModelException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}
					}
				}
				// Dynamic field access:
				else if (node instanceof FieldAccess) {
					FieldAccess fieldAccess = (FieldAccess) node;
					ASTNode field = fieldAccess.getField();
					String fieldName = null;
					if (field instanceof SimpleReference) {
						fieldName = ((SimpleReference) field).getName();
					}
					if (fieldName != null
							&& fieldAccess.getDispatcher() != null) {
						IEvaluatedType dispatcherType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, parsedUnit,
										context, fieldAccess.getDispatcher());
						if (dispatcherType != null) {
							IModelElement[] elements = PHPTypeInferenceUtils
									.getModelElements(dispatcherType,
											(ISourceModuleContext) context,
											offset);
							List<IModelElement> fields = new LinkedList<IModelElement>();
							if (elements != null) {
								for (IModelElement element : elements) {
									if (element instanceof IType) {
										IType type = (IType) element;
										try {
											fields.addAll(Arrays
													.asList(PHPModelUtils
															.getTypeField(type,
																	fieldName,
																	true)));
										} catch (ModelException e) {
											PHPCorePlugin.log(e);
										}
									}
								}
							}
							return fields.toArray(new IModelElement[fields
									.size()]);
						}
					}
				} else if (node instanceof NamespaceReference) {
					String name = ((NamespaceReference) node).getName();
					IType[] namespace = PHPModelUtils.getNamespaceOf(name
							+ NamespaceReference.NAMESPACE_SEPARATOR,
							sourceModule, offset, null, null);
					return namespace == null ? EMPTY : namespace;
				}
				// Class/Interface reference:
				else if (node instanceof TypeReference) {
					IEvaluatedType evaluatedType = PHPTypeInferenceUtils
							.resolveExpression(sourceModule, node);
					String name = evaluatedType.getTypeName();
					IType[] types = PHPModelUtils.getTypes(name, sourceModule,
							offset, null, null);
					if (types == null || types.length == 0) {
						// This can be a constant or namespace in PHP 5.3:
						if (name.charAt(0) == NamespaceReference.NAMESPACE_SEPARATOR) {
							name = name.substring(1);
						}
						IDLTKSearchScope scope = SearchEngine
								.createSearchScope(sourceModule
										.getScriptProject());
						types = PhpModelAccess.getDefault().findTypes(null,
								name, MatchRule.EXACT, Modifiers.AccNameSpace,
								0, scope, null);
						if (types == null || types.length == 0) {
							name = NamespaceReference.NAMESPACE_SEPARATOR
									+ name;
							return PHPModelUtils.getFields(name, sourceModule,
									offset, null, null);
						}
					}
					return types;
				}
				// 'new' statement
				else if (node instanceof ClassInstanceCreation) {
					ClassInstanceCreation newNode = (ClassInstanceCreation) node;

					Expression className = newNode.getClassName();
					if ((className instanceof SimpleReference || className instanceof FullyQualifiedReference)) {
						IEvaluatedType evaluatedType = PHPTypeInferenceUtils
								.resolveExpression(sourceModule, node);
						return getConstructorsIfAny(extractClasses(PHPModelUtils
								.getTypes(evaluatedType.getTypeName(),
										sourceModule, offset, null, null)));
					}
				}
				// Class name in declaration
				else if ((node instanceof TypeDeclaration || node instanceof MethodDeclaration)
						&& ((Declaration) node).getNameStart() <= offset
						&& ((Declaration) node).getNameEnd() >= offset) {

					IModelElement element = sourceModule.getElementAt(node
							.sourceStart());
					if (element != null) {
						return new IModelElement[] { element };
					}
				}
			}
		}
		return null;
	}

