  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   IOException  if any I/O-Error occurs
   */
  public int next_token() throws java.io.IOException {
    int yy_input;
    int yy_action;

    // cached fields:
    int yy_currentPos_l;
    int yy_startRead_l;
    int yy_markedPos_l;
    int yy_endRead_l = yy_endRead;
    char [] yy_buffer_l = yy_buffer;
    char [] yycmap_l = yycmap;

    int [] yytrans_l = yytrans;
    int [] yy_rowMap_l = yy_rowMap;
    byte [] yy_attr_l = YY_ATTRIBUTE;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      boolean yy_r = false;
      for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                                                             yy_currentPos_l++) {
        switch (yy_buffer_l[yy_currentPos_l]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          yy_r = false;
          break;
        case '\r':
          yyline++;
          yy_r = true;
          break;
        case '\n':
          if (yy_r)
            yy_r = false;
          else {
            yyline++;
          }
          break;
        default:
          yy_r = false;
        }
      }

      if (yy_r) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean yy_peek;
        if (yy_markedPos_l < yy_endRead_l)
          yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        else if (yy_atEOF)
          yy_peek = false;
        else {
          boolean eof = yy_refill();
          yy_markedPos_l = yy_markedPos;
          yy_buffer_l = yy_buffer;
          if (eof) 
            yy_peek = false;
          else 
            yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        }
        if (yy_peek) yyline--;
      }
      if (yy_markedPos_l > yy_startRead) {
        switch (yy_buffer_l[yy_markedPos_l-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yy_atBOL = true;
          break;
        case '\r': 
          if (yy_markedPos_l < yy_endRead_l)
            yy_atBOL = yy_buffer_l[yy_markedPos_l] != '\n';
          else if (yy_atEOF)
            yy_atBOL = false;
          else {
            boolean eof = yy_refill();
            yy_markedPos_l = yy_markedPos;
            yy_buffer_l = yy_buffer;
            if (eof) 
              yy_atBOL = false;
            else 
              yy_atBOL = yy_buffer_l[yy_markedPos_l] != '\n';
          }
          break;
        default:
          yy_atBOL = false;
        }
      }
      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos = 
                       yy_startRead = yy_markedPos_l;

      if (yy_atBOL)
        yy_state = YY_LEXSTATE[yy_lexical_state+1];
      else
        yy_state = YY_LEXSTATE[yy_lexical_state];


      yy_forAction: {
        while (true) {

          if (yy_currentPos_l < yy_endRead_l)
            yy_input = yy_buffer_l[yy_currentPos_l++];
          else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          }
          else {
            // store back cached positions
            yy_currentPos  = yy_currentPos_l;
            yy_markedPos   = yy_markedPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l  = yy_currentPos;
            yy_markedPos_l   = yy_markedPos;
            yy_buffer_l      = yy_buffer;
            yy_endRead_l     = yy_endRead;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            }
            else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
          int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
          if (yy_next == -1) break yy_forAction;
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ( (yy_attributes & 1) == 1 ) {
            yy_action = yy_state; 
            yy_markedPos_l = yy_currentPos_l; 
            if ( (yy_attributes & 8) == 8 ) break yy_forAction;
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      switch (yy_action) {

        case 21: 
        case 22: 
          { appendText(); }
        case 380: break;
        case 281: 
          { setNewTag("final"); }
        case 381: break;
        case 274: 
          { setNewTag("param"); }
        case 382: break;
        case 267: 
          { setNewTag("since"); }
        case 383: break;
        case 239: 
          { setNewTag("name"); }
        case 384: break;
        case 236: 
          { setNewTag("link"); }
        case 385: break;
        case 233: 
          { setNewTag("desc"); }
        case 386: break;
        case 227: 
          { setNewTag("uses"); }
        case 387: break;
        case 222: 
          { setNewTag("todo"); }
        case 388: break;
        case 363: 
          { startTagsState("staticvar"); }
        case 389: break;
        case 365: 
          { startTagsState("copyright"); }
        case 390: break;
        case 373: 
          { startTagsState("subpackage"); }
        case 391: break;
        case 374: 
          { startTagsState("deprecated"); }
        case 392: break;
        case 375: 
          { startTagsState("filesource"); }
        case 393: break;
        case 302: 
          { setNewTag("access"); }
        case 394: break;
        case 303: 
          { setNewTag("author"); }
        case 395: break;
        case 304: 
          { setNewTag("static"); }
        case 396: break;
        case 307: 
          { setNewTag("return"); }
        case 397: break;
        case 311: 
          { setNewTag("global"); }
        case 398: break;
        case 313: 
          { setNewTag("ignore"); }
        case 399: break;
        case 338: 
          { setNewTag("example"); }
        case 400: break;
        case 339: 
          { setNewTag("package"); }
        case 401: break;
        case 342: 
          { setNewTag("license"); }
        case 402: break;
        case 344: 
          { setNewTag("version"); }
        case 403: break;
        case 34: 
        case 36: 
        case 37: 
          { 
    appendText();
    startLongDescState();
 }
        case 404: break;
        case 35: 
          { 
    maxNumberofLines = 4;
    handleDocEnd_shortDesc();
 }
        case 405: break;
        case 42: 
          { 
    maxNumberofLines = 5;
    handleDocEnd_shortDesc();
 }
        case 406: break;
        case 82: 
          { 
        updateStartPos();
        yybegin(ST_IN_SHORT_DESC);
     }
        case 407: break;
        case 131: 
        case 132: 
          { 
        updateStartPos();
        yybegin(ST_IN_SHORT_DESC);
     }
        case 408: break;
        case 376: 
          { setNewTag("subpackage"); }
        case 409: break;
        case 260: 
          { startTagsState("final"); }
        case 410: break;
        case 253: 
          { startTagsState("param"); }
        case 411: break;
        case 246: 
          { startTagsState("since"); }
        case 412: break;
        case 284: 
          { startTagsState("access"); }
        case 413: break;
        case 285: 
          { startTagsState("author"); }
        case 414: break;
        case 286: 
          { startTagsState("static"); }
        case 415: break;
        case 289: 
          { startTagsState("return"); }
        case 416: break;
        case 293: 
          { startTagsState("global"); }
        case 417: break;
        case 295: 
          { startTagsState("ignore"); }
        case 418: break;
        case 357: 
          { setNewTag("tutorial"); }
        case 419: break;
        case 368: 
          { setNewTag("staticvar"); }
        case 420: break;
        case 11: 
        case 12: 
          { hendleNewLine(); }
        case 421: break;
        case 378: 
          { setNewTag("filesource"); }
        case 422: break;
        case 360: 
          { setNewTag("internal"); }
        case 423: break;
        case 187: 
          { setNewTag("var"); }
        case 424: break;
        case 165: 
          { setNewTag("see"); }
        case 425: break;
        case 377: 
          { setNewTag("deprecated"); }
        case 426: break;
        case 16: 
        case 17: 
          { startLongDescState(); }
        case 427: break;
        case 325: 
          { startTagsState("example"); }
        case 428: break;
        case 326: 
          { startTagsState("package"); }
        case 429: break;
        case 329: 
          { startTagsState("license"); }
        case 430: break;
        case 331: 
          { startTagsState("version"); }
        case 431: break;
        case 345: 
          { startTagsState("abstract"); }
        case 432: break;
        case 348: 
          { startTagsState("tutorial"); }
        case 433: break;
        case 349: 
          { startTagsState("category"); }
        case 434: break;
        case 351: 
          { startTagsState("internal"); }
        case 435: break;
        case 3: 
        case 5: 
        case 7: 
        case 24: 
        case 25: 
        case 28: 
        case 29: 
        case 38: 
        case 39: 
        case 41: 
        case 61: 
        case 66: 
          { updateStartPos(); }
        case 436: break;
        case 358: 
          { setNewTag("category"); }
        case 437: break;
        case 370: 
          { setNewTag("copyright"); }
        case 438: break;
        case 213: 
          { startTagsState("name"); }
        case 439: break;
        case 210: 
          { startTagsState("link"); }
        case 440: break;
        case 207: 
          { startTagsState("desc"); }
        case 441: break;
        case 201: 
          { startTagsState("uses"); }
        case 442: break;
        case 196: 
          { startTagsState("todo"); }
        case 443: break;
        case 137: 
          { startTagsState("see"); }
        case 444: break;
        case 159: 
          { startTagsState("var"); }
        case 445: break;
        case 354: 
          { setNewTag("abstract"); }
        case 446: break;
        case 64: 
          { handleDocEnd_inTags(); }
        case 447: break;
        case 60: 
          { handleDocEnd_longDesc(); }
        case 448: break;
        case 26: 
        case 27: 
        case 30: 
          {  }
        case 449: break;
        case 20: 
        case 23: 
          {  }
        case 450: break;
        case 10: 
        case 13: 
        case 14: 
        case 15: 
        case 18: 
        case 19: 
          {  }
        case 451: break;
        case 8: 
        case 9: 
          {  }
        case 452: break;
        default: 
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            yy_do_eof();
            return YYEOF;
          } 
          else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }

