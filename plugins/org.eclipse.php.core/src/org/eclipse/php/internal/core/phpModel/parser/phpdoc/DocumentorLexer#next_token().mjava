  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  public int next_token() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      boolean zzR = false;
      for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                                                             zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          zzR = false;
          break;
        case '\r':
          yyline++;
          zzR = true;
          break;
        case '\n':
          if (zzR)
            zzR = false;
          else {
            yyline++;
          }
          break;
        default:
          zzR = false;
        }
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean zzPeek;
        if (zzMarkedPosL < zzEndReadL)
          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        else if (zzAtEOF)
          zzPeek = false;
        else {
          boolean eof = zzRefill();
          zzEndReadL = zzEndRead;
          zzMarkedPosL = zzMarkedPos;
          zzBufferL = zzBuffer;
          if (eof) 
            zzPeek = false;
          else 
            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        }
        if (zzPeek) yyline--;
      }
      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 12: 
          { startTagsState("see");
          }
        case 72: break;
        case 55: 
          { startTagsState("tutorial");
          }
        case 73: break;
        case 41: 
          { setNewTag("static");
          }
        case 74: break;
        case 7: 
          { maxNumberofLines = 4;
    handleDocEnd_shortDesc();
          }
        case 75: break;
        case 28: 
          { startTagsState("final");
          }
        case 76: break;
        case 43: 
          { setNewTag("return");
          }
        case 77: break;
        case 11: 
          { updateStartPos();
        yybegin(ST_IN_SHORT_DESC);
          }
        case 78: break;
        case 59: 
          { setNewTag("tutorial");
          }
        case 79: break;
        case 20: 
          { startTagsState("name");
          }
        case 80: break;
        case 39: 
          { setNewTag("access");
          }
        case 81: break;
        case 62: 
          { startTagsState("staticvar");
          }
        case 82: break;
        case 22: 
          { setNewTag("uses");
          }
        case 83: break;
        case 46: 
          { startTagsState("example");
          }
        case 84: break;
        case 49: 
          { startTagsState("version");
          }
        case 85: break;
        case 27: 
          { startTagsState("param");
          }
        case 86: break;
        case 24: 
          { setNewTag("link");
          }
        case 87: break;
        case 64: 
          { setNewTag("staticvar");
          }
        case 88: break;
        case 69: 
          { setNewTag("subpackage");
          }
        case 89: break;
        case 38: 
          { startTagsState("ignore");
          }
        case 90: break;
        case 31: 
          { setNewTag("final");
          }
        case 91: break;
        case 71: 
          { setNewTag("filesource");
          }
        case 92: break;
        case 70: 
          { setNewTag("deprecated");
          }
        case 93: break;
        case 17: 
          { startTagsState("uses");
          }
        case 94: break;
        case 9: 
          { handleDocEnd_longDesc();
          }
        case 95: break;
        case 54: 
          { startTagsState("abstract");
          }
        case 96: break;
        case 5: 
          { appendText();
          }
        case 97: break;
        case 19: 
          { startTagsState("link");
          }
        case 98: break;
        case 56: 
          { startTagsState("category");
          }
        case 99: break;
        case 58: 
          { setNewTag("abstract");
          }
        case 100: break;
        case 66: 
          { startTagsState("subpackage");
          }
        case 101: break;
        case 68: 
          { startTagsState("filesource");
          }
        case 102: break;
        case 67: 
          { startTagsState("deprecated");
          }
        case 103: break;
        case 63: 
          { startTagsState("copyright");
          }
        case 104: break;
        case 48: 
          { startTagsState("license");
          }
        case 105: break;
        case 60: 
          { setNewTag("category");
          }
        case 106: break;
        case 47: 
          { startTagsState("package");
          }
        case 107: break;
        case 35: 
          { startTagsState("throws");
          }
        case 108: break;
        case 23: 
          { setNewTag("desc");
          }
        case 109: break;
        case 57: 
          { startTagsState("internal");
          }
        case 110: break;
        case 30: 
          { setNewTag("param");
          }
        case 111: break;
        case 50: 
          { setNewTag("example");
          }
        case 112: break;
        case 45: 
          { setNewTag("ignore");
          }
        case 113: break;
        case 33: 
          { startTagsState("author");
          }
        case 114: break;
        case 15: 
          { setNewTag("var");
          }
        case 115: break;
        case 65: 
          { setNewTag("copyright");
          }
        case 116: break;
        case 14: 
          { setNewTag("see");
          }
        case 117: break;
        case 53: 
          { setNewTag("version");
          }
        case 118: break;
        case 61: 
          { setNewTag("internal");
          }
        case 119: break;
        case 26: 
          { startTagsState("since");
          }
        case 120: break;
        case 18: 
          { startTagsState("desc");
          }
        case 121: break;
        case 37: 
          { startTagsState("global");
          }
        case 122: break;
        case 6: 
          { appendText();
    startLongDescState();
          }
        case 123: break;
        case 42: 
          { setNewTag("throws");
          }
        case 124: break;
        case 21: 
          { setNewTag("todo");
          }
        case 125: break;
        case 34: 
          { startTagsState("static");
          }
        case 126: break;
        case 52: 
          { setNewTag("license");
          }
        case 127: break;
        case 40: 
          { setNewTag("author");
          }
        case 128: break;
        case 4: 
          { startLongDescState();
          }
        case 129: break;
        case 36: 
          { startTagsState("return");
          }
        case 130: break;
        case 51: 
          { setNewTag("package");
          }
        case 131: break;
        case 1: 
          { updateStartPos();
          }
        case 132: break;
        case 16: 
          { startTagsState("todo");
          }
        case 133: break;
        case 32: 
          { startTagsState("access");
          }
        case 134: break;
        case 44: 
          { setNewTag("global");
          }
        case 135: break;
        case 8: 
          { maxNumberofLines = 5;
    handleDocEnd_shortDesc();
          }
        case 136: break;
        case 29: 
          { setNewTag("since");
          }
        case 137: break;
        case 3: 
          { hendleNewLine();
          }
        case 138: break;
        case 25: 
          { setNewTag("name");
          }
        case 139: break;
        case 2: 
          { 
          }
        case 140: break;
        case 10: 
          { handleDocEnd_inTags();
          }
        case 141: break;
        case 13: 
          { startTagsState("var");
          }
        case 142: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            zzDoEOF();
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }

