	public IEvaluatedType[] getFunctionReturnType(IMethod functionElement) {

		ISourceModule sourceModule = functionElement.getSourceModule();
		ModuleDeclaration sourceModuleDeclaration = SourceParserUtil
				.getModuleDeclaration(sourceModule);
		MethodDeclaration functionDeclaration = null;
		try {
			functionDeclaration = PHPModelUtils.getNodeByMethod(
					sourceModuleDeclaration, functionElement);

		} catch (ModelException e) {
			if (DLTKCore.DEBUG) {
				e.printStackTrace();
			}
		}
		FileContext fileContext = new FileContext(sourceModule,
				sourceModuleDeclaration);

		final List<IEvaluatedType> evaluated = new LinkedList<IEvaluatedType>();
		final List<Expression> returnExpressions = new LinkedList<Expression>();

		if (functionDeclaration != null) {

			ASTVisitor visitor = new ASTVisitor() {
				public boolean visitGeneral(ASTNode node) throws Exception {
					if (node instanceof ReturnStatement) {
						ReturnStatement statement = (ReturnStatement) node;
						Expression expr = statement.getExpr();
						if (expr == null) {
							evaluated.add(PHPSimpleTypes.VOID);
						} else {
							returnExpressions.add(expr);
						}
					}
					return super.visitGeneral(node);
				}
			};

			try {
				functionDeclaration.traverse(visitor);
			} catch (Exception e) {
				if (DLTKCore.DEBUG) {
					e.printStackTrace();
				}
			}
		}

		for (Expression expr : returnExpressions) {
			IEvaluatedType resolvedExpression = PHPTypeInferenceUtils
					.resolveExpression(sourceModule, sourceModuleDeclaration,
							fileContext, expr);
			evaluated.add(resolvedExpression);
		}
		return (IEvaluatedType[]) evaluated
				.toArray(new IEvaluatedType[evaluated.size()]);
	}

