    private Statistics computeStatsFromAggregates(Dim dimension) {
        Statistics stats= new Statistics();
        long aggregateCount= 0;
        double averageSum= 0;
        long countSum= 0;
        double stdevSum= 0;
        
//        Set acquiredAggregates= new HashSet();
        for (int i= 0; i < fDataPoints.length; i++) {
            DataPoint point= fDataPoints[i];
            Scalar scalar= point.getScalar(dimension);
            if (scalar == null)
                continue;
            
            Integer aggregate= new Integer(point.getStep());
            // allow for multiple measurements that were each stored with their own 
            // aggregate values
//            Assert.assertTrue(acquiredAggregates.add(aggregate));
            
            long magnitude= scalar.getMagnitude();
            switch (aggregate.intValue()) {
                case InternalPerformanceMeter.AVERAGE:
                    averageSum += magnitude;
                    aggregateCount++;
                    break;
                case InternalPerformanceMeter.STDEV:
                    // see DB.internalStore
                    stdevSum += Double.longBitsToDouble(magnitude);
                    break;
                case InternalPerformanceMeter.SIZE:
                    countSum += magnitude;
                    break;
                default:
                    Assert.fail("only average, stdev and size are supported in aggregate mode"); //$NON-NLS-1$
                    break;
            }
        }
        
        stats.average= averageSum / aggregateCount;
        stats.stddev= stdevSum / aggregateCount; // XXX this does not work! have to treat multiple runs like normal measurement data
        stats.count= countSum;
        stats.sum= Math.round(stats.count * stats.average);
        
        return stats;
    }

