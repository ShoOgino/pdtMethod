    private Statistics computeStatsFromMeasurements(Dim dimension, Set<Integer> steps) {
        Statistics stats= new Statistics();
        long mags[];
        switch (steps.size()) {
            case 1:
                // if there is only one Step, we don't calculate the delta. happens for startup tests
                mags= new long[fDataPoints.length];
                for (int i= 0; i < fDataPoints.length; i++) {
                    Scalar sc= fDataPoints[i].getScalar(dimension);
                    mags[i]= sc == null ? 0 : sc.getMagnitude();
                }
                break;
            case 2:
                int count= fDataPoints.length / 2;
                mags= new long[count];
                for (int i= 0; i < count; i ++) {
                    DataPoint before= fDataPoints[2 * i];
                    Assert.assertTrue("wrong order of steps", before.getStep() == InternalPerformanceMeter.BEFORE); //$NON-NLS-1$
                    DataPoint after= fDataPoints[2 * i + 1];
                    Assert.assertTrue("wrong order of steps", after.getStep() == InternalPerformanceMeter.AFTER); //$NON-NLS-1$

                    Scalar delta= getDelta(before, after, dimension);
                    long magnitude= delta.getMagnitude();
                    mags[i]= magnitude;
                }
                break;
            default:
                Assert.fail("cannot handle more than two steps in measurement mode"); //$NON-NLS-1$
                return null; // dummy
        }
        
        for (int i= 0; i < mags.length; i++) {
            stats.sum += mags[i];
            stats.count++;
        }
        
        if (stats.count > 0) {
            stats.average= (double) stats.sum / stats.count;
            if (stats.count == 1) {
	            stats.stddev= 0;
            } else {
	            double squaredDeviations= 0;
	            for (int i= 0; i < mags.length; i++) {
	                double deviation= stats.average - mags[i];
	                squaredDeviations += deviation * deviation;
	            }
	            stats.stddev= Math.sqrt(squaredDeviations / (stats.count - 1)); // unbiased sample stdev
            }
        } else {
            stats.average= 0;
            stats.stddev= 0;
        }
        
        return stats;
    }

